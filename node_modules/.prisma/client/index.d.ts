
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model LeaveRequest
 * 
 */
export type LeaveRequest = $Result.DefaultSelection<Prisma.$LeaveRequestPayload>
/**
 * Model LeaveBalance
 * 
 */
export type LeaveBalance = $Result.DefaultSelection<Prisma.$LeaveBalancePayload>
/**
 * Model LeavePolicy
 * 
 */
export type LeavePolicy = $Result.DefaultSelection<Prisma.$LeavePolicyPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model LeaveDocument
 * 
 */
export type LeaveDocument = $Result.DefaultSelection<Prisma.$LeaveDocumentPayload>
/**
 * Model Holiday
 * 
 */
export type Holiday = $Result.DefaultSelection<Prisma.$HolidayPayload>
/**
 * Model AttendanceRecord
 * 
 */
export type AttendanceRecord = $Result.DefaultSelection<Prisma.$AttendanceRecordPayload>
/**
 * Model AttendancePolicy
 * 
 */
export type AttendancePolicy = $Result.DefaultSelection<Prisma.$AttendancePolicyPayload>
/**
 * Model EmployeeSalary
 * 
 */
export type EmployeeSalary = $Result.DefaultSelection<Prisma.$EmployeeSalaryPayload>
/**
 * Model MonthlySalary
 * 
 */
export type MonthlySalary = $Result.DefaultSelection<Prisma.$MonthlySalaryPayload>
/**
 * Model SalaryDeduction
 * 
 */
export type SalaryDeduction = $Result.DefaultSelection<Prisma.$SalaryDeductionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  admin: 'admin',
  manager: 'manager',
  employee: 'employee'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const LeaveType: {
  annual: 'annual',
  sick: 'sick',
  casual: 'casual',
  maternity: 'maternity',
  paternity: 'paternity',
  emergency: 'emergency'
};

export type LeaveType = (typeof LeaveType)[keyof typeof LeaveType]


export const LeaveStatus: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
  escalated: 'escalated'
};

export type LeaveStatus = (typeof LeaveStatus)[keyof typeof LeaveStatus]


export const HalfDayPeriod: {
  morning: 'morning',
  afternoon: 'afternoon'
};

export type HalfDayPeriod = (typeof HalfDayPeriod)[keyof typeof HalfDayPeriod]


export const HolidayType: {
  public: 'public',
  company: 'company',
  religious: 'religious',
  national: 'national'
};

export type HolidayType = (typeof HolidayType)[keyof typeof HolidayType]


export const AttendanceStatus: {
  present: 'present',
  absent: 'absent',
  late: 'late',
  half_day: 'half_day',
  on_leave: 'on_leave'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const SalaryStatus: {
  draft: 'draft',
  calculated: 'calculated',
  approved: 'approved',
  paid: 'paid',
  cancelled: 'cancelled'
};

export type SalaryStatus = (typeof SalaryStatus)[keyof typeof SalaryStatus]


export const DeductionType: {
  leave_deduction: 'leave_deduction',
  tax_deduction: 'tax_deduction',
  other_deduction: 'other_deduction',
  bonus: 'bonus',
  overtime: 'overtime'
};

export type DeductionType = (typeof DeductionType)[keyof typeof DeductionType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type LeaveType = $Enums.LeaveType

export const LeaveType: typeof $Enums.LeaveType

export type LeaveStatus = $Enums.LeaveStatus

export const LeaveStatus: typeof $Enums.LeaveStatus

export type HalfDayPeriod = $Enums.HalfDayPeriod

export const HalfDayPeriod: typeof $Enums.HalfDayPeriod

export type HolidayType = $Enums.HolidayType

export const HolidayType: typeof $Enums.HolidayType

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type SalaryStatus = $Enums.SalaryStatus

export const SalaryStatus: typeof $Enums.SalaryStatus

export type DeductionType = $Enums.DeductionType

export const DeductionType: typeof $Enums.DeductionType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.leaveRequest`: Exposes CRUD operations for the **LeaveRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveRequests
    * const leaveRequests = await prisma.leaveRequest.findMany()
    * ```
    */
  get leaveRequest(): Prisma.LeaveRequestDelegate<ExtArgs>;

  /**
   * `prisma.leaveBalance`: Exposes CRUD operations for the **LeaveBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveBalances
    * const leaveBalances = await prisma.leaveBalance.findMany()
    * ```
    */
  get leaveBalance(): Prisma.LeaveBalanceDelegate<ExtArgs>;

  /**
   * `prisma.leavePolicy`: Exposes CRUD operations for the **LeavePolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeavePolicies
    * const leavePolicies = await prisma.leavePolicy.findMany()
    * ```
    */
  get leavePolicy(): Prisma.LeavePolicyDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.leaveDocument`: Exposes CRUD operations for the **LeaveDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveDocuments
    * const leaveDocuments = await prisma.leaveDocument.findMany()
    * ```
    */
  get leaveDocument(): Prisma.LeaveDocumentDelegate<ExtArgs>;

  /**
   * `prisma.holiday`: Exposes CRUD operations for the **Holiday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Holidays
    * const holidays = await prisma.holiday.findMany()
    * ```
    */
  get holiday(): Prisma.HolidayDelegate<ExtArgs>;

  /**
   * `prisma.attendanceRecord`: Exposes CRUD operations for the **AttendanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceRecords
    * const attendanceRecords = await prisma.attendanceRecord.findMany()
    * ```
    */
  get attendanceRecord(): Prisma.AttendanceRecordDelegate<ExtArgs>;

  /**
   * `prisma.attendancePolicy`: Exposes CRUD operations for the **AttendancePolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendancePolicies
    * const attendancePolicies = await prisma.attendancePolicy.findMany()
    * ```
    */
  get attendancePolicy(): Prisma.AttendancePolicyDelegate<ExtArgs>;

  /**
   * `prisma.employeeSalary`: Exposes CRUD operations for the **EmployeeSalary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeSalaries
    * const employeeSalaries = await prisma.employeeSalary.findMany()
    * ```
    */
  get employeeSalary(): Prisma.EmployeeSalaryDelegate<ExtArgs>;

  /**
   * `prisma.monthlySalary`: Exposes CRUD operations for the **MonthlySalary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonthlySalaries
    * const monthlySalaries = await prisma.monthlySalary.findMany()
    * ```
    */
  get monthlySalary(): Prisma.MonthlySalaryDelegate<ExtArgs>;

  /**
   * `prisma.salaryDeduction`: Exposes CRUD operations for the **SalaryDeduction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryDeductions
    * const salaryDeductions = await prisma.salaryDeduction.findMany()
    * ```
    */
  get salaryDeduction(): Prisma.SalaryDeductionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    LeaveRequest: 'LeaveRequest',
    LeaveBalance: 'LeaveBalance',
    LeavePolicy: 'LeavePolicy',
    AuditLog: 'AuditLog',
    LeaveDocument: 'LeaveDocument',
    Holiday: 'Holiday',
    AttendanceRecord: 'AttendanceRecord',
    AttendancePolicy: 'AttendancePolicy',
    EmployeeSalary: 'EmployeeSalary',
    MonthlySalary: 'MonthlySalary',
    SalaryDeduction: 'SalaryDeduction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "leaveRequest" | "leaveBalance" | "leavePolicy" | "auditLog" | "leaveDocument" | "holiday" | "attendanceRecord" | "attendancePolicy" | "employeeSalary" | "monthlySalary" | "salaryDeduction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      LeaveRequest: {
        payload: Prisma.$LeaveRequestPayload<ExtArgs>
        fields: Prisma.LeaveRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findFirst: {
            args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findMany: {
            args: Prisma.LeaveRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          create: {
            args: Prisma.LeaveRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          createMany: {
            args: Prisma.LeaveRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          delete: {
            args: Prisma.LeaveRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          update: {
            args: Prisma.LeaveRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          deleteMany: {
            args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          aggregate: {
            args: Prisma.LeaveRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveRequest>
          }
          groupBy: {
            args: Prisma.LeaveRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveRequestCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestCountAggregateOutputType> | number
          }
        }
      }
      LeaveBalance: {
        payload: Prisma.$LeaveBalancePayload<ExtArgs>
        fields: Prisma.LeaveBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          findFirst: {
            args: Prisma.LeaveBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          findMany: {
            args: Prisma.LeaveBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
          }
          create: {
            args: Prisma.LeaveBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          createMany: {
            args: Prisma.LeaveBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveBalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
          }
          delete: {
            args: Prisma.LeaveBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          update: {
            args: Prisma.LeaveBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          deleteMany: {
            args: Prisma.LeaveBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          aggregate: {
            args: Prisma.LeaveBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveBalance>
          }
          groupBy: {
            args: Prisma.LeaveBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveBalanceCountAggregateOutputType> | number
          }
        }
      }
      LeavePolicy: {
        payload: Prisma.$LeavePolicyPayload<ExtArgs>
        fields: Prisma.LeavePolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeavePolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeavePolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
          }
          findFirst: {
            args: Prisma.LeavePolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeavePolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
          }
          findMany: {
            args: Prisma.LeavePolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>[]
          }
          create: {
            args: Prisma.LeavePolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
          }
          createMany: {
            args: Prisma.LeavePolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeavePolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>[]
          }
          delete: {
            args: Prisma.LeavePolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
          }
          update: {
            args: Prisma.LeavePolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
          }
          deleteMany: {
            args: Prisma.LeavePolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeavePolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeavePolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
          }
          aggregate: {
            args: Prisma.LeavePolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeavePolicy>
          }
          groupBy: {
            args: Prisma.LeavePolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeavePolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeavePolicyCountArgs<ExtArgs>
            result: $Utils.Optional<LeavePolicyCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      LeaveDocument: {
        payload: Prisma.$LeaveDocumentPayload<ExtArgs>
        fields: Prisma.LeaveDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveDocumentPayload>
          }
          findFirst: {
            args: Prisma.LeaveDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveDocumentPayload>
          }
          findMany: {
            args: Prisma.LeaveDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveDocumentPayload>[]
          }
          create: {
            args: Prisma.LeaveDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveDocumentPayload>
          }
          createMany: {
            args: Prisma.LeaveDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveDocumentPayload>[]
          }
          delete: {
            args: Prisma.LeaveDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveDocumentPayload>
          }
          update: {
            args: Prisma.LeaveDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveDocumentPayload>
          }
          deleteMany: {
            args: Prisma.LeaveDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveDocumentPayload>
          }
          aggregate: {
            args: Prisma.LeaveDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveDocument>
          }
          groupBy: {
            args: Prisma.LeaveDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveDocumentCountAggregateOutputType> | number
          }
        }
      }
      Holiday: {
        payload: Prisma.$HolidayPayload<ExtArgs>
        fields: Prisma.HolidayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HolidayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HolidayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findFirst: {
            args: Prisma.HolidayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HolidayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findMany: {
            args: Prisma.HolidayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          create: {
            args: Prisma.HolidayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          createMany: {
            args: Prisma.HolidayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HolidayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          delete: {
            args: Prisma.HolidayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          update: {
            args: Prisma.HolidayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          deleteMany: {
            args: Prisma.HolidayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HolidayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HolidayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          aggregate: {
            args: Prisma.HolidayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoliday>
          }
          groupBy: {
            args: Prisma.HolidayGroupByArgs<ExtArgs>
            result: $Utils.Optional<HolidayGroupByOutputType>[]
          }
          count: {
            args: Prisma.HolidayCountArgs<ExtArgs>
            result: $Utils.Optional<HolidayCountAggregateOutputType> | number
          }
        }
      }
      AttendanceRecord: {
        payload: Prisma.$AttendanceRecordPayload<ExtArgs>
        fields: Prisma.AttendanceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findFirst: {
            args: Prisma.AttendanceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findMany: {
            args: Prisma.AttendanceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          create: {
            args: Prisma.AttendanceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          createMany: {
            args: Prisma.AttendanceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          delete: {
            args: Prisma.AttendanceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          update: {
            args: Prisma.AttendanceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          aggregate: {
            args: Prisma.AttendanceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceRecord>
          }
          groupBy: {
            args: Prisma.AttendanceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordCountAggregateOutputType> | number
          }
        }
      }
      AttendancePolicy: {
        payload: Prisma.$AttendancePolicyPayload<ExtArgs>
        fields: Prisma.AttendancePolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendancePolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendancePolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePolicyPayload>
          }
          findFirst: {
            args: Prisma.AttendancePolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendancePolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePolicyPayload>
          }
          findMany: {
            args: Prisma.AttendancePolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePolicyPayload>[]
          }
          create: {
            args: Prisma.AttendancePolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePolicyPayload>
          }
          createMany: {
            args: Prisma.AttendancePolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendancePolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePolicyPayload>[]
          }
          delete: {
            args: Prisma.AttendancePolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePolicyPayload>
          }
          update: {
            args: Prisma.AttendancePolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePolicyPayload>
          }
          deleteMany: {
            args: Prisma.AttendancePolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendancePolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendancePolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePolicyPayload>
          }
          aggregate: {
            args: Prisma.AttendancePolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendancePolicy>
          }
          groupBy: {
            args: Prisma.AttendancePolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendancePolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendancePolicyCountArgs<ExtArgs>
            result: $Utils.Optional<AttendancePolicyCountAggregateOutputType> | number
          }
        }
      }
      EmployeeSalary: {
        payload: Prisma.$EmployeeSalaryPayload<ExtArgs>
        fields: Prisma.EmployeeSalaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeSalaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSalaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeSalaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSalaryPayload>
          }
          findFirst: {
            args: Prisma.EmployeeSalaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSalaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeSalaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSalaryPayload>
          }
          findMany: {
            args: Prisma.EmployeeSalaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSalaryPayload>[]
          }
          create: {
            args: Prisma.EmployeeSalaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSalaryPayload>
          }
          createMany: {
            args: Prisma.EmployeeSalaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeSalaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSalaryPayload>[]
          }
          delete: {
            args: Prisma.EmployeeSalaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSalaryPayload>
          }
          update: {
            args: Prisma.EmployeeSalaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSalaryPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeSalaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeSalaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeSalaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSalaryPayload>
          }
          aggregate: {
            args: Prisma.EmployeeSalaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeSalary>
          }
          groupBy: {
            args: Prisma.EmployeeSalaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeSalaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeSalaryCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeSalaryCountAggregateOutputType> | number
          }
        }
      }
      MonthlySalary: {
        payload: Prisma.$MonthlySalaryPayload<ExtArgs>
        fields: Prisma.MonthlySalaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonthlySalaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlySalaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonthlySalaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlySalaryPayload>
          }
          findFirst: {
            args: Prisma.MonthlySalaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlySalaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonthlySalaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlySalaryPayload>
          }
          findMany: {
            args: Prisma.MonthlySalaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlySalaryPayload>[]
          }
          create: {
            args: Prisma.MonthlySalaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlySalaryPayload>
          }
          createMany: {
            args: Prisma.MonthlySalaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonthlySalaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlySalaryPayload>[]
          }
          delete: {
            args: Prisma.MonthlySalaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlySalaryPayload>
          }
          update: {
            args: Prisma.MonthlySalaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlySalaryPayload>
          }
          deleteMany: {
            args: Prisma.MonthlySalaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonthlySalaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MonthlySalaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlySalaryPayload>
          }
          aggregate: {
            args: Prisma.MonthlySalaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonthlySalary>
          }
          groupBy: {
            args: Prisma.MonthlySalaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonthlySalaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonthlySalaryCountArgs<ExtArgs>
            result: $Utils.Optional<MonthlySalaryCountAggregateOutputType> | number
          }
        }
      }
      SalaryDeduction: {
        payload: Prisma.$SalaryDeductionPayload<ExtArgs>
        fields: Prisma.SalaryDeductionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryDeductionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDeductionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryDeductionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDeductionPayload>
          }
          findFirst: {
            args: Prisma.SalaryDeductionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDeductionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryDeductionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDeductionPayload>
          }
          findMany: {
            args: Prisma.SalaryDeductionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDeductionPayload>[]
          }
          create: {
            args: Prisma.SalaryDeductionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDeductionPayload>
          }
          createMany: {
            args: Prisma.SalaryDeductionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryDeductionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDeductionPayload>[]
          }
          delete: {
            args: Prisma.SalaryDeductionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDeductionPayload>
          }
          update: {
            args: Prisma.SalaryDeductionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDeductionPayload>
          }
          deleteMany: {
            args: Prisma.SalaryDeductionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryDeductionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalaryDeductionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryDeductionPayload>
          }
          aggregate: {
            args: Prisma.SalaryDeductionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryDeduction>
          }
          groupBy: {
            args: Prisma.SalaryDeductionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryDeductionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryDeductionCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryDeductionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    subordinates: number
    leaveRequests: number
    approvedLeaves: number
    leaveBalances: number
    auditLogs: number
    createdPolicies: number
    createdHolidays: number
    attendanceRecords: number
    createdAttendancePolicies: number
    employeeSalary: number
    monthlySalaries: number
    approvedSalaries: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subordinates?: boolean | UserCountOutputTypeCountSubordinatesArgs
    leaveRequests?: boolean | UserCountOutputTypeCountLeaveRequestsArgs
    approvedLeaves?: boolean | UserCountOutputTypeCountApprovedLeavesArgs
    leaveBalances?: boolean | UserCountOutputTypeCountLeaveBalancesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    createdPolicies?: boolean | UserCountOutputTypeCountCreatedPoliciesArgs
    createdHolidays?: boolean | UserCountOutputTypeCountCreatedHolidaysArgs
    attendanceRecords?: boolean | UserCountOutputTypeCountAttendanceRecordsArgs
    createdAttendancePolicies?: boolean | UserCountOutputTypeCountCreatedAttendancePoliciesArgs
    employeeSalary?: boolean | UserCountOutputTypeCountEmployeeSalaryArgs
    monthlySalaries?: boolean | UserCountOutputTypeCountMonthlySalariesArgs
    approvedSalaries?: boolean | UserCountOutputTypeCountApprovedSalariesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaveBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveBalanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeavePolicyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedHolidaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolidayWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedAttendancePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendancePolicyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmployeeSalaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeSalaryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMonthlySalariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlySalaryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedSalariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlySalaryWhereInput
  }


  /**
   * Count Type LeaveRequestCountOutputType
   */

  export type LeaveRequestCountOutputType = {
    documents: number
    salaryDeductions: number
  }

  export type LeaveRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | LeaveRequestCountOutputTypeCountDocumentsArgs
    salaryDeductions?: boolean | LeaveRequestCountOutputTypeCountSalaryDeductionsArgs
  }

  // Custom InputTypes
  /**
   * LeaveRequestCountOutputType without action
   */
  export type LeaveRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequestCountOutputType
     */
    select?: LeaveRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeaveRequestCountOutputType without action
   */
  export type LeaveRequestCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveDocumentWhereInput
  }

  /**
   * LeaveRequestCountOutputType without action
   */
  export type LeaveRequestCountOutputTypeCountSalaryDeductionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryDeductionWhereInput
  }


  /**
   * Count Type EmployeeSalaryCountOutputType
   */

  export type EmployeeSalaryCountOutputType = {
    monthlySalaries: number
  }

  export type EmployeeSalaryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthlySalaries?: boolean | EmployeeSalaryCountOutputTypeCountMonthlySalariesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeSalaryCountOutputType without action
   */
  export type EmployeeSalaryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalaryCountOutputType
     */
    select?: EmployeeSalaryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeSalaryCountOutputType without action
   */
  export type EmployeeSalaryCountOutputTypeCountMonthlySalariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlySalaryWhereInput
  }


  /**
   * Count Type MonthlySalaryCountOutputType
   */

  export type MonthlySalaryCountOutputType = {
    deductions: number
  }

  export type MonthlySalaryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deductions?: boolean | MonthlySalaryCountOutputTypeCountDeductionsArgs
  }

  // Custom InputTypes
  /**
   * MonthlySalaryCountOutputType without action
   */
  export type MonthlySalaryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalaryCountOutputType
     */
    select?: MonthlySalaryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MonthlySalaryCountOutputType without action
   */
  export type MonthlySalaryCountOutputTypeCountDeductionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryDeductionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    department: string | null
    managerId: string | null
    profilePicture: string | null
    phone: string | null
    bio: string | null
    address: string | null
    emergencyContact: string | null
    emergencyPhone: string | null
    isActive: boolean | null
    lastLogin: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    department: string | null
    managerId: string | null
    profilePicture: string | null
    phone: string | null
    bio: string | null
    address: string | null
    emergencyContact: string | null
    emergencyPhone: string | null
    isActive: boolean | null
    lastLogin: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    passwordHash: number
    role: number
    department: number
    managerId: number
    profilePicture: number
    phone: number
    bio: number
    address: number
    emergencyContact: number
    emergencyPhone: number
    isActive: number
    lastLogin: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    department?: true
    managerId?: true
    profilePicture?: true
    phone?: true
    bio?: true
    address?: true
    emergencyContact?: true
    emergencyPhone?: true
    isActive?: true
    lastLogin?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    department?: true
    managerId?: true
    profilePicture?: true
    phone?: true
    bio?: true
    address?: true
    emergencyContact?: true
    emergencyPhone?: true
    isActive?: true
    lastLogin?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    department?: true
    managerId?: true
    profilePicture?: true
    phone?: true
    bio?: true
    address?: true
    emergencyContact?: true
    emergencyPhone?: true
    isActive?: true
    lastLogin?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department: string | null
    managerId: string | null
    profilePicture: string | null
    phone: string | null
    bio: string | null
    address: string | null
    emergencyContact: string | null
    emergencyPhone: string | null
    isActive: boolean
    lastLogin: Date | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    department?: boolean
    managerId?: boolean
    profilePicture?: boolean
    phone?: boolean
    bio?: boolean
    address?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    isActive?: boolean
    lastLogin?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    manager?: boolean | User$managerArgs<ExtArgs>
    subordinates?: boolean | User$subordinatesArgs<ExtArgs>
    leaveRequests?: boolean | User$leaveRequestsArgs<ExtArgs>
    approvedLeaves?: boolean | User$approvedLeavesArgs<ExtArgs>
    leaveBalances?: boolean | User$leaveBalancesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    createdPolicies?: boolean | User$createdPoliciesArgs<ExtArgs>
    createdHolidays?: boolean | User$createdHolidaysArgs<ExtArgs>
    attendanceRecords?: boolean | User$attendanceRecordsArgs<ExtArgs>
    createdAttendancePolicies?: boolean | User$createdAttendancePoliciesArgs<ExtArgs>
    employeeSalary?: boolean | User$employeeSalaryArgs<ExtArgs>
    monthlySalaries?: boolean | User$monthlySalariesArgs<ExtArgs>
    approvedSalaries?: boolean | User$approvedSalariesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    department?: boolean
    managerId?: boolean
    profilePicture?: boolean
    phone?: boolean
    bio?: boolean
    address?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    isActive?: boolean
    lastLogin?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    manager?: boolean | User$managerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    department?: boolean
    managerId?: boolean
    profilePicture?: boolean
    phone?: boolean
    bio?: boolean
    address?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    isActive?: boolean
    lastLogin?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | User$managerArgs<ExtArgs>
    subordinates?: boolean | User$subordinatesArgs<ExtArgs>
    leaveRequests?: boolean | User$leaveRequestsArgs<ExtArgs>
    approvedLeaves?: boolean | User$approvedLeavesArgs<ExtArgs>
    leaveBalances?: boolean | User$leaveBalancesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    createdPolicies?: boolean | User$createdPoliciesArgs<ExtArgs>
    createdHolidays?: boolean | User$createdHolidaysArgs<ExtArgs>
    attendanceRecords?: boolean | User$attendanceRecordsArgs<ExtArgs>
    createdAttendancePolicies?: boolean | User$createdAttendancePoliciesArgs<ExtArgs>
    employeeSalary?: boolean | User$employeeSalaryArgs<ExtArgs>
    monthlySalaries?: boolean | User$monthlySalariesArgs<ExtArgs>
    approvedSalaries?: boolean | User$approvedSalariesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | User$managerArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      manager: Prisma.$UserPayload<ExtArgs> | null
      subordinates: Prisma.$UserPayload<ExtArgs>[]
      leaveRequests: Prisma.$LeaveRequestPayload<ExtArgs>[]
      approvedLeaves: Prisma.$LeaveRequestPayload<ExtArgs>[]
      leaveBalances: Prisma.$LeaveBalancePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      createdPolicies: Prisma.$LeavePolicyPayload<ExtArgs>[]
      createdHolidays: Prisma.$HolidayPayload<ExtArgs>[]
      attendanceRecords: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      createdAttendancePolicies: Prisma.$AttendancePolicyPayload<ExtArgs>[]
      employeeSalary: Prisma.$EmployeeSalaryPayload<ExtArgs>[]
      monthlySalaries: Prisma.$MonthlySalaryPayload<ExtArgs>[]
      approvedSalaries: Prisma.$MonthlySalaryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      passwordHash: string
      role: $Enums.UserRole
      department: string | null
      managerId: string | null
      profilePicture: string | null
      phone: string | null
      bio: string | null
      address: string | null
      emergencyContact: string | null
      emergencyPhone: string | null
      isActive: boolean
      lastLogin: Date | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    manager<T extends User$managerArgs<ExtArgs> = {}>(args?: Subset<T, User$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subordinates<T extends User$subordinatesArgs<ExtArgs> = {}>(args?: Subset<T, User$subordinatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    leaveRequests<T extends User$leaveRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$leaveRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany"> | Null>
    approvedLeaves<T extends User$approvedLeavesArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedLeavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany"> | Null>
    leaveBalances<T extends User$leaveBalancesArgs<ExtArgs> = {}>(args?: Subset<T, User$leaveBalancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    createdPolicies<T extends User$createdPoliciesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPoliciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, "findMany"> | Null>
    createdHolidays<T extends User$createdHolidaysArgs<ExtArgs> = {}>(args?: Subset<T, User$createdHolidaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findMany"> | Null>
    attendanceRecords<T extends User$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany"> | Null>
    createdAttendancePolicies<T extends User$createdAttendancePoliciesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdAttendancePoliciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePolicyPayload<ExtArgs>, T, "findMany"> | Null>
    employeeSalary<T extends User$employeeSalaryArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeSalaryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeSalaryPayload<ExtArgs>, T, "findMany"> | Null>
    monthlySalaries<T extends User$monthlySalariesArgs<ExtArgs> = {}>(args?: Subset<T, User$monthlySalariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "findMany"> | Null>
    approvedSalaries<T extends User$approvedSalariesArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedSalariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly department: FieldRef<"User", 'String'>
    readonly managerId: FieldRef<"User", 'String'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly emergencyContact: FieldRef<"User", 'String'>
    readonly emergencyPhone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.manager
   */
  export type User$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.subordinates
   */
  export type User$subordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.leaveRequests
   */
  export type User$leaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * User.approvedLeaves
   */
  export type User$approvedLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * User.leaveBalances
   */
  export type User$leaveBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    where?: LeaveBalanceWhereInput
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    cursor?: LeaveBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.createdPolicies
   */
  export type User$createdPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    where?: LeavePolicyWhereInput
    orderBy?: LeavePolicyOrderByWithRelationInput | LeavePolicyOrderByWithRelationInput[]
    cursor?: LeavePolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeavePolicyScalarFieldEnum | LeavePolicyScalarFieldEnum[]
  }

  /**
   * User.createdHolidays
   */
  export type User$createdHolidaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    where?: HolidayWhereInput
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    cursor?: HolidayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * User.attendanceRecords
   */
  export type User$attendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * User.createdAttendancePolicies
   */
  export type User$createdAttendancePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendancePolicy
     */
    select?: AttendancePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancePolicyInclude<ExtArgs> | null
    where?: AttendancePolicyWhereInput
    orderBy?: AttendancePolicyOrderByWithRelationInput | AttendancePolicyOrderByWithRelationInput[]
    cursor?: AttendancePolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendancePolicyScalarFieldEnum | AttendancePolicyScalarFieldEnum[]
  }

  /**
   * User.employeeSalary
   */
  export type User$employeeSalaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalary
     */
    select?: EmployeeSalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeSalaryInclude<ExtArgs> | null
    where?: EmployeeSalaryWhereInput
    orderBy?: EmployeeSalaryOrderByWithRelationInput | EmployeeSalaryOrderByWithRelationInput[]
    cursor?: EmployeeSalaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeSalaryScalarFieldEnum | EmployeeSalaryScalarFieldEnum[]
  }

  /**
   * User.monthlySalaries
   */
  export type User$monthlySalariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
    where?: MonthlySalaryWhereInput
    orderBy?: MonthlySalaryOrderByWithRelationInput | MonthlySalaryOrderByWithRelationInput[]
    cursor?: MonthlySalaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthlySalaryScalarFieldEnum | MonthlySalaryScalarFieldEnum[]
  }

  /**
   * User.approvedSalaries
   */
  export type User$approvedSalariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
    where?: MonthlySalaryWhereInput
    orderBy?: MonthlySalaryOrderByWithRelationInput | MonthlySalaryOrderByWithRelationInput[]
    cursor?: MonthlySalaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthlySalaryScalarFieldEnum | MonthlySalaryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model LeaveRequest
   */

  export type AggregateLeaveRequest = {
    _count: LeaveRequestCountAggregateOutputType | null
    _avg: LeaveRequestAvgAggregateOutputType | null
    _sum: LeaveRequestSumAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  export type LeaveRequestAvgAggregateOutputType = {
    totalDays: Decimal | null
  }

  export type LeaveRequestSumAggregateOutputType = {
    totalDays: Decimal | null
  }

  export type LeaveRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    leaveType: $Enums.LeaveType | null
    startDate: Date | null
    endDate: Date | null
    totalDays: Decimal | null
    reason: string | null
    status: $Enums.LeaveStatus | null
    submittedAt: Date | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedReason: string | null
    isHalfDay: boolean | null
    halfDayPeriod: $Enums.HalfDayPeriod | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    leaveType: $Enums.LeaveType | null
    startDate: Date | null
    endDate: Date | null
    totalDays: Decimal | null
    reason: string | null
    status: $Enums.LeaveStatus | null
    submittedAt: Date | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedReason: string | null
    isHalfDay: boolean | null
    halfDayPeriod: $Enums.HalfDayPeriod | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestCountAggregateOutputType = {
    id: number
    userId: number
    leaveType: number
    startDate: number
    endDate: number
    totalDays: number
    reason: number
    status: number
    submittedAt: number
    approvedBy: number
    approvedAt: number
    rejectedReason: number
    isHalfDay: number
    halfDayPeriod: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveRequestAvgAggregateInputType = {
    totalDays?: true
  }

  export type LeaveRequestSumAggregateInputType = {
    totalDays?: true
  }

  export type LeaveRequestMinAggregateInputType = {
    id?: true
    userId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    reason?: true
    status?: true
    submittedAt?: true
    approvedBy?: true
    approvedAt?: true
    rejectedReason?: true
    isHalfDay?: true
    halfDayPeriod?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    reason?: true
    status?: true
    submittedAt?: true
    approvedBy?: true
    approvedAt?: true
    rejectedReason?: true
    isHalfDay?: true
    halfDayPeriod?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestCountAggregateInputType = {
    id?: true
    userId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    reason?: true
    status?: true
    submittedAt?: true
    approvedBy?: true
    approvedAt?: true
    rejectedReason?: true
    isHalfDay?: true
    halfDayPeriod?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequest to aggregate.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveRequests
    **/
    _count?: true | LeaveRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type GetLeaveRequestAggregateType<T extends LeaveRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveRequest[P]>
      : GetScalarType<T[P], AggregateLeaveRequest[P]>
  }




  export type LeaveRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithAggregationInput | LeaveRequestOrderByWithAggregationInput[]
    by: LeaveRequestScalarFieldEnum[] | LeaveRequestScalarFieldEnum
    having?: LeaveRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveRequestCountAggregateInputType | true
    _avg?: LeaveRequestAvgAggregateInputType
    _sum?: LeaveRequestSumAggregateInputType
    _min?: LeaveRequestMinAggregateInputType
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type LeaveRequestGroupByOutputType = {
    id: string
    userId: string
    leaveType: $Enums.LeaveType
    startDate: Date
    endDate: Date
    totalDays: Decimal
    reason: string
    status: $Enums.LeaveStatus
    submittedAt: Date
    approvedBy: string | null
    approvedAt: Date | null
    rejectedReason: string | null
    isHalfDay: boolean
    halfDayPeriod: $Enums.HalfDayPeriod | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeaveRequestCountAggregateOutputType | null
    _avg: LeaveRequestAvgAggregateOutputType | null
    _sum: LeaveRequestSumAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  type GetLeaveRequestGroupByPayload<T extends LeaveRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
        }
      >
    >


  export type LeaveRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    reason?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    isHalfDay?: boolean
    halfDayPeriod?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | LeaveRequest$approverArgs<ExtArgs>
    documents?: boolean | LeaveRequest$documentsArgs<ExtArgs>
    salaryDeductions?: boolean | LeaveRequest$salaryDeductionsArgs<ExtArgs>
    _count?: boolean | LeaveRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    reason?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    isHalfDay?: boolean
    halfDayPeriod?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | LeaveRequest$approverArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    reason?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    isHalfDay?: boolean
    halfDayPeriod?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | LeaveRequest$approverArgs<ExtArgs>
    documents?: boolean | LeaveRequest$documentsArgs<ExtArgs>
    salaryDeductions?: boolean | LeaveRequest$salaryDeductionsArgs<ExtArgs>
    _count?: boolean | LeaveRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeaveRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | LeaveRequest$approverArgs<ExtArgs>
  }

  export type $LeaveRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
      documents: Prisma.$LeaveDocumentPayload<ExtArgs>[]
      salaryDeductions: Prisma.$SalaryDeductionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      leaveType: $Enums.LeaveType
      startDate: Date
      endDate: Date
      totalDays: Prisma.Decimal
      reason: string
      status: $Enums.LeaveStatus
      submittedAt: Date
      approvedBy: string | null
      approvedAt: Date | null
      rejectedReason: string | null
      isHalfDay: boolean
      halfDayPeriod: $Enums.HalfDayPeriod | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveRequest"]>
    composites: {}
  }

  type LeaveRequestGetPayload<S extends boolean | null | undefined | LeaveRequestDefaultArgs> = $Result.GetResult<Prisma.$LeaveRequestPayload, S>

  type LeaveRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveRequestCountAggregateInputType | true
    }

  export interface LeaveRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveRequest'], meta: { name: 'LeaveRequest' } }
    /**
     * Find zero or one LeaveRequest that matches the filter.
     * @param {LeaveRequestFindUniqueArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveRequestFindUniqueArgs>(args: SelectSubset<T, LeaveRequestFindUniqueArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaveRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaveRequestFindUniqueOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaveRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveRequestFindFirstArgs>(args?: SelectSubset<T, LeaveRequestFindFirstArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaveRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaveRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany()
     * 
     * // Get first 10 LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveRequestFindManyArgs>(args?: SelectSubset<T, LeaveRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaveRequest.
     * @param {LeaveRequestCreateArgs} args - Arguments to create a LeaveRequest.
     * @example
     * // Create one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.create({
     *   data: {
     *     // ... data to create a LeaveRequest
     *   }
     * })
     * 
     */
    create<T extends LeaveRequestCreateArgs>(args: SelectSubset<T, LeaveRequestCreateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaveRequests.
     * @param {LeaveRequestCreateManyArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveRequestCreateManyArgs>(args?: SelectSubset<T, LeaveRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveRequests and returns the data saved in the database.
     * @param {LeaveRequestCreateManyAndReturnArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveRequests and only return the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeaveRequest.
     * @param {LeaveRequestDeleteArgs} args - Arguments to delete one LeaveRequest.
     * @example
     * // Delete one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.delete({
     *   where: {
     *     // ... filter to delete one LeaveRequest
     *   }
     * })
     * 
     */
    delete<T extends LeaveRequestDeleteArgs>(args: SelectSubset<T, LeaveRequestDeleteArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaveRequest.
     * @param {LeaveRequestUpdateArgs} args - Arguments to update one LeaveRequest.
     * @example
     * // Update one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveRequestUpdateArgs>(args: SelectSubset<T, LeaveRequestUpdateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaveRequests.
     * @param {LeaveRequestDeleteManyArgs} args - Arguments to filter LeaveRequests to delete.
     * @example
     * // Delete a few LeaveRequests
     * const { count } = await prisma.leaveRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveRequestDeleteManyArgs>(args?: SelectSubset<T, LeaveRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveRequestUpdateManyArgs>(args: SelectSubset<T, LeaveRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveRequest.
     * @param {LeaveRequestUpsertArgs} args - Arguments to update or create a LeaveRequest.
     * @example
     * // Update or create a LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.upsert({
     *   create: {
     *     // ... data to create a LeaveRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveRequest we want to update
     *   }
     * })
     */
    upsert<T extends LeaveRequestUpsertArgs>(args: SelectSubset<T, LeaveRequestUpsertArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestCountArgs} args - Arguments to filter LeaveRequests to count.
     * @example
     * // Count the number of LeaveRequests
     * const count = await prisma.leaveRequest.count({
     *   where: {
     *     // ... the filter for the LeaveRequests we want to count
     *   }
     * })
    **/
    count<T extends LeaveRequestCountArgs>(
      args?: Subset<T, LeaveRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveRequestAggregateArgs>(args: Subset<T, LeaveRequestAggregateArgs>): Prisma.PrismaPromise<GetLeaveRequestAggregateType<T>>

    /**
     * Group by LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveRequestGroupByArgs['orderBy'] }
        : { orderBy?: LeaveRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveRequest model
   */
  readonly fields: LeaveRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approver<T extends LeaveRequest$approverArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequest$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    documents<T extends LeaveRequest$documentsArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequest$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    salaryDeductions<T extends LeaveRequest$salaryDeductionsArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequest$salaryDeductionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryDeductionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveRequest model
   */ 
  interface LeaveRequestFieldRefs {
    readonly id: FieldRef<"LeaveRequest", 'String'>
    readonly userId: FieldRef<"LeaveRequest", 'String'>
    readonly leaveType: FieldRef<"LeaveRequest", 'LeaveType'>
    readonly startDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly endDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly totalDays: FieldRef<"LeaveRequest", 'Decimal'>
    readonly reason: FieldRef<"LeaveRequest", 'String'>
    readonly status: FieldRef<"LeaveRequest", 'LeaveStatus'>
    readonly submittedAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly approvedBy: FieldRef<"LeaveRequest", 'String'>
    readonly approvedAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly rejectedReason: FieldRef<"LeaveRequest", 'String'>
    readonly isHalfDay: FieldRef<"LeaveRequest", 'Boolean'>
    readonly halfDayPeriod: FieldRef<"LeaveRequest", 'HalfDayPeriod'>
    readonly comments: FieldRef<"LeaveRequest", 'String'>
    readonly createdAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveRequest findUnique
   */
  export type LeaveRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findUniqueOrThrow
   */
  export type LeaveRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findFirst
   */
  export type LeaveRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findFirstOrThrow
   */
  export type LeaveRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findMany
   */
  export type LeaveRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequests to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest create
   */
  export type LeaveRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveRequest.
     */
    data: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
  }

  /**
   * LeaveRequest createMany
   */
  export type LeaveRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveRequest createManyAndReturn
   */
  export type LeaveRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveRequest update
   */
  export type LeaveRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveRequest.
     */
    data: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
    /**
     * Choose, which LeaveRequest to update.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest updateMany
   */
  export type LeaveRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
  }

  /**
   * LeaveRequest upsert
   */
  export type LeaveRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveRequest to update in case it exists.
     */
    where: LeaveRequestWhereUniqueInput
    /**
     * In case the LeaveRequest found by the `where` argument doesn't exist, create a new LeaveRequest with this data.
     */
    create: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
    /**
     * In case the LeaveRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
  }

  /**
   * LeaveRequest delete
   */
  export type LeaveRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter which LeaveRequest to delete.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest deleteMany
   */
  export type LeaveRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequests to delete
     */
    where?: LeaveRequestWhereInput
  }

  /**
   * LeaveRequest.approver
   */
  export type LeaveRequest$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LeaveRequest.documents
   */
  export type LeaveRequest$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveDocument
     */
    select?: LeaveDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveDocumentInclude<ExtArgs> | null
    where?: LeaveDocumentWhereInput
    orderBy?: LeaveDocumentOrderByWithRelationInput | LeaveDocumentOrderByWithRelationInput[]
    cursor?: LeaveDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveDocumentScalarFieldEnum | LeaveDocumentScalarFieldEnum[]
  }

  /**
   * LeaveRequest.salaryDeductions
   */
  export type LeaveRequest$salaryDeductionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionInclude<ExtArgs> | null
    where?: SalaryDeductionWhereInput
    orderBy?: SalaryDeductionOrderByWithRelationInput | SalaryDeductionOrderByWithRelationInput[]
    cursor?: SalaryDeductionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryDeductionScalarFieldEnum | SalaryDeductionScalarFieldEnum[]
  }

  /**
   * LeaveRequest without action
   */
  export type LeaveRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
  }


  /**
   * Model LeaveBalance
   */

  export type AggregateLeaveBalance = {
    _count: LeaveBalanceCountAggregateOutputType | null
    _avg: LeaveBalanceAvgAggregateOutputType | null
    _sum: LeaveBalanceSumAggregateOutputType | null
    _min: LeaveBalanceMinAggregateOutputType | null
    _max: LeaveBalanceMaxAggregateOutputType | null
  }

  export type LeaveBalanceAvgAggregateOutputType = {
    year: number | null
    annualTotal: number | null
    annualUsed: number | null
    annualRemaining: number | null
    sickTotal: number | null
    sickUsed: number | null
    sickRemaining: number | null
    casualTotal: number | null
    casualUsed: number | null
    casualRemaining: number | null
    maternityTotal: number | null
    maternityUsed: number | null
    maternityRemaining: number | null
    paternityTotal: number | null
    paternityUsed: number | null
    paternityRemaining: number | null
    emergencyTotal: number | null
    emergencyUsed: number | null
    emergencyRemaining: number | null
  }

  export type LeaveBalanceSumAggregateOutputType = {
    year: number | null
    annualTotal: number | null
    annualUsed: number | null
    annualRemaining: number | null
    sickTotal: number | null
    sickUsed: number | null
    sickRemaining: number | null
    casualTotal: number | null
    casualUsed: number | null
    casualRemaining: number | null
    maternityTotal: number | null
    maternityUsed: number | null
    maternityRemaining: number | null
    paternityTotal: number | null
    paternityUsed: number | null
    paternityRemaining: number | null
    emergencyTotal: number | null
    emergencyUsed: number | null
    emergencyRemaining: number | null
  }

  export type LeaveBalanceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    year: number | null
    annualTotal: number | null
    annualUsed: number | null
    annualRemaining: number | null
    sickTotal: number | null
    sickUsed: number | null
    sickRemaining: number | null
    casualTotal: number | null
    casualUsed: number | null
    casualRemaining: number | null
    maternityTotal: number | null
    maternityUsed: number | null
    maternityRemaining: number | null
    paternityTotal: number | null
    paternityUsed: number | null
    paternityRemaining: number | null
    emergencyTotal: number | null
    emergencyUsed: number | null
    emergencyRemaining: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveBalanceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    year: number | null
    annualTotal: number | null
    annualUsed: number | null
    annualRemaining: number | null
    sickTotal: number | null
    sickUsed: number | null
    sickRemaining: number | null
    casualTotal: number | null
    casualUsed: number | null
    casualRemaining: number | null
    maternityTotal: number | null
    maternityUsed: number | null
    maternityRemaining: number | null
    paternityTotal: number | null
    paternityUsed: number | null
    paternityRemaining: number | null
    emergencyTotal: number | null
    emergencyUsed: number | null
    emergencyRemaining: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveBalanceCountAggregateOutputType = {
    id: number
    userId: number
    year: number
    annualTotal: number
    annualUsed: number
    annualRemaining: number
    sickTotal: number
    sickUsed: number
    sickRemaining: number
    casualTotal: number
    casualUsed: number
    casualRemaining: number
    maternityTotal: number
    maternityUsed: number
    maternityRemaining: number
    paternityTotal: number
    paternityUsed: number
    paternityRemaining: number
    emergencyTotal: number
    emergencyUsed: number
    emergencyRemaining: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveBalanceAvgAggregateInputType = {
    year?: true
    annualTotal?: true
    annualUsed?: true
    annualRemaining?: true
    sickTotal?: true
    sickUsed?: true
    sickRemaining?: true
    casualTotal?: true
    casualUsed?: true
    casualRemaining?: true
    maternityTotal?: true
    maternityUsed?: true
    maternityRemaining?: true
    paternityTotal?: true
    paternityUsed?: true
    paternityRemaining?: true
    emergencyTotal?: true
    emergencyUsed?: true
    emergencyRemaining?: true
  }

  export type LeaveBalanceSumAggregateInputType = {
    year?: true
    annualTotal?: true
    annualUsed?: true
    annualRemaining?: true
    sickTotal?: true
    sickUsed?: true
    sickRemaining?: true
    casualTotal?: true
    casualUsed?: true
    casualRemaining?: true
    maternityTotal?: true
    maternityUsed?: true
    maternityRemaining?: true
    paternityTotal?: true
    paternityUsed?: true
    paternityRemaining?: true
    emergencyTotal?: true
    emergencyUsed?: true
    emergencyRemaining?: true
  }

  export type LeaveBalanceMinAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    annualTotal?: true
    annualUsed?: true
    annualRemaining?: true
    sickTotal?: true
    sickUsed?: true
    sickRemaining?: true
    casualTotal?: true
    casualUsed?: true
    casualRemaining?: true
    maternityTotal?: true
    maternityUsed?: true
    maternityRemaining?: true
    paternityTotal?: true
    paternityUsed?: true
    paternityRemaining?: true
    emergencyTotal?: true
    emergencyUsed?: true
    emergencyRemaining?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveBalanceMaxAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    annualTotal?: true
    annualUsed?: true
    annualRemaining?: true
    sickTotal?: true
    sickUsed?: true
    sickRemaining?: true
    casualTotal?: true
    casualUsed?: true
    casualRemaining?: true
    maternityTotal?: true
    maternityUsed?: true
    maternityRemaining?: true
    paternityTotal?: true
    paternityUsed?: true
    paternityRemaining?: true
    emergencyTotal?: true
    emergencyUsed?: true
    emergencyRemaining?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveBalanceCountAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    annualTotal?: true
    annualUsed?: true
    annualRemaining?: true
    sickTotal?: true
    sickUsed?: true
    sickRemaining?: true
    casualTotal?: true
    casualUsed?: true
    casualRemaining?: true
    maternityTotal?: true
    maternityUsed?: true
    maternityRemaining?: true
    paternityTotal?: true
    paternityUsed?: true
    paternityRemaining?: true
    emergencyTotal?: true
    emergencyUsed?: true
    emergencyRemaining?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveBalance to aggregate.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveBalances
    **/
    _count?: true | LeaveBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveBalanceMaxAggregateInputType
  }

  export type GetLeaveBalanceAggregateType<T extends LeaveBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveBalance[P]>
      : GetScalarType<T[P], AggregateLeaveBalance[P]>
  }




  export type LeaveBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveBalanceWhereInput
    orderBy?: LeaveBalanceOrderByWithAggregationInput | LeaveBalanceOrderByWithAggregationInput[]
    by: LeaveBalanceScalarFieldEnum[] | LeaveBalanceScalarFieldEnum
    having?: LeaveBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveBalanceCountAggregateInputType | true
    _avg?: LeaveBalanceAvgAggregateInputType
    _sum?: LeaveBalanceSumAggregateInputType
    _min?: LeaveBalanceMinAggregateInputType
    _max?: LeaveBalanceMaxAggregateInputType
  }

  export type LeaveBalanceGroupByOutputType = {
    id: string
    userId: string
    year: number
    annualTotal: number
    annualUsed: number
    annualRemaining: number
    sickTotal: number
    sickUsed: number
    sickRemaining: number
    casualTotal: number
    casualUsed: number
    casualRemaining: number
    maternityTotal: number
    maternityUsed: number
    maternityRemaining: number
    paternityTotal: number
    paternityUsed: number
    paternityRemaining: number
    emergencyTotal: number
    emergencyUsed: number
    emergencyRemaining: number
    createdAt: Date
    updatedAt: Date
    _count: LeaveBalanceCountAggregateOutputType | null
    _avg: LeaveBalanceAvgAggregateOutputType | null
    _sum: LeaveBalanceSumAggregateOutputType | null
    _min: LeaveBalanceMinAggregateOutputType | null
    _max: LeaveBalanceMaxAggregateOutputType | null
  }

  type GetLeaveBalanceGroupByPayload<T extends LeaveBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveBalanceGroupByOutputType[P]>
        }
      >
    >


  export type LeaveBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    annualTotal?: boolean
    annualUsed?: boolean
    annualRemaining?: boolean
    sickTotal?: boolean
    sickUsed?: boolean
    sickRemaining?: boolean
    casualTotal?: boolean
    casualUsed?: boolean
    casualRemaining?: boolean
    maternityTotal?: boolean
    maternityUsed?: boolean
    maternityRemaining?: boolean
    paternityTotal?: boolean
    paternityUsed?: boolean
    paternityRemaining?: boolean
    emergencyTotal?: boolean
    emergencyUsed?: boolean
    emergencyRemaining?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveBalance"]>

  export type LeaveBalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    annualTotal?: boolean
    annualUsed?: boolean
    annualRemaining?: boolean
    sickTotal?: boolean
    sickUsed?: boolean
    sickRemaining?: boolean
    casualTotal?: boolean
    casualUsed?: boolean
    casualRemaining?: boolean
    maternityTotal?: boolean
    maternityUsed?: boolean
    maternityRemaining?: boolean
    paternityTotal?: boolean
    paternityUsed?: boolean
    paternityRemaining?: boolean
    emergencyTotal?: boolean
    emergencyUsed?: boolean
    emergencyRemaining?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveBalance"]>

  export type LeaveBalanceSelectScalar = {
    id?: boolean
    userId?: boolean
    year?: boolean
    annualTotal?: boolean
    annualUsed?: boolean
    annualRemaining?: boolean
    sickTotal?: boolean
    sickUsed?: boolean
    sickRemaining?: boolean
    casualTotal?: boolean
    casualUsed?: boolean
    casualRemaining?: boolean
    maternityTotal?: boolean
    maternityUsed?: boolean
    maternityRemaining?: boolean
    paternityTotal?: boolean
    paternityUsed?: boolean
    paternityRemaining?: boolean
    emergencyTotal?: boolean
    emergencyUsed?: boolean
    emergencyRemaining?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeaveBalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeaveBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveBalance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      year: number
      annualTotal: number
      annualUsed: number
      annualRemaining: number
      sickTotal: number
      sickUsed: number
      sickRemaining: number
      casualTotal: number
      casualUsed: number
      casualRemaining: number
      maternityTotal: number
      maternityUsed: number
      maternityRemaining: number
      paternityTotal: number
      paternityUsed: number
      paternityRemaining: number
      emergencyTotal: number
      emergencyUsed: number
      emergencyRemaining: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveBalance"]>
    composites: {}
  }

  type LeaveBalanceGetPayload<S extends boolean | null | undefined | LeaveBalanceDefaultArgs> = $Result.GetResult<Prisma.$LeaveBalancePayload, S>

  type LeaveBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveBalanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveBalanceCountAggregateInputType | true
    }

  export interface LeaveBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveBalance'], meta: { name: 'LeaveBalance' } }
    /**
     * Find zero or one LeaveBalance that matches the filter.
     * @param {LeaveBalanceFindUniqueArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveBalanceFindUniqueArgs>(args: SelectSubset<T, LeaveBalanceFindUniqueArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaveBalance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaveBalanceFindUniqueOrThrowArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaveBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceFindFirstArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveBalanceFindFirstArgs>(args?: SelectSubset<T, LeaveBalanceFindFirstArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaveBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceFindFirstOrThrowArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaveBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveBalances
     * const leaveBalances = await prisma.leaveBalance.findMany()
     * 
     * // Get first 10 LeaveBalances
     * const leaveBalances = await prisma.leaveBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveBalanceWithIdOnly = await prisma.leaveBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveBalanceFindManyArgs>(args?: SelectSubset<T, LeaveBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaveBalance.
     * @param {LeaveBalanceCreateArgs} args - Arguments to create a LeaveBalance.
     * @example
     * // Create one LeaveBalance
     * const LeaveBalance = await prisma.leaveBalance.create({
     *   data: {
     *     // ... data to create a LeaveBalance
     *   }
     * })
     * 
     */
    create<T extends LeaveBalanceCreateArgs>(args: SelectSubset<T, LeaveBalanceCreateArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaveBalances.
     * @param {LeaveBalanceCreateManyArgs} args - Arguments to create many LeaveBalances.
     * @example
     * // Create many LeaveBalances
     * const leaveBalance = await prisma.leaveBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveBalanceCreateManyArgs>(args?: SelectSubset<T, LeaveBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveBalances and returns the data saved in the database.
     * @param {LeaveBalanceCreateManyAndReturnArgs} args - Arguments to create many LeaveBalances.
     * @example
     * // Create many LeaveBalances
     * const leaveBalance = await prisma.leaveBalance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveBalances and only return the `id`
     * const leaveBalanceWithIdOnly = await prisma.leaveBalance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveBalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveBalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeaveBalance.
     * @param {LeaveBalanceDeleteArgs} args - Arguments to delete one LeaveBalance.
     * @example
     * // Delete one LeaveBalance
     * const LeaveBalance = await prisma.leaveBalance.delete({
     *   where: {
     *     // ... filter to delete one LeaveBalance
     *   }
     * })
     * 
     */
    delete<T extends LeaveBalanceDeleteArgs>(args: SelectSubset<T, LeaveBalanceDeleteArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaveBalance.
     * @param {LeaveBalanceUpdateArgs} args - Arguments to update one LeaveBalance.
     * @example
     * // Update one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveBalanceUpdateArgs>(args: SelectSubset<T, LeaveBalanceUpdateArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaveBalances.
     * @param {LeaveBalanceDeleteManyArgs} args - Arguments to filter LeaveBalances to delete.
     * @example
     * // Delete a few LeaveBalances
     * const { count } = await prisma.leaveBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveBalanceDeleteManyArgs>(args?: SelectSubset<T, LeaveBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveBalances
     * const leaveBalance = await prisma.leaveBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveBalanceUpdateManyArgs>(args: SelectSubset<T, LeaveBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveBalance.
     * @param {LeaveBalanceUpsertArgs} args - Arguments to update or create a LeaveBalance.
     * @example
     * // Update or create a LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.upsert({
     *   create: {
     *     // ... data to create a LeaveBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveBalance we want to update
     *   }
     * })
     */
    upsert<T extends LeaveBalanceUpsertArgs>(args: SelectSubset<T, LeaveBalanceUpsertArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaveBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceCountArgs} args - Arguments to filter LeaveBalances to count.
     * @example
     * // Count the number of LeaveBalances
     * const count = await prisma.leaveBalance.count({
     *   where: {
     *     // ... the filter for the LeaveBalances we want to count
     *   }
     * })
    **/
    count<T extends LeaveBalanceCountArgs>(
      args?: Subset<T, LeaveBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveBalanceAggregateArgs>(args: Subset<T, LeaveBalanceAggregateArgs>): Prisma.PrismaPromise<GetLeaveBalanceAggregateType<T>>

    /**
     * Group by LeaveBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveBalanceGroupByArgs['orderBy'] }
        : { orderBy?: LeaveBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveBalance model
   */
  readonly fields: LeaveBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveBalance model
   */ 
  interface LeaveBalanceFieldRefs {
    readonly id: FieldRef<"LeaveBalance", 'String'>
    readonly userId: FieldRef<"LeaveBalance", 'String'>
    readonly year: FieldRef<"LeaveBalance", 'Int'>
    readonly annualTotal: FieldRef<"LeaveBalance", 'Int'>
    readonly annualUsed: FieldRef<"LeaveBalance", 'Int'>
    readonly annualRemaining: FieldRef<"LeaveBalance", 'Int'>
    readonly sickTotal: FieldRef<"LeaveBalance", 'Int'>
    readonly sickUsed: FieldRef<"LeaveBalance", 'Int'>
    readonly sickRemaining: FieldRef<"LeaveBalance", 'Int'>
    readonly casualTotal: FieldRef<"LeaveBalance", 'Int'>
    readonly casualUsed: FieldRef<"LeaveBalance", 'Int'>
    readonly casualRemaining: FieldRef<"LeaveBalance", 'Int'>
    readonly maternityTotal: FieldRef<"LeaveBalance", 'Int'>
    readonly maternityUsed: FieldRef<"LeaveBalance", 'Int'>
    readonly maternityRemaining: FieldRef<"LeaveBalance", 'Int'>
    readonly paternityTotal: FieldRef<"LeaveBalance", 'Int'>
    readonly paternityUsed: FieldRef<"LeaveBalance", 'Int'>
    readonly paternityRemaining: FieldRef<"LeaveBalance", 'Int'>
    readonly emergencyTotal: FieldRef<"LeaveBalance", 'Int'>
    readonly emergencyUsed: FieldRef<"LeaveBalance", 'Int'>
    readonly emergencyRemaining: FieldRef<"LeaveBalance", 'Int'>
    readonly createdAt: FieldRef<"LeaveBalance", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveBalance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveBalance findUnique
   */
  export type LeaveBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where: LeaveBalanceWhereUniqueInput
  }

  /**
   * LeaveBalance findUniqueOrThrow
   */
  export type LeaveBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where: LeaveBalanceWhereUniqueInput
  }

  /**
   * LeaveBalance findFirst
   */
  export type LeaveBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveBalances.
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveBalances.
     */
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * LeaveBalance findFirstOrThrow
   */
  export type LeaveBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveBalances.
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveBalances.
     */
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * LeaveBalance findMany
   */
  export type LeaveBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalances to fetch.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveBalances.
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * LeaveBalance create
   */
  export type LeaveBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveBalance.
     */
    data: XOR<LeaveBalanceCreateInput, LeaveBalanceUncheckedCreateInput>
  }

  /**
   * LeaveBalance createMany
   */
  export type LeaveBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveBalances.
     */
    data: LeaveBalanceCreateManyInput | LeaveBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveBalance createManyAndReturn
   */
  export type LeaveBalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeaveBalances.
     */
    data: LeaveBalanceCreateManyInput | LeaveBalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveBalance update
   */
  export type LeaveBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveBalance.
     */
    data: XOR<LeaveBalanceUpdateInput, LeaveBalanceUncheckedUpdateInput>
    /**
     * Choose, which LeaveBalance to update.
     */
    where: LeaveBalanceWhereUniqueInput
  }

  /**
   * LeaveBalance updateMany
   */
  export type LeaveBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveBalances.
     */
    data: XOR<LeaveBalanceUpdateManyMutationInput, LeaveBalanceUncheckedUpdateManyInput>
    /**
     * Filter which LeaveBalances to update
     */
    where?: LeaveBalanceWhereInput
  }

  /**
   * LeaveBalance upsert
   */
  export type LeaveBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveBalance to update in case it exists.
     */
    where: LeaveBalanceWhereUniqueInput
    /**
     * In case the LeaveBalance found by the `where` argument doesn't exist, create a new LeaveBalance with this data.
     */
    create: XOR<LeaveBalanceCreateInput, LeaveBalanceUncheckedCreateInput>
    /**
     * In case the LeaveBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveBalanceUpdateInput, LeaveBalanceUncheckedUpdateInput>
  }

  /**
   * LeaveBalance delete
   */
  export type LeaveBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter which LeaveBalance to delete.
     */
    where: LeaveBalanceWhereUniqueInput
  }

  /**
   * LeaveBalance deleteMany
   */
  export type LeaveBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveBalances to delete
     */
    where?: LeaveBalanceWhereInput
  }

  /**
   * LeaveBalance without action
   */
  export type LeaveBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
  }


  /**
   * Model LeavePolicy
   */

  export type AggregateLeavePolicy = {
    _count: LeavePolicyCountAggregateOutputType | null
    _avg: LeavePolicyAvgAggregateOutputType | null
    _sum: LeavePolicySumAggregateOutputType | null
    _min: LeavePolicyMinAggregateOutputType | null
    _max: LeavePolicyMaxAggregateOutputType | null
  }

  export type LeavePolicyAvgAggregateOutputType = {
    totalDaysPerYear: number | null
    maxCarryForwardDays: number | null
  }

  export type LeavePolicySumAggregateOutputType = {
    totalDaysPerYear: number | null
    maxCarryForwardDays: number | null
  }

  export type LeavePolicyMinAggregateOutputType = {
    id: string | null
    leaveType: string | null
    totalDaysPerYear: number | null
    canCarryForward: boolean | null
    maxCarryForwardDays: number | null
    requiresApproval: boolean | null
    allowHalfDay: boolean | null
    description: string | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeavePolicyMaxAggregateOutputType = {
    id: string | null
    leaveType: string | null
    totalDaysPerYear: number | null
    canCarryForward: boolean | null
    maxCarryForwardDays: number | null
    requiresApproval: boolean | null
    allowHalfDay: boolean | null
    description: string | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeavePolicyCountAggregateOutputType = {
    id: number
    leaveType: number
    totalDaysPerYear: number
    canCarryForward: number
    maxCarryForwardDays: number
    requiresApproval: number
    allowHalfDay: number
    description: number
    isActive: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeavePolicyAvgAggregateInputType = {
    totalDaysPerYear?: true
    maxCarryForwardDays?: true
  }

  export type LeavePolicySumAggregateInputType = {
    totalDaysPerYear?: true
    maxCarryForwardDays?: true
  }

  export type LeavePolicyMinAggregateInputType = {
    id?: true
    leaveType?: true
    totalDaysPerYear?: true
    canCarryForward?: true
    maxCarryForwardDays?: true
    requiresApproval?: true
    allowHalfDay?: true
    description?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeavePolicyMaxAggregateInputType = {
    id?: true
    leaveType?: true
    totalDaysPerYear?: true
    canCarryForward?: true
    maxCarryForwardDays?: true
    requiresApproval?: true
    allowHalfDay?: true
    description?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeavePolicyCountAggregateInputType = {
    id?: true
    leaveType?: true
    totalDaysPerYear?: true
    canCarryForward?: true
    maxCarryForwardDays?: true
    requiresApproval?: true
    allowHalfDay?: true
    description?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeavePolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeavePolicy to aggregate.
     */
    where?: LeavePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeavePolicies to fetch.
     */
    orderBy?: LeavePolicyOrderByWithRelationInput | LeavePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeavePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeavePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeavePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeavePolicies
    **/
    _count?: true | LeavePolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeavePolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeavePolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeavePolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeavePolicyMaxAggregateInputType
  }

  export type GetLeavePolicyAggregateType<T extends LeavePolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateLeavePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeavePolicy[P]>
      : GetScalarType<T[P], AggregateLeavePolicy[P]>
  }




  export type LeavePolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeavePolicyWhereInput
    orderBy?: LeavePolicyOrderByWithAggregationInput | LeavePolicyOrderByWithAggregationInput[]
    by: LeavePolicyScalarFieldEnum[] | LeavePolicyScalarFieldEnum
    having?: LeavePolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeavePolicyCountAggregateInputType | true
    _avg?: LeavePolicyAvgAggregateInputType
    _sum?: LeavePolicySumAggregateInputType
    _min?: LeavePolicyMinAggregateInputType
    _max?: LeavePolicyMaxAggregateInputType
  }

  export type LeavePolicyGroupByOutputType = {
    id: string
    leaveType: string
    totalDaysPerYear: number
    canCarryForward: boolean
    maxCarryForwardDays: number | null
    requiresApproval: boolean
    allowHalfDay: boolean
    description: string | null
    isActive: boolean
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: LeavePolicyCountAggregateOutputType | null
    _avg: LeavePolicyAvgAggregateOutputType | null
    _sum: LeavePolicySumAggregateOutputType | null
    _min: LeavePolicyMinAggregateOutputType | null
    _max: LeavePolicyMaxAggregateOutputType | null
  }

  type GetLeavePolicyGroupByPayload<T extends LeavePolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeavePolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeavePolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeavePolicyGroupByOutputType[P]>
            : GetScalarType<T[P], LeavePolicyGroupByOutputType[P]>
        }
      >
    >


  export type LeavePolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaveType?: boolean
    totalDaysPerYear?: boolean
    canCarryForward?: boolean
    maxCarryForwardDays?: boolean
    requiresApproval?: boolean
    allowHalfDay?: boolean
    description?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leavePolicy"]>

  export type LeavePolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaveType?: boolean
    totalDaysPerYear?: boolean
    canCarryForward?: boolean
    maxCarryForwardDays?: boolean
    requiresApproval?: boolean
    allowHalfDay?: boolean
    description?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leavePolicy"]>

  export type LeavePolicySelectScalar = {
    id?: boolean
    leaveType?: boolean
    totalDaysPerYear?: boolean
    canCarryForward?: boolean
    maxCarryForwardDays?: boolean
    requiresApproval?: boolean
    allowHalfDay?: boolean
    description?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeavePolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeavePolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeavePolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeavePolicy"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leaveType: string
      totalDaysPerYear: number
      canCarryForward: boolean
      maxCarryForwardDays: number | null
      requiresApproval: boolean
      allowHalfDay: boolean
      description: string | null
      isActive: boolean
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leavePolicy"]>
    composites: {}
  }

  type LeavePolicyGetPayload<S extends boolean | null | undefined | LeavePolicyDefaultArgs> = $Result.GetResult<Prisma.$LeavePolicyPayload, S>

  type LeavePolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeavePolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeavePolicyCountAggregateInputType | true
    }

  export interface LeavePolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeavePolicy'], meta: { name: 'LeavePolicy' } }
    /**
     * Find zero or one LeavePolicy that matches the filter.
     * @param {LeavePolicyFindUniqueArgs} args - Arguments to find a LeavePolicy
     * @example
     * // Get one LeavePolicy
     * const leavePolicy = await prisma.leavePolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeavePolicyFindUniqueArgs>(args: SelectSubset<T, LeavePolicyFindUniqueArgs<ExtArgs>>): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeavePolicy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeavePolicyFindUniqueOrThrowArgs} args - Arguments to find a LeavePolicy
     * @example
     * // Get one LeavePolicy
     * const leavePolicy = await prisma.leavePolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeavePolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, LeavePolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeavePolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyFindFirstArgs} args - Arguments to find a LeavePolicy
     * @example
     * // Get one LeavePolicy
     * const leavePolicy = await prisma.leavePolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeavePolicyFindFirstArgs>(args?: SelectSubset<T, LeavePolicyFindFirstArgs<ExtArgs>>): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeavePolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyFindFirstOrThrowArgs} args - Arguments to find a LeavePolicy
     * @example
     * // Get one LeavePolicy
     * const leavePolicy = await prisma.leavePolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeavePolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, LeavePolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeavePolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeavePolicies
     * const leavePolicies = await prisma.leavePolicy.findMany()
     * 
     * // Get first 10 LeavePolicies
     * const leavePolicies = await prisma.leavePolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leavePolicyWithIdOnly = await prisma.leavePolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeavePolicyFindManyArgs>(args?: SelectSubset<T, LeavePolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeavePolicy.
     * @param {LeavePolicyCreateArgs} args - Arguments to create a LeavePolicy.
     * @example
     * // Create one LeavePolicy
     * const LeavePolicy = await prisma.leavePolicy.create({
     *   data: {
     *     // ... data to create a LeavePolicy
     *   }
     * })
     * 
     */
    create<T extends LeavePolicyCreateArgs>(args: SelectSubset<T, LeavePolicyCreateArgs<ExtArgs>>): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeavePolicies.
     * @param {LeavePolicyCreateManyArgs} args - Arguments to create many LeavePolicies.
     * @example
     * // Create many LeavePolicies
     * const leavePolicy = await prisma.leavePolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeavePolicyCreateManyArgs>(args?: SelectSubset<T, LeavePolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeavePolicies and returns the data saved in the database.
     * @param {LeavePolicyCreateManyAndReturnArgs} args - Arguments to create many LeavePolicies.
     * @example
     * // Create many LeavePolicies
     * const leavePolicy = await prisma.leavePolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeavePolicies and only return the `id`
     * const leavePolicyWithIdOnly = await prisma.leavePolicy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeavePolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, LeavePolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeavePolicy.
     * @param {LeavePolicyDeleteArgs} args - Arguments to delete one LeavePolicy.
     * @example
     * // Delete one LeavePolicy
     * const LeavePolicy = await prisma.leavePolicy.delete({
     *   where: {
     *     // ... filter to delete one LeavePolicy
     *   }
     * })
     * 
     */
    delete<T extends LeavePolicyDeleteArgs>(args: SelectSubset<T, LeavePolicyDeleteArgs<ExtArgs>>): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeavePolicy.
     * @param {LeavePolicyUpdateArgs} args - Arguments to update one LeavePolicy.
     * @example
     * // Update one LeavePolicy
     * const leavePolicy = await prisma.leavePolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeavePolicyUpdateArgs>(args: SelectSubset<T, LeavePolicyUpdateArgs<ExtArgs>>): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeavePolicies.
     * @param {LeavePolicyDeleteManyArgs} args - Arguments to filter LeavePolicies to delete.
     * @example
     * // Delete a few LeavePolicies
     * const { count } = await prisma.leavePolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeavePolicyDeleteManyArgs>(args?: SelectSubset<T, LeavePolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeavePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeavePolicies
     * const leavePolicy = await prisma.leavePolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeavePolicyUpdateManyArgs>(args: SelectSubset<T, LeavePolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeavePolicy.
     * @param {LeavePolicyUpsertArgs} args - Arguments to update or create a LeavePolicy.
     * @example
     * // Update or create a LeavePolicy
     * const leavePolicy = await prisma.leavePolicy.upsert({
     *   create: {
     *     // ... data to create a LeavePolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeavePolicy we want to update
     *   }
     * })
     */
    upsert<T extends LeavePolicyUpsertArgs>(args: SelectSubset<T, LeavePolicyUpsertArgs<ExtArgs>>): Prisma__LeavePolicyClient<$Result.GetResult<Prisma.$LeavePolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeavePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyCountArgs} args - Arguments to filter LeavePolicies to count.
     * @example
     * // Count the number of LeavePolicies
     * const count = await prisma.leavePolicy.count({
     *   where: {
     *     // ... the filter for the LeavePolicies we want to count
     *   }
     * })
    **/
    count<T extends LeavePolicyCountArgs>(
      args?: Subset<T, LeavePolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeavePolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeavePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeavePolicyAggregateArgs>(args: Subset<T, LeavePolicyAggregateArgs>): Prisma.PrismaPromise<GetLeavePolicyAggregateType<T>>

    /**
     * Group by LeavePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeavePolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeavePolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeavePolicyGroupByArgs['orderBy'] }
        : { orderBy?: LeavePolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeavePolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeavePolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeavePolicy model
   */
  readonly fields: LeavePolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeavePolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeavePolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeavePolicy model
   */ 
  interface LeavePolicyFieldRefs {
    readonly id: FieldRef<"LeavePolicy", 'String'>
    readonly leaveType: FieldRef<"LeavePolicy", 'String'>
    readonly totalDaysPerYear: FieldRef<"LeavePolicy", 'Int'>
    readonly canCarryForward: FieldRef<"LeavePolicy", 'Boolean'>
    readonly maxCarryForwardDays: FieldRef<"LeavePolicy", 'Int'>
    readonly requiresApproval: FieldRef<"LeavePolicy", 'Boolean'>
    readonly allowHalfDay: FieldRef<"LeavePolicy", 'Boolean'>
    readonly description: FieldRef<"LeavePolicy", 'String'>
    readonly isActive: FieldRef<"LeavePolicy", 'Boolean'>
    readonly createdBy: FieldRef<"LeavePolicy", 'String'>
    readonly createdAt: FieldRef<"LeavePolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"LeavePolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeavePolicy findUnique
   */
  export type LeavePolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * Filter, which LeavePolicy to fetch.
     */
    where: LeavePolicyWhereUniqueInput
  }

  /**
   * LeavePolicy findUniqueOrThrow
   */
  export type LeavePolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * Filter, which LeavePolicy to fetch.
     */
    where: LeavePolicyWhereUniqueInput
  }

  /**
   * LeavePolicy findFirst
   */
  export type LeavePolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * Filter, which LeavePolicy to fetch.
     */
    where?: LeavePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeavePolicies to fetch.
     */
    orderBy?: LeavePolicyOrderByWithRelationInput | LeavePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeavePolicies.
     */
    cursor?: LeavePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeavePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeavePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeavePolicies.
     */
    distinct?: LeavePolicyScalarFieldEnum | LeavePolicyScalarFieldEnum[]
  }

  /**
   * LeavePolicy findFirstOrThrow
   */
  export type LeavePolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * Filter, which LeavePolicy to fetch.
     */
    where?: LeavePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeavePolicies to fetch.
     */
    orderBy?: LeavePolicyOrderByWithRelationInput | LeavePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeavePolicies.
     */
    cursor?: LeavePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeavePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeavePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeavePolicies.
     */
    distinct?: LeavePolicyScalarFieldEnum | LeavePolicyScalarFieldEnum[]
  }

  /**
   * LeavePolicy findMany
   */
  export type LeavePolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * Filter, which LeavePolicies to fetch.
     */
    where?: LeavePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeavePolicies to fetch.
     */
    orderBy?: LeavePolicyOrderByWithRelationInput | LeavePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeavePolicies.
     */
    cursor?: LeavePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeavePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeavePolicies.
     */
    skip?: number
    distinct?: LeavePolicyScalarFieldEnum | LeavePolicyScalarFieldEnum[]
  }

  /**
   * LeavePolicy create
   */
  export type LeavePolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a LeavePolicy.
     */
    data: XOR<LeavePolicyCreateInput, LeavePolicyUncheckedCreateInput>
  }

  /**
   * LeavePolicy createMany
   */
  export type LeavePolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeavePolicies.
     */
    data: LeavePolicyCreateManyInput | LeavePolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeavePolicy createManyAndReturn
   */
  export type LeavePolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeavePolicies.
     */
    data: LeavePolicyCreateManyInput | LeavePolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeavePolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeavePolicy update
   */
  export type LeavePolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a LeavePolicy.
     */
    data: XOR<LeavePolicyUpdateInput, LeavePolicyUncheckedUpdateInput>
    /**
     * Choose, which LeavePolicy to update.
     */
    where: LeavePolicyWhereUniqueInput
  }

  /**
   * LeavePolicy updateMany
   */
  export type LeavePolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeavePolicies.
     */
    data: XOR<LeavePolicyUpdateManyMutationInput, LeavePolicyUncheckedUpdateManyInput>
    /**
     * Filter which LeavePolicies to update
     */
    where?: LeavePolicyWhereInput
  }

  /**
   * LeavePolicy upsert
   */
  export type LeavePolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the LeavePolicy to update in case it exists.
     */
    where: LeavePolicyWhereUniqueInput
    /**
     * In case the LeavePolicy found by the `where` argument doesn't exist, create a new LeavePolicy with this data.
     */
    create: XOR<LeavePolicyCreateInput, LeavePolicyUncheckedCreateInput>
    /**
     * In case the LeavePolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeavePolicyUpdateInput, LeavePolicyUncheckedUpdateInput>
  }

  /**
   * LeavePolicy delete
   */
  export type LeavePolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeavePolicyInclude<ExtArgs> | null
    /**
     * Filter which LeavePolicy to delete.
     */
    where: LeavePolicyWhereUniqueInput
  }

  /**
   * LeavePolicy deleteMany
   */
  export type LeavePolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeavePolicies to delete
     */
    where?: LeavePolicyWhereInput
  }

  /**
   * LeavePolicy without action
   */
  export type LeavePolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeavePolicy
     */
    select?: LeavePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeavePolicyInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    action: string | null
    targetId: string | null
    targetType: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    action: string | null
    targetId: string | null
    targetType: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    action: number
    targetId: number
    targetType: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    action?: true
    targetId?: true
    targetType?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    action?: true
    targetId?: true
    targetType?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    action?: true
    targetId?: true
    targetType?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    userName: string
    action: string
    targetId: string | null
    targetType: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    targetId?: boolean
    targetType?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    targetId?: boolean
    targetType?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    targetId?: boolean
    targetType?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userName: string
      action: string
      targetId: string | null
      targetType: string | null
      details: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly userName: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly targetId: FieldRef<"AuditLog", 'String'>
    readonly targetType: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model LeaveDocument
   */

  export type AggregateLeaveDocument = {
    _count: LeaveDocumentCountAggregateOutputType | null
    _avg: LeaveDocumentAvgAggregateOutputType | null
    _sum: LeaveDocumentSumAggregateOutputType | null
    _min: LeaveDocumentMinAggregateOutputType | null
    _max: LeaveDocumentMaxAggregateOutputType | null
  }

  export type LeaveDocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type LeaveDocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type LeaveDocumentMinAggregateOutputType = {
    id: string | null
    leaveRequestId: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedAt: Date | null
  }

  export type LeaveDocumentMaxAggregateOutputType = {
    id: string | null
    leaveRequestId: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedAt: Date | null
  }

  export type LeaveDocumentCountAggregateOutputType = {
    id: number
    leaveRequestId: number
    fileName: number
    filePath: number
    fileSize: number
    mimeType: number
    uploadedAt: number
    _all: number
  }


  export type LeaveDocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type LeaveDocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type LeaveDocumentMinAggregateInputType = {
    id?: true
    leaveRequestId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedAt?: true
  }

  export type LeaveDocumentMaxAggregateInputType = {
    id?: true
    leaveRequestId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedAt?: true
  }

  export type LeaveDocumentCountAggregateInputType = {
    id?: true
    leaveRequestId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedAt?: true
    _all?: true
  }

  export type LeaveDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveDocument to aggregate.
     */
    where?: LeaveDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveDocuments to fetch.
     */
    orderBy?: LeaveDocumentOrderByWithRelationInput | LeaveDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveDocuments
    **/
    _count?: true | LeaveDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveDocumentMaxAggregateInputType
  }

  export type GetLeaveDocumentAggregateType<T extends LeaveDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveDocument[P]>
      : GetScalarType<T[P], AggregateLeaveDocument[P]>
  }




  export type LeaveDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveDocumentWhereInput
    orderBy?: LeaveDocumentOrderByWithAggregationInput | LeaveDocumentOrderByWithAggregationInput[]
    by: LeaveDocumentScalarFieldEnum[] | LeaveDocumentScalarFieldEnum
    having?: LeaveDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveDocumentCountAggregateInputType | true
    _avg?: LeaveDocumentAvgAggregateInputType
    _sum?: LeaveDocumentSumAggregateInputType
    _min?: LeaveDocumentMinAggregateInputType
    _max?: LeaveDocumentMaxAggregateInputType
  }

  export type LeaveDocumentGroupByOutputType = {
    id: string
    leaveRequestId: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt: Date
    _count: LeaveDocumentCountAggregateOutputType | null
    _avg: LeaveDocumentAvgAggregateOutputType | null
    _sum: LeaveDocumentSumAggregateOutputType | null
    _min: LeaveDocumentMinAggregateOutputType | null
    _max: LeaveDocumentMaxAggregateOutputType | null
  }

  type GetLeaveDocumentGroupByPayload<T extends LeaveDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveDocumentGroupByOutputType[P]>
        }
      >
    >


  export type LeaveDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaveRequestId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
    leaveRequest?: boolean | LeaveRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveDocument"]>

  export type LeaveDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaveRequestId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
    leaveRequest?: boolean | LeaveRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveDocument"]>

  export type LeaveDocumentSelectScalar = {
    id?: boolean
    leaveRequestId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
  }

  export type LeaveDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaveRequest?: boolean | LeaveRequestDefaultArgs<ExtArgs>
  }
  export type LeaveDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaveRequest?: boolean | LeaveRequestDefaultArgs<ExtArgs>
  }

  export type $LeaveDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveDocument"
    objects: {
      leaveRequest: Prisma.$LeaveRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leaveRequestId: string
      fileName: string
      filePath: string
      fileSize: number
      mimeType: string
      uploadedAt: Date
    }, ExtArgs["result"]["leaveDocument"]>
    composites: {}
  }

  type LeaveDocumentGetPayload<S extends boolean | null | undefined | LeaveDocumentDefaultArgs> = $Result.GetResult<Prisma.$LeaveDocumentPayload, S>

  type LeaveDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveDocumentCountAggregateInputType | true
    }

  export interface LeaveDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveDocument'], meta: { name: 'LeaveDocument' } }
    /**
     * Find zero or one LeaveDocument that matches the filter.
     * @param {LeaveDocumentFindUniqueArgs} args - Arguments to find a LeaveDocument
     * @example
     * // Get one LeaveDocument
     * const leaveDocument = await prisma.leaveDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveDocumentFindUniqueArgs>(args: SelectSubset<T, LeaveDocumentFindUniqueArgs<ExtArgs>>): Prisma__LeaveDocumentClient<$Result.GetResult<Prisma.$LeaveDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaveDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaveDocumentFindUniqueOrThrowArgs} args - Arguments to find a LeaveDocument
     * @example
     * // Get one LeaveDocument
     * const leaveDocument = await prisma.leaveDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveDocumentClient<$Result.GetResult<Prisma.$LeaveDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaveDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveDocumentFindFirstArgs} args - Arguments to find a LeaveDocument
     * @example
     * // Get one LeaveDocument
     * const leaveDocument = await prisma.leaveDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveDocumentFindFirstArgs>(args?: SelectSubset<T, LeaveDocumentFindFirstArgs<ExtArgs>>): Prisma__LeaveDocumentClient<$Result.GetResult<Prisma.$LeaveDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaveDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveDocumentFindFirstOrThrowArgs} args - Arguments to find a LeaveDocument
     * @example
     * // Get one LeaveDocument
     * const leaveDocument = await prisma.leaveDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveDocumentClient<$Result.GetResult<Prisma.$LeaveDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaveDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveDocuments
     * const leaveDocuments = await prisma.leaveDocument.findMany()
     * 
     * // Get first 10 LeaveDocuments
     * const leaveDocuments = await prisma.leaveDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveDocumentWithIdOnly = await prisma.leaveDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveDocumentFindManyArgs>(args?: SelectSubset<T, LeaveDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaveDocument.
     * @param {LeaveDocumentCreateArgs} args - Arguments to create a LeaveDocument.
     * @example
     * // Create one LeaveDocument
     * const LeaveDocument = await prisma.leaveDocument.create({
     *   data: {
     *     // ... data to create a LeaveDocument
     *   }
     * })
     * 
     */
    create<T extends LeaveDocumentCreateArgs>(args: SelectSubset<T, LeaveDocumentCreateArgs<ExtArgs>>): Prisma__LeaveDocumentClient<$Result.GetResult<Prisma.$LeaveDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaveDocuments.
     * @param {LeaveDocumentCreateManyArgs} args - Arguments to create many LeaveDocuments.
     * @example
     * // Create many LeaveDocuments
     * const leaveDocument = await prisma.leaveDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveDocumentCreateManyArgs>(args?: SelectSubset<T, LeaveDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveDocuments and returns the data saved in the database.
     * @param {LeaveDocumentCreateManyAndReturnArgs} args - Arguments to create many LeaveDocuments.
     * @example
     * // Create many LeaveDocuments
     * const leaveDocument = await prisma.leaveDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveDocuments and only return the `id`
     * const leaveDocumentWithIdOnly = await prisma.leaveDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeaveDocument.
     * @param {LeaveDocumentDeleteArgs} args - Arguments to delete one LeaveDocument.
     * @example
     * // Delete one LeaveDocument
     * const LeaveDocument = await prisma.leaveDocument.delete({
     *   where: {
     *     // ... filter to delete one LeaveDocument
     *   }
     * })
     * 
     */
    delete<T extends LeaveDocumentDeleteArgs>(args: SelectSubset<T, LeaveDocumentDeleteArgs<ExtArgs>>): Prisma__LeaveDocumentClient<$Result.GetResult<Prisma.$LeaveDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaveDocument.
     * @param {LeaveDocumentUpdateArgs} args - Arguments to update one LeaveDocument.
     * @example
     * // Update one LeaveDocument
     * const leaveDocument = await prisma.leaveDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveDocumentUpdateArgs>(args: SelectSubset<T, LeaveDocumentUpdateArgs<ExtArgs>>): Prisma__LeaveDocumentClient<$Result.GetResult<Prisma.$LeaveDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaveDocuments.
     * @param {LeaveDocumentDeleteManyArgs} args - Arguments to filter LeaveDocuments to delete.
     * @example
     * // Delete a few LeaveDocuments
     * const { count } = await prisma.leaveDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveDocumentDeleteManyArgs>(args?: SelectSubset<T, LeaveDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveDocuments
     * const leaveDocument = await prisma.leaveDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveDocumentUpdateManyArgs>(args: SelectSubset<T, LeaveDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveDocument.
     * @param {LeaveDocumentUpsertArgs} args - Arguments to update or create a LeaveDocument.
     * @example
     * // Update or create a LeaveDocument
     * const leaveDocument = await prisma.leaveDocument.upsert({
     *   create: {
     *     // ... data to create a LeaveDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveDocument we want to update
     *   }
     * })
     */
    upsert<T extends LeaveDocumentUpsertArgs>(args: SelectSubset<T, LeaveDocumentUpsertArgs<ExtArgs>>): Prisma__LeaveDocumentClient<$Result.GetResult<Prisma.$LeaveDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaveDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveDocumentCountArgs} args - Arguments to filter LeaveDocuments to count.
     * @example
     * // Count the number of LeaveDocuments
     * const count = await prisma.leaveDocument.count({
     *   where: {
     *     // ... the filter for the LeaveDocuments we want to count
     *   }
     * })
    **/
    count<T extends LeaveDocumentCountArgs>(
      args?: Subset<T, LeaveDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveDocumentAggregateArgs>(args: Subset<T, LeaveDocumentAggregateArgs>): Prisma.PrismaPromise<GetLeaveDocumentAggregateType<T>>

    /**
     * Group by LeaveDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveDocumentGroupByArgs['orderBy'] }
        : { orderBy?: LeaveDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveDocument model
   */
  readonly fields: LeaveDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leaveRequest<T extends LeaveRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequestDefaultArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveDocument model
   */ 
  interface LeaveDocumentFieldRefs {
    readonly id: FieldRef<"LeaveDocument", 'String'>
    readonly leaveRequestId: FieldRef<"LeaveDocument", 'String'>
    readonly fileName: FieldRef<"LeaveDocument", 'String'>
    readonly filePath: FieldRef<"LeaveDocument", 'String'>
    readonly fileSize: FieldRef<"LeaveDocument", 'Int'>
    readonly mimeType: FieldRef<"LeaveDocument", 'String'>
    readonly uploadedAt: FieldRef<"LeaveDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveDocument findUnique
   */
  export type LeaveDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveDocument
     */
    select?: LeaveDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveDocument to fetch.
     */
    where: LeaveDocumentWhereUniqueInput
  }

  /**
   * LeaveDocument findUniqueOrThrow
   */
  export type LeaveDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveDocument
     */
    select?: LeaveDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveDocument to fetch.
     */
    where: LeaveDocumentWhereUniqueInput
  }

  /**
   * LeaveDocument findFirst
   */
  export type LeaveDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveDocument
     */
    select?: LeaveDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveDocument to fetch.
     */
    where?: LeaveDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveDocuments to fetch.
     */
    orderBy?: LeaveDocumentOrderByWithRelationInput | LeaveDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveDocuments.
     */
    cursor?: LeaveDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveDocuments.
     */
    distinct?: LeaveDocumentScalarFieldEnum | LeaveDocumentScalarFieldEnum[]
  }

  /**
   * LeaveDocument findFirstOrThrow
   */
  export type LeaveDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveDocument
     */
    select?: LeaveDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveDocument to fetch.
     */
    where?: LeaveDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveDocuments to fetch.
     */
    orderBy?: LeaveDocumentOrderByWithRelationInput | LeaveDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveDocuments.
     */
    cursor?: LeaveDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveDocuments.
     */
    distinct?: LeaveDocumentScalarFieldEnum | LeaveDocumentScalarFieldEnum[]
  }

  /**
   * LeaveDocument findMany
   */
  export type LeaveDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveDocument
     */
    select?: LeaveDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveDocuments to fetch.
     */
    where?: LeaveDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveDocuments to fetch.
     */
    orderBy?: LeaveDocumentOrderByWithRelationInput | LeaveDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveDocuments.
     */
    cursor?: LeaveDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveDocuments.
     */
    skip?: number
    distinct?: LeaveDocumentScalarFieldEnum | LeaveDocumentScalarFieldEnum[]
  }

  /**
   * LeaveDocument create
   */
  export type LeaveDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveDocument
     */
    select?: LeaveDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveDocument.
     */
    data: XOR<LeaveDocumentCreateInput, LeaveDocumentUncheckedCreateInput>
  }

  /**
   * LeaveDocument createMany
   */
  export type LeaveDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveDocuments.
     */
    data: LeaveDocumentCreateManyInput | LeaveDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveDocument createManyAndReturn
   */
  export type LeaveDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveDocument
     */
    select?: LeaveDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeaveDocuments.
     */
    data: LeaveDocumentCreateManyInput | LeaveDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveDocument update
   */
  export type LeaveDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveDocument
     */
    select?: LeaveDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveDocument.
     */
    data: XOR<LeaveDocumentUpdateInput, LeaveDocumentUncheckedUpdateInput>
    /**
     * Choose, which LeaveDocument to update.
     */
    where: LeaveDocumentWhereUniqueInput
  }

  /**
   * LeaveDocument updateMany
   */
  export type LeaveDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveDocuments.
     */
    data: XOR<LeaveDocumentUpdateManyMutationInput, LeaveDocumentUncheckedUpdateManyInput>
    /**
     * Filter which LeaveDocuments to update
     */
    where?: LeaveDocumentWhereInput
  }

  /**
   * LeaveDocument upsert
   */
  export type LeaveDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveDocument
     */
    select?: LeaveDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveDocument to update in case it exists.
     */
    where: LeaveDocumentWhereUniqueInput
    /**
     * In case the LeaveDocument found by the `where` argument doesn't exist, create a new LeaveDocument with this data.
     */
    create: XOR<LeaveDocumentCreateInput, LeaveDocumentUncheckedCreateInput>
    /**
     * In case the LeaveDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveDocumentUpdateInput, LeaveDocumentUncheckedUpdateInput>
  }

  /**
   * LeaveDocument delete
   */
  export type LeaveDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveDocument
     */
    select?: LeaveDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveDocumentInclude<ExtArgs> | null
    /**
     * Filter which LeaveDocument to delete.
     */
    where: LeaveDocumentWhereUniqueInput
  }

  /**
   * LeaveDocument deleteMany
   */
  export type LeaveDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveDocuments to delete
     */
    where?: LeaveDocumentWhereInput
  }

  /**
   * LeaveDocument without action
   */
  export type LeaveDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveDocument
     */
    select?: LeaveDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Holiday
   */

  export type AggregateHoliday = {
    _count: HolidayCountAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  export type HolidayMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    date: Date | null
    type: $Enums.HolidayType | null
    isRecurring: boolean | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HolidayMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    date: Date | null
    type: $Enums.HolidayType | null
    isRecurring: boolean | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HolidayCountAggregateOutputType = {
    id: number
    name: number
    description: number
    date: number
    type: number
    isRecurring: number
    isActive: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HolidayMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    date?: true
    type?: true
    isRecurring?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HolidayMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    date?: true
    type?: true
    isRecurring?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HolidayCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    date?: true
    type?: true
    isRecurring?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HolidayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holiday to aggregate.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Holidays
    **/
    _count?: true | HolidayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HolidayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HolidayMaxAggregateInputType
  }

  export type GetHolidayAggregateType<T extends HolidayAggregateArgs> = {
        [P in keyof T & keyof AggregateHoliday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoliday[P]>
      : GetScalarType<T[P], AggregateHoliday[P]>
  }




  export type HolidayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolidayWhereInput
    orderBy?: HolidayOrderByWithAggregationInput | HolidayOrderByWithAggregationInput[]
    by: HolidayScalarFieldEnum[] | HolidayScalarFieldEnum
    having?: HolidayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HolidayCountAggregateInputType | true
    _min?: HolidayMinAggregateInputType
    _max?: HolidayMaxAggregateInputType
  }

  export type HolidayGroupByOutputType = {
    id: string
    name: string
    description: string | null
    date: Date
    type: $Enums.HolidayType
    isRecurring: boolean
    isActive: boolean
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: HolidayCountAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  type GetHolidayGroupByPayload<T extends HolidayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HolidayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HolidayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HolidayGroupByOutputType[P]>
            : GetScalarType<T[P], HolidayGroupByOutputType[P]>
        }
      >
    >


  export type HolidaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    date?: boolean
    type?: boolean
    isRecurring?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    date?: boolean
    type?: boolean
    isRecurring?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    date?: boolean
    type?: boolean
    isRecurring?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HolidayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HolidayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HolidayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Holiday"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      date: Date
      type: $Enums.HolidayType
      isRecurring: boolean
      isActive: boolean
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["holiday"]>
    composites: {}
  }

  type HolidayGetPayload<S extends boolean | null | undefined | HolidayDefaultArgs> = $Result.GetResult<Prisma.$HolidayPayload, S>

  type HolidayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HolidayFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HolidayCountAggregateInputType | true
    }

  export interface HolidayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Holiday'], meta: { name: 'Holiday' } }
    /**
     * Find zero or one Holiday that matches the filter.
     * @param {HolidayFindUniqueArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HolidayFindUniqueArgs>(args: SelectSubset<T, HolidayFindUniqueArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Holiday that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HolidayFindUniqueOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HolidayFindUniqueOrThrowArgs>(args: SelectSubset<T, HolidayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Holiday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HolidayFindFirstArgs>(args?: SelectSubset<T, HolidayFindFirstArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Holiday that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HolidayFindFirstOrThrowArgs>(args?: SelectSubset<T, HolidayFindFirstOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Holidays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Holidays
     * const holidays = await prisma.holiday.findMany()
     * 
     * // Get first 10 Holidays
     * const holidays = await prisma.holiday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holidayWithIdOnly = await prisma.holiday.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HolidayFindManyArgs>(args?: SelectSubset<T, HolidayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Holiday.
     * @param {HolidayCreateArgs} args - Arguments to create a Holiday.
     * @example
     * // Create one Holiday
     * const Holiday = await prisma.holiday.create({
     *   data: {
     *     // ... data to create a Holiday
     *   }
     * })
     * 
     */
    create<T extends HolidayCreateArgs>(args: SelectSubset<T, HolidayCreateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Holidays.
     * @param {HolidayCreateManyArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HolidayCreateManyArgs>(args?: SelectSubset<T, HolidayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Holidays and returns the data saved in the database.
     * @param {HolidayCreateManyAndReturnArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Holidays and only return the `id`
     * const holidayWithIdOnly = await prisma.holiday.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HolidayCreateManyAndReturnArgs>(args?: SelectSubset<T, HolidayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Holiday.
     * @param {HolidayDeleteArgs} args - Arguments to delete one Holiday.
     * @example
     * // Delete one Holiday
     * const Holiday = await prisma.holiday.delete({
     *   where: {
     *     // ... filter to delete one Holiday
     *   }
     * })
     * 
     */
    delete<T extends HolidayDeleteArgs>(args: SelectSubset<T, HolidayDeleteArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Holiday.
     * @param {HolidayUpdateArgs} args - Arguments to update one Holiday.
     * @example
     * // Update one Holiday
     * const holiday = await prisma.holiday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HolidayUpdateArgs>(args: SelectSubset<T, HolidayUpdateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Holidays.
     * @param {HolidayDeleteManyArgs} args - Arguments to filter Holidays to delete.
     * @example
     * // Delete a few Holidays
     * const { count } = await prisma.holiday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HolidayDeleteManyArgs>(args?: SelectSubset<T, HolidayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Holidays
     * const holiday = await prisma.holiday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HolidayUpdateManyArgs>(args: SelectSubset<T, HolidayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Holiday.
     * @param {HolidayUpsertArgs} args - Arguments to update or create a Holiday.
     * @example
     * // Update or create a Holiday
     * const holiday = await prisma.holiday.upsert({
     *   create: {
     *     // ... data to create a Holiday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Holiday we want to update
     *   }
     * })
     */
    upsert<T extends HolidayUpsertArgs>(args: SelectSubset<T, HolidayUpsertArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayCountArgs} args - Arguments to filter Holidays to count.
     * @example
     * // Count the number of Holidays
     * const count = await prisma.holiday.count({
     *   where: {
     *     // ... the filter for the Holidays we want to count
     *   }
     * })
    **/
    count<T extends HolidayCountArgs>(
      args?: Subset<T, HolidayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HolidayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HolidayAggregateArgs>(args: Subset<T, HolidayAggregateArgs>): Prisma.PrismaPromise<GetHolidayAggregateType<T>>

    /**
     * Group by Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HolidayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HolidayGroupByArgs['orderBy'] }
        : { orderBy?: HolidayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HolidayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHolidayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Holiday model
   */
  readonly fields: HolidayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Holiday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HolidayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Holiday model
   */ 
  interface HolidayFieldRefs {
    readonly id: FieldRef<"Holiday", 'String'>
    readonly name: FieldRef<"Holiday", 'String'>
    readonly description: FieldRef<"Holiday", 'String'>
    readonly date: FieldRef<"Holiday", 'DateTime'>
    readonly type: FieldRef<"Holiday", 'HolidayType'>
    readonly isRecurring: FieldRef<"Holiday", 'Boolean'>
    readonly isActive: FieldRef<"Holiday", 'Boolean'>
    readonly createdBy: FieldRef<"Holiday", 'String'>
    readonly createdAt: FieldRef<"Holiday", 'DateTime'>
    readonly updatedAt: FieldRef<"Holiday", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Holiday findUnique
   */
  export type HolidayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findUniqueOrThrow
   */
  export type HolidayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findFirst
   */
  export type HolidayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findFirstOrThrow
   */
  export type HolidayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findMany
   */
  export type HolidayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holidays to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday create
   */
  export type HolidayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * The data needed to create a Holiday.
     */
    data: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
  }

  /**
   * Holiday createMany
   */
  export type HolidayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Holiday createManyAndReturn
   */
  export type HolidayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Holiday update
   */
  export type HolidayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * The data needed to update a Holiday.
     */
    data: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
    /**
     * Choose, which Holiday to update.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday updateMany
   */
  export type HolidayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Holidays.
     */
    data: XOR<HolidayUpdateManyMutationInput, HolidayUncheckedUpdateManyInput>
    /**
     * Filter which Holidays to update
     */
    where?: HolidayWhereInput
  }

  /**
   * Holiday upsert
   */
  export type HolidayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * The filter to search for the Holiday to update in case it exists.
     */
    where: HolidayWhereUniqueInput
    /**
     * In case the Holiday found by the `where` argument doesn't exist, create a new Holiday with this data.
     */
    create: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
    /**
     * In case the Holiday was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
  }

  /**
   * Holiday delete
   */
  export type HolidayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter which Holiday to delete.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday deleteMany
   */
  export type HolidayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holidays to delete
     */
    where?: HolidayWhereInput
  }

  /**
   * Holiday without action
   */
  export type HolidayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceRecord
   */

  export type AggregateAttendanceRecord = {
    _count: AttendanceRecordCountAggregateOutputType | null
    _avg: AttendanceRecordAvgAggregateOutputType | null
    _sum: AttendanceRecordSumAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  export type AttendanceRecordAvgAggregateOutputType = {
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
  }

  export type AttendanceRecordSumAggregateOutputType = {
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
  }

  export type AttendanceRecordMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    checkInTime: Date | null
    checkOutTime: Date | null
    status: $Enums.AttendanceStatus | null
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
    notes: string | null
    isHoliday: boolean | null
    isWeekend: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceRecordMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    checkInTime: Date | null
    checkOutTime: Date | null
    status: $Enums.AttendanceStatus | null
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
    notes: string | null
    isHoliday: boolean | null
    isWeekend: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceRecordCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    checkInTime: number
    checkOutTime: number
    status: number
    hoursWorked: number
    overtimeHours: number
    notes: number
    isHoliday: number
    isWeekend: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceRecordAvgAggregateInputType = {
    hoursWorked?: true
    overtimeHours?: true
  }

  export type AttendanceRecordSumAggregateInputType = {
    hoursWorked?: true
    overtimeHours?: true
  }

  export type AttendanceRecordMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    checkInTime?: true
    checkOutTime?: true
    status?: true
    hoursWorked?: true
    overtimeHours?: true
    notes?: true
    isHoliday?: true
    isWeekend?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    checkInTime?: true
    checkOutTime?: true
    status?: true
    hoursWorked?: true
    overtimeHours?: true
    notes?: true
    isHoliday?: true
    isWeekend?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceRecordCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    checkInTime?: true
    checkOutTime?: true
    status?: true
    hoursWorked?: true
    overtimeHours?: true
    notes?: true
    isHoliday?: true
    isWeekend?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecord to aggregate.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceRecords
    **/
    _count?: true | AttendanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type GetAttendanceRecordAggregateType<T extends AttendanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceRecord[P]>
      : GetScalarType<T[P], AggregateAttendanceRecord[P]>
  }




  export type AttendanceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithAggregationInput | AttendanceRecordOrderByWithAggregationInput[]
    by: AttendanceRecordScalarFieldEnum[] | AttendanceRecordScalarFieldEnum
    having?: AttendanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceRecordCountAggregateInputType | true
    _avg?: AttendanceRecordAvgAggregateInputType
    _sum?: AttendanceRecordSumAggregateInputType
    _min?: AttendanceRecordMinAggregateInputType
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type AttendanceRecordGroupByOutputType = {
    id: string
    userId: string
    date: Date
    checkInTime: Date | null
    checkOutTime: Date | null
    status: $Enums.AttendanceStatus
    hoursWorked: Decimal
    overtimeHours: Decimal
    notes: string | null
    isHoliday: boolean
    isWeekend: boolean
    createdAt: Date
    updatedAt: Date
    _count: AttendanceRecordCountAggregateOutputType | null
    _avg: AttendanceRecordAvgAggregateOutputType | null
    _sum: AttendanceRecordSumAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  type GetAttendanceRecordGroupByPayload<T extends AttendanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    status?: boolean
    hoursWorked?: boolean
    overtimeHours?: boolean
    notes?: boolean
    isHoliday?: boolean
    isWeekend?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    status?: boolean
    hoursWorked?: boolean
    overtimeHours?: boolean
    notes?: boolean
    isHoliday?: boolean
    isWeekend?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    status?: boolean
    hoursWorked?: boolean
    overtimeHours?: boolean
    notes?: boolean
    isHoliday?: boolean
    isWeekend?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendanceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      checkInTime: Date | null
      checkOutTime: Date | null
      status: $Enums.AttendanceStatus
      hoursWorked: Prisma.Decimal
      overtimeHours: Prisma.Decimal
      notes: string | null
      isHoliday: boolean
      isWeekend: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendanceRecord"]>
    composites: {}
  }

  type AttendanceRecordGetPayload<S extends boolean | null | undefined | AttendanceRecordDefaultArgs> = $Result.GetResult<Prisma.$AttendanceRecordPayload, S>

  type AttendanceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttendanceRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttendanceRecordCountAggregateInputType | true
    }

  export interface AttendanceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceRecord'], meta: { name: 'AttendanceRecord' } }
    /**
     * Find zero or one AttendanceRecord that matches the filter.
     * @param {AttendanceRecordFindUniqueArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceRecordFindUniqueArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AttendanceRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttendanceRecordFindUniqueOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AttendanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceRecordFindFirstArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AttendanceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AttendanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany()
     * 
     * // Get first 10 AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceRecordFindManyArgs>(args?: SelectSubset<T, AttendanceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AttendanceRecord.
     * @param {AttendanceRecordCreateArgs} args - Arguments to create a AttendanceRecord.
     * @example
     * // Create one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.create({
     *   data: {
     *     // ... data to create a AttendanceRecord
     *   }
     * })
     * 
     */
    create<T extends AttendanceRecordCreateArgs>(args: SelectSubset<T, AttendanceRecordCreateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AttendanceRecords.
     * @param {AttendanceRecordCreateManyArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceRecordCreateManyArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceRecords and returns the data saved in the database.
     * @param {AttendanceRecordCreateManyAndReturnArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceRecords and only return the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AttendanceRecord.
     * @param {AttendanceRecordDeleteArgs} args - Arguments to delete one AttendanceRecord.
     * @example
     * // Delete one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.delete({
     *   where: {
     *     // ... filter to delete one AttendanceRecord
     *   }
     * })
     * 
     */
    delete<T extends AttendanceRecordDeleteArgs>(args: SelectSubset<T, AttendanceRecordDeleteArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AttendanceRecord.
     * @param {AttendanceRecordUpdateArgs} args - Arguments to update one AttendanceRecord.
     * @example
     * // Update one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceRecordUpdateArgs>(args: SelectSubset<T, AttendanceRecordUpdateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AttendanceRecords.
     * @param {AttendanceRecordDeleteManyArgs} args - Arguments to filter AttendanceRecords to delete.
     * @example
     * // Delete a few AttendanceRecords
     * const { count } = await prisma.attendanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceRecordDeleteManyArgs>(args?: SelectSubset<T, AttendanceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceRecordUpdateManyArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttendanceRecord.
     * @param {AttendanceRecordUpsertArgs} args - Arguments to update or create a AttendanceRecord.
     * @example
     * // Update or create a AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.upsert({
     *   create: {
     *     // ... data to create a AttendanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceRecord we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceRecordUpsertArgs>(args: SelectSubset<T, AttendanceRecordUpsertArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordCountArgs} args - Arguments to filter AttendanceRecords to count.
     * @example
     * // Count the number of AttendanceRecords
     * const count = await prisma.attendanceRecord.count({
     *   where: {
     *     // ... the filter for the AttendanceRecords we want to count
     *   }
     * })
    **/
    count<T extends AttendanceRecordCountArgs>(
      args?: Subset<T, AttendanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceRecordAggregateArgs>(args: Subset<T, AttendanceRecordAggregateArgs>): Prisma.PrismaPromise<GetAttendanceRecordAggregateType<T>>

    /**
     * Group by AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceRecord model
   */
  readonly fields: AttendanceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceRecord model
   */ 
  interface AttendanceRecordFieldRefs {
    readonly id: FieldRef<"AttendanceRecord", 'String'>
    readonly userId: FieldRef<"AttendanceRecord", 'String'>
    readonly date: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly checkInTime: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly checkOutTime: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly status: FieldRef<"AttendanceRecord", 'AttendanceStatus'>
    readonly hoursWorked: FieldRef<"AttendanceRecord", 'Decimal'>
    readonly overtimeHours: FieldRef<"AttendanceRecord", 'Decimal'>
    readonly notes: FieldRef<"AttendanceRecord", 'String'>
    readonly isHoliday: FieldRef<"AttendanceRecord", 'Boolean'>
    readonly isWeekend: FieldRef<"AttendanceRecord", 'Boolean'>
    readonly createdAt: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"AttendanceRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceRecord findUnique
   */
  export type AttendanceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findUniqueOrThrow
   */
  export type AttendanceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findFirst
   */
  export type AttendanceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findFirstOrThrow
   */
  export type AttendanceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findMany
   */
  export type AttendanceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecords to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord create
   */
  export type AttendanceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceRecord.
     */
    data: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
  }

  /**
   * AttendanceRecord createMany
   */
  export type AttendanceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceRecord createManyAndReturn
   */
  export type AttendanceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceRecord update
   */
  export type AttendanceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceRecord.
     */
    data: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
    /**
     * Choose, which AttendanceRecord to update.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord updateMany
   */
  export type AttendanceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
  }

  /**
   * AttendanceRecord upsert
   */
  export type AttendanceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceRecord to update in case it exists.
     */
    where: AttendanceRecordWhereUniqueInput
    /**
     * In case the AttendanceRecord found by the `where` argument doesn't exist, create a new AttendanceRecord with this data.
     */
    create: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
    /**
     * In case the AttendanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
  }

  /**
   * AttendanceRecord delete
   */
  export type AttendanceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter which AttendanceRecord to delete.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord deleteMany
   */
  export type AttendanceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecords to delete
     */
    where?: AttendanceRecordWhereInput
  }

  /**
   * AttendanceRecord without action
   */
  export type AttendanceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
  }


  /**
   * Model AttendancePolicy
   */

  export type AggregateAttendancePolicy = {
    _count: AttendancePolicyCountAggregateOutputType | null
    _avg: AttendancePolicyAvgAggregateOutputType | null
    _sum: AttendancePolicySumAggregateOutputType | null
    _min: AttendancePolicyMinAggregateOutputType | null
    _max: AttendancePolicyMaxAggregateOutputType | null
  }

  export type AttendancePolicyAvgAggregateOutputType = {
    workingHoursPerDay: Decimal | null
    lateThresholdMinutes: number | null
    overtimeThresholdHours: Decimal | null
  }

  export type AttendancePolicySumAggregateOutputType = {
    workingHoursPerDay: Decimal | null
    lateThresholdMinutes: number | null
    overtimeThresholdHours: Decimal | null
  }

  export type AttendancePolicyMinAggregateOutputType = {
    id: string | null
    name: string | null
    workingHoursPerDay: Decimal | null
    lateThresholdMinutes: number | null
    overtimeThresholdHours: Decimal | null
    allowFlexibleHours: boolean | null
    requireCheckIn: boolean | null
    requireCheckOut: boolean | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendancePolicyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    workingHoursPerDay: Decimal | null
    lateThresholdMinutes: number | null
    overtimeThresholdHours: Decimal | null
    allowFlexibleHours: boolean | null
    requireCheckIn: boolean | null
    requireCheckOut: boolean | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendancePolicyCountAggregateOutputType = {
    id: number
    name: number
    workingHoursPerDay: number
    lateThresholdMinutes: number
    overtimeThresholdHours: number
    allowFlexibleHours: number
    requireCheckIn: number
    requireCheckOut: number
    isActive: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendancePolicyAvgAggregateInputType = {
    workingHoursPerDay?: true
    lateThresholdMinutes?: true
    overtimeThresholdHours?: true
  }

  export type AttendancePolicySumAggregateInputType = {
    workingHoursPerDay?: true
    lateThresholdMinutes?: true
    overtimeThresholdHours?: true
  }

  export type AttendancePolicyMinAggregateInputType = {
    id?: true
    name?: true
    workingHoursPerDay?: true
    lateThresholdMinutes?: true
    overtimeThresholdHours?: true
    allowFlexibleHours?: true
    requireCheckIn?: true
    requireCheckOut?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendancePolicyMaxAggregateInputType = {
    id?: true
    name?: true
    workingHoursPerDay?: true
    lateThresholdMinutes?: true
    overtimeThresholdHours?: true
    allowFlexibleHours?: true
    requireCheckIn?: true
    requireCheckOut?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendancePolicyCountAggregateInputType = {
    id?: true
    name?: true
    workingHoursPerDay?: true
    lateThresholdMinutes?: true
    overtimeThresholdHours?: true
    allowFlexibleHours?: true
    requireCheckIn?: true
    requireCheckOut?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendancePolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendancePolicy to aggregate.
     */
    where?: AttendancePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendancePolicies to fetch.
     */
    orderBy?: AttendancePolicyOrderByWithRelationInput | AttendancePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendancePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendancePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendancePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendancePolicies
    **/
    _count?: true | AttendancePolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendancePolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendancePolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendancePolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendancePolicyMaxAggregateInputType
  }

  export type GetAttendancePolicyAggregateType<T extends AttendancePolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendancePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendancePolicy[P]>
      : GetScalarType<T[P], AggregateAttendancePolicy[P]>
  }




  export type AttendancePolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendancePolicyWhereInput
    orderBy?: AttendancePolicyOrderByWithAggregationInput | AttendancePolicyOrderByWithAggregationInput[]
    by: AttendancePolicyScalarFieldEnum[] | AttendancePolicyScalarFieldEnum
    having?: AttendancePolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendancePolicyCountAggregateInputType | true
    _avg?: AttendancePolicyAvgAggregateInputType
    _sum?: AttendancePolicySumAggregateInputType
    _min?: AttendancePolicyMinAggregateInputType
    _max?: AttendancePolicyMaxAggregateInputType
  }

  export type AttendancePolicyGroupByOutputType = {
    id: string
    name: string
    workingHoursPerDay: Decimal
    lateThresholdMinutes: number
    overtimeThresholdHours: Decimal
    allowFlexibleHours: boolean
    requireCheckIn: boolean
    requireCheckOut: boolean
    isActive: boolean
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: AttendancePolicyCountAggregateOutputType | null
    _avg: AttendancePolicyAvgAggregateOutputType | null
    _sum: AttendancePolicySumAggregateOutputType | null
    _min: AttendancePolicyMinAggregateOutputType | null
    _max: AttendancePolicyMaxAggregateOutputType | null
  }

  type GetAttendancePolicyGroupByPayload<T extends AttendancePolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendancePolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendancePolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendancePolicyGroupByOutputType[P]>
            : GetScalarType<T[P], AttendancePolicyGroupByOutputType[P]>
        }
      >
    >


  export type AttendancePolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    workingHoursPerDay?: boolean
    lateThresholdMinutes?: boolean
    overtimeThresholdHours?: boolean
    allowFlexibleHours?: boolean
    requireCheckIn?: boolean
    requireCheckOut?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendancePolicy"]>

  export type AttendancePolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    workingHoursPerDay?: boolean
    lateThresholdMinutes?: boolean
    overtimeThresholdHours?: boolean
    allowFlexibleHours?: boolean
    requireCheckIn?: boolean
    requireCheckOut?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendancePolicy"]>

  export type AttendancePolicySelectScalar = {
    id?: boolean
    name?: boolean
    workingHoursPerDay?: boolean
    lateThresholdMinutes?: boolean
    overtimeThresholdHours?: boolean
    allowFlexibleHours?: boolean
    requireCheckIn?: boolean
    requireCheckOut?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendancePolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendancePolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendancePolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendancePolicy"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      workingHoursPerDay: Prisma.Decimal
      lateThresholdMinutes: number
      overtimeThresholdHours: Prisma.Decimal
      allowFlexibleHours: boolean
      requireCheckIn: boolean
      requireCheckOut: boolean
      isActive: boolean
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendancePolicy"]>
    composites: {}
  }

  type AttendancePolicyGetPayload<S extends boolean | null | undefined | AttendancePolicyDefaultArgs> = $Result.GetResult<Prisma.$AttendancePolicyPayload, S>

  type AttendancePolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttendancePolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttendancePolicyCountAggregateInputType | true
    }

  export interface AttendancePolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendancePolicy'], meta: { name: 'AttendancePolicy' } }
    /**
     * Find zero or one AttendancePolicy that matches the filter.
     * @param {AttendancePolicyFindUniqueArgs} args - Arguments to find a AttendancePolicy
     * @example
     * // Get one AttendancePolicy
     * const attendancePolicy = await prisma.attendancePolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendancePolicyFindUniqueArgs>(args: SelectSubset<T, AttendancePolicyFindUniqueArgs<ExtArgs>>): Prisma__AttendancePolicyClient<$Result.GetResult<Prisma.$AttendancePolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AttendancePolicy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttendancePolicyFindUniqueOrThrowArgs} args - Arguments to find a AttendancePolicy
     * @example
     * // Get one AttendancePolicy
     * const attendancePolicy = await prisma.attendancePolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendancePolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendancePolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendancePolicyClient<$Result.GetResult<Prisma.$AttendancePolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AttendancePolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancePolicyFindFirstArgs} args - Arguments to find a AttendancePolicy
     * @example
     * // Get one AttendancePolicy
     * const attendancePolicy = await prisma.attendancePolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendancePolicyFindFirstArgs>(args?: SelectSubset<T, AttendancePolicyFindFirstArgs<ExtArgs>>): Prisma__AttendancePolicyClient<$Result.GetResult<Prisma.$AttendancePolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AttendancePolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancePolicyFindFirstOrThrowArgs} args - Arguments to find a AttendancePolicy
     * @example
     * // Get one AttendancePolicy
     * const attendancePolicy = await prisma.attendancePolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendancePolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendancePolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendancePolicyClient<$Result.GetResult<Prisma.$AttendancePolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AttendancePolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancePolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendancePolicies
     * const attendancePolicies = await prisma.attendancePolicy.findMany()
     * 
     * // Get first 10 AttendancePolicies
     * const attendancePolicies = await prisma.attendancePolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendancePolicyWithIdOnly = await prisma.attendancePolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendancePolicyFindManyArgs>(args?: SelectSubset<T, AttendancePolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AttendancePolicy.
     * @param {AttendancePolicyCreateArgs} args - Arguments to create a AttendancePolicy.
     * @example
     * // Create one AttendancePolicy
     * const AttendancePolicy = await prisma.attendancePolicy.create({
     *   data: {
     *     // ... data to create a AttendancePolicy
     *   }
     * })
     * 
     */
    create<T extends AttendancePolicyCreateArgs>(args: SelectSubset<T, AttendancePolicyCreateArgs<ExtArgs>>): Prisma__AttendancePolicyClient<$Result.GetResult<Prisma.$AttendancePolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AttendancePolicies.
     * @param {AttendancePolicyCreateManyArgs} args - Arguments to create many AttendancePolicies.
     * @example
     * // Create many AttendancePolicies
     * const attendancePolicy = await prisma.attendancePolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendancePolicyCreateManyArgs>(args?: SelectSubset<T, AttendancePolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendancePolicies and returns the data saved in the database.
     * @param {AttendancePolicyCreateManyAndReturnArgs} args - Arguments to create many AttendancePolicies.
     * @example
     * // Create many AttendancePolicies
     * const attendancePolicy = await prisma.attendancePolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendancePolicies and only return the `id`
     * const attendancePolicyWithIdOnly = await prisma.attendancePolicy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendancePolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendancePolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePolicyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AttendancePolicy.
     * @param {AttendancePolicyDeleteArgs} args - Arguments to delete one AttendancePolicy.
     * @example
     * // Delete one AttendancePolicy
     * const AttendancePolicy = await prisma.attendancePolicy.delete({
     *   where: {
     *     // ... filter to delete one AttendancePolicy
     *   }
     * })
     * 
     */
    delete<T extends AttendancePolicyDeleteArgs>(args: SelectSubset<T, AttendancePolicyDeleteArgs<ExtArgs>>): Prisma__AttendancePolicyClient<$Result.GetResult<Prisma.$AttendancePolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AttendancePolicy.
     * @param {AttendancePolicyUpdateArgs} args - Arguments to update one AttendancePolicy.
     * @example
     * // Update one AttendancePolicy
     * const attendancePolicy = await prisma.attendancePolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendancePolicyUpdateArgs>(args: SelectSubset<T, AttendancePolicyUpdateArgs<ExtArgs>>): Prisma__AttendancePolicyClient<$Result.GetResult<Prisma.$AttendancePolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AttendancePolicies.
     * @param {AttendancePolicyDeleteManyArgs} args - Arguments to filter AttendancePolicies to delete.
     * @example
     * // Delete a few AttendancePolicies
     * const { count } = await prisma.attendancePolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendancePolicyDeleteManyArgs>(args?: SelectSubset<T, AttendancePolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendancePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancePolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendancePolicies
     * const attendancePolicy = await prisma.attendancePolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendancePolicyUpdateManyArgs>(args: SelectSubset<T, AttendancePolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttendancePolicy.
     * @param {AttendancePolicyUpsertArgs} args - Arguments to update or create a AttendancePolicy.
     * @example
     * // Update or create a AttendancePolicy
     * const attendancePolicy = await prisma.attendancePolicy.upsert({
     *   create: {
     *     // ... data to create a AttendancePolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendancePolicy we want to update
     *   }
     * })
     */
    upsert<T extends AttendancePolicyUpsertArgs>(args: SelectSubset<T, AttendancePolicyUpsertArgs<ExtArgs>>): Prisma__AttendancePolicyClient<$Result.GetResult<Prisma.$AttendancePolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AttendancePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancePolicyCountArgs} args - Arguments to filter AttendancePolicies to count.
     * @example
     * // Count the number of AttendancePolicies
     * const count = await prisma.attendancePolicy.count({
     *   where: {
     *     // ... the filter for the AttendancePolicies we want to count
     *   }
     * })
    **/
    count<T extends AttendancePolicyCountArgs>(
      args?: Subset<T, AttendancePolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendancePolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendancePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancePolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendancePolicyAggregateArgs>(args: Subset<T, AttendancePolicyAggregateArgs>): Prisma.PrismaPromise<GetAttendancePolicyAggregateType<T>>

    /**
     * Group by AttendancePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancePolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendancePolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendancePolicyGroupByArgs['orderBy'] }
        : { orderBy?: AttendancePolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendancePolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendancePolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendancePolicy model
   */
  readonly fields: AttendancePolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendancePolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendancePolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendancePolicy model
   */ 
  interface AttendancePolicyFieldRefs {
    readonly id: FieldRef<"AttendancePolicy", 'String'>
    readonly name: FieldRef<"AttendancePolicy", 'String'>
    readonly workingHoursPerDay: FieldRef<"AttendancePolicy", 'Decimal'>
    readonly lateThresholdMinutes: FieldRef<"AttendancePolicy", 'Int'>
    readonly overtimeThresholdHours: FieldRef<"AttendancePolicy", 'Decimal'>
    readonly allowFlexibleHours: FieldRef<"AttendancePolicy", 'Boolean'>
    readonly requireCheckIn: FieldRef<"AttendancePolicy", 'Boolean'>
    readonly requireCheckOut: FieldRef<"AttendancePolicy", 'Boolean'>
    readonly isActive: FieldRef<"AttendancePolicy", 'Boolean'>
    readonly createdBy: FieldRef<"AttendancePolicy", 'String'>
    readonly createdAt: FieldRef<"AttendancePolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"AttendancePolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendancePolicy findUnique
   */
  export type AttendancePolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendancePolicy
     */
    select?: AttendancePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancePolicyInclude<ExtArgs> | null
    /**
     * Filter, which AttendancePolicy to fetch.
     */
    where: AttendancePolicyWhereUniqueInput
  }

  /**
   * AttendancePolicy findUniqueOrThrow
   */
  export type AttendancePolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendancePolicy
     */
    select?: AttendancePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancePolicyInclude<ExtArgs> | null
    /**
     * Filter, which AttendancePolicy to fetch.
     */
    where: AttendancePolicyWhereUniqueInput
  }

  /**
   * AttendancePolicy findFirst
   */
  export type AttendancePolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendancePolicy
     */
    select?: AttendancePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancePolicyInclude<ExtArgs> | null
    /**
     * Filter, which AttendancePolicy to fetch.
     */
    where?: AttendancePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendancePolicies to fetch.
     */
    orderBy?: AttendancePolicyOrderByWithRelationInput | AttendancePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendancePolicies.
     */
    cursor?: AttendancePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendancePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendancePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendancePolicies.
     */
    distinct?: AttendancePolicyScalarFieldEnum | AttendancePolicyScalarFieldEnum[]
  }

  /**
   * AttendancePolicy findFirstOrThrow
   */
  export type AttendancePolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendancePolicy
     */
    select?: AttendancePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancePolicyInclude<ExtArgs> | null
    /**
     * Filter, which AttendancePolicy to fetch.
     */
    where?: AttendancePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendancePolicies to fetch.
     */
    orderBy?: AttendancePolicyOrderByWithRelationInput | AttendancePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendancePolicies.
     */
    cursor?: AttendancePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendancePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendancePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendancePolicies.
     */
    distinct?: AttendancePolicyScalarFieldEnum | AttendancePolicyScalarFieldEnum[]
  }

  /**
   * AttendancePolicy findMany
   */
  export type AttendancePolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendancePolicy
     */
    select?: AttendancePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancePolicyInclude<ExtArgs> | null
    /**
     * Filter, which AttendancePolicies to fetch.
     */
    where?: AttendancePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendancePolicies to fetch.
     */
    orderBy?: AttendancePolicyOrderByWithRelationInput | AttendancePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendancePolicies.
     */
    cursor?: AttendancePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendancePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendancePolicies.
     */
    skip?: number
    distinct?: AttendancePolicyScalarFieldEnum | AttendancePolicyScalarFieldEnum[]
  }

  /**
   * AttendancePolicy create
   */
  export type AttendancePolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendancePolicy
     */
    select?: AttendancePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancePolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendancePolicy.
     */
    data: XOR<AttendancePolicyCreateInput, AttendancePolicyUncheckedCreateInput>
  }

  /**
   * AttendancePolicy createMany
   */
  export type AttendancePolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendancePolicies.
     */
    data: AttendancePolicyCreateManyInput | AttendancePolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendancePolicy createManyAndReturn
   */
  export type AttendancePolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendancePolicy
     */
    select?: AttendancePolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AttendancePolicies.
     */
    data: AttendancePolicyCreateManyInput | AttendancePolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancePolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendancePolicy update
   */
  export type AttendancePolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendancePolicy
     */
    select?: AttendancePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancePolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendancePolicy.
     */
    data: XOR<AttendancePolicyUpdateInput, AttendancePolicyUncheckedUpdateInput>
    /**
     * Choose, which AttendancePolicy to update.
     */
    where: AttendancePolicyWhereUniqueInput
  }

  /**
   * AttendancePolicy updateMany
   */
  export type AttendancePolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendancePolicies.
     */
    data: XOR<AttendancePolicyUpdateManyMutationInput, AttendancePolicyUncheckedUpdateManyInput>
    /**
     * Filter which AttendancePolicies to update
     */
    where?: AttendancePolicyWhereInput
  }

  /**
   * AttendancePolicy upsert
   */
  export type AttendancePolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendancePolicy
     */
    select?: AttendancePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancePolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendancePolicy to update in case it exists.
     */
    where: AttendancePolicyWhereUniqueInput
    /**
     * In case the AttendancePolicy found by the `where` argument doesn't exist, create a new AttendancePolicy with this data.
     */
    create: XOR<AttendancePolicyCreateInput, AttendancePolicyUncheckedCreateInput>
    /**
     * In case the AttendancePolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendancePolicyUpdateInput, AttendancePolicyUncheckedUpdateInput>
  }

  /**
   * AttendancePolicy delete
   */
  export type AttendancePolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendancePolicy
     */
    select?: AttendancePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancePolicyInclude<ExtArgs> | null
    /**
     * Filter which AttendancePolicy to delete.
     */
    where: AttendancePolicyWhereUniqueInput
  }

  /**
   * AttendancePolicy deleteMany
   */
  export type AttendancePolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendancePolicies to delete
     */
    where?: AttendancePolicyWhereInput
  }

  /**
   * AttendancePolicy without action
   */
  export type AttendancePolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendancePolicy
     */
    select?: AttendancePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancePolicyInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeSalary
   */

  export type AggregateEmployeeSalary = {
    _count: EmployeeSalaryCountAggregateOutputType | null
    _avg: EmployeeSalaryAvgAggregateOutputType | null
    _sum: EmployeeSalarySumAggregateOutputType | null
    _min: EmployeeSalaryMinAggregateOutputType | null
    _max: EmployeeSalaryMaxAggregateOutputType | null
  }

  export type EmployeeSalaryAvgAggregateOutputType = {
    baseSalary: Decimal | null
    hourlyRate: Decimal | null
  }

  export type EmployeeSalarySumAggregateOutputType = {
    baseSalary: Decimal | null
    hourlyRate: Decimal | null
  }

  export type EmployeeSalaryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    baseSalary: Decimal | null
    hourlyRate: Decimal | null
    currency: string | null
    effectiveDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeSalaryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    baseSalary: Decimal | null
    hourlyRate: Decimal | null
    currency: string | null
    effectiveDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeSalaryCountAggregateOutputType = {
    id: number
    userId: number
    baseSalary: number
    hourlyRate: number
    currency: number
    effectiveDate: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeSalaryAvgAggregateInputType = {
    baseSalary?: true
    hourlyRate?: true
  }

  export type EmployeeSalarySumAggregateInputType = {
    baseSalary?: true
    hourlyRate?: true
  }

  export type EmployeeSalaryMinAggregateInputType = {
    id?: true
    userId?: true
    baseSalary?: true
    hourlyRate?: true
    currency?: true
    effectiveDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeSalaryMaxAggregateInputType = {
    id?: true
    userId?: true
    baseSalary?: true
    hourlyRate?: true
    currency?: true
    effectiveDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeSalaryCountAggregateInputType = {
    id?: true
    userId?: true
    baseSalary?: true
    hourlyRate?: true
    currency?: true
    effectiveDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeSalaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeSalary to aggregate.
     */
    where?: EmployeeSalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeSalaries to fetch.
     */
    orderBy?: EmployeeSalaryOrderByWithRelationInput | EmployeeSalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeSalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeSalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeSalaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeSalaries
    **/
    _count?: true | EmployeeSalaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeSalaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSalarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeSalaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeSalaryMaxAggregateInputType
  }

  export type GetEmployeeSalaryAggregateType<T extends EmployeeSalaryAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeSalary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeSalary[P]>
      : GetScalarType<T[P], AggregateEmployeeSalary[P]>
  }




  export type EmployeeSalaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeSalaryWhereInput
    orderBy?: EmployeeSalaryOrderByWithAggregationInput | EmployeeSalaryOrderByWithAggregationInput[]
    by: EmployeeSalaryScalarFieldEnum[] | EmployeeSalaryScalarFieldEnum
    having?: EmployeeSalaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeSalaryCountAggregateInputType | true
    _avg?: EmployeeSalaryAvgAggregateInputType
    _sum?: EmployeeSalarySumAggregateInputType
    _min?: EmployeeSalaryMinAggregateInputType
    _max?: EmployeeSalaryMaxAggregateInputType
  }

  export type EmployeeSalaryGroupByOutputType = {
    id: string
    userId: string
    baseSalary: Decimal
    hourlyRate: Decimal | null
    currency: string
    effectiveDate: Date
    endDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmployeeSalaryCountAggregateOutputType | null
    _avg: EmployeeSalaryAvgAggregateOutputType | null
    _sum: EmployeeSalarySumAggregateOutputType | null
    _min: EmployeeSalaryMinAggregateOutputType | null
    _max: EmployeeSalaryMaxAggregateOutputType | null
  }

  type GetEmployeeSalaryGroupByPayload<T extends EmployeeSalaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeSalaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeSalaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeSalaryGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeSalaryGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSalarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    baseSalary?: boolean
    hourlyRate?: boolean
    currency?: boolean
    effectiveDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    monthlySalaries?: boolean | EmployeeSalary$monthlySalariesArgs<ExtArgs>
    _count?: boolean | EmployeeSalaryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeSalary"]>

  export type EmployeeSalarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    baseSalary?: boolean
    hourlyRate?: boolean
    currency?: boolean
    effectiveDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeSalary"]>

  export type EmployeeSalarySelectScalar = {
    id?: boolean
    userId?: boolean
    baseSalary?: boolean
    hourlyRate?: boolean
    currency?: boolean
    effectiveDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeSalaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    monthlySalaries?: boolean | EmployeeSalary$monthlySalariesArgs<ExtArgs>
    _count?: boolean | EmployeeSalaryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeSalaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeeSalaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeSalary"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      monthlySalaries: Prisma.$MonthlySalaryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      baseSalary: Prisma.Decimal
      hourlyRate: Prisma.Decimal | null
      currency: string
      effectiveDate: Date
      endDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeSalary"]>
    composites: {}
  }

  type EmployeeSalaryGetPayload<S extends boolean | null | undefined | EmployeeSalaryDefaultArgs> = $Result.GetResult<Prisma.$EmployeeSalaryPayload, S>

  type EmployeeSalaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeSalaryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeSalaryCountAggregateInputType | true
    }

  export interface EmployeeSalaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeSalary'], meta: { name: 'EmployeeSalary' } }
    /**
     * Find zero or one EmployeeSalary that matches the filter.
     * @param {EmployeeSalaryFindUniqueArgs} args - Arguments to find a EmployeeSalary
     * @example
     * // Get one EmployeeSalary
     * const employeeSalary = await prisma.employeeSalary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeSalaryFindUniqueArgs>(args: SelectSubset<T, EmployeeSalaryFindUniqueArgs<ExtArgs>>): Prisma__EmployeeSalaryClient<$Result.GetResult<Prisma.$EmployeeSalaryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeSalary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeSalaryFindUniqueOrThrowArgs} args - Arguments to find a EmployeeSalary
     * @example
     * // Get one EmployeeSalary
     * const employeeSalary = await prisma.employeeSalary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeSalaryFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeSalaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeSalaryClient<$Result.GetResult<Prisma.$EmployeeSalaryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeSalary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeSalaryFindFirstArgs} args - Arguments to find a EmployeeSalary
     * @example
     * // Get one EmployeeSalary
     * const employeeSalary = await prisma.employeeSalary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeSalaryFindFirstArgs>(args?: SelectSubset<T, EmployeeSalaryFindFirstArgs<ExtArgs>>): Prisma__EmployeeSalaryClient<$Result.GetResult<Prisma.$EmployeeSalaryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeSalary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeSalaryFindFirstOrThrowArgs} args - Arguments to find a EmployeeSalary
     * @example
     * // Get one EmployeeSalary
     * const employeeSalary = await prisma.employeeSalary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeSalaryFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeSalaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeSalaryClient<$Result.GetResult<Prisma.$EmployeeSalaryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeSalaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeSalaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeSalaries
     * const employeeSalaries = await prisma.employeeSalary.findMany()
     * 
     * // Get first 10 EmployeeSalaries
     * const employeeSalaries = await prisma.employeeSalary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeSalaryWithIdOnly = await prisma.employeeSalary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeSalaryFindManyArgs>(args?: SelectSubset<T, EmployeeSalaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeSalaryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeSalary.
     * @param {EmployeeSalaryCreateArgs} args - Arguments to create a EmployeeSalary.
     * @example
     * // Create one EmployeeSalary
     * const EmployeeSalary = await prisma.employeeSalary.create({
     *   data: {
     *     // ... data to create a EmployeeSalary
     *   }
     * })
     * 
     */
    create<T extends EmployeeSalaryCreateArgs>(args: SelectSubset<T, EmployeeSalaryCreateArgs<ExtArgs>>): Prisma__EmployeeSalaryClient<$Result.GetResult<Prisma.$EmployeeSalaryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeSalaries.
     * @param {EmployeeSalaryCreateManyArgs} args - Arguments to create many EmployeeSalaries.
     * @example
     * // Create many EmployeeSalaries
     * const employeeSalary = await prisma.employeeSalary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeSalaryCreateManyArgs>(args?: SelectSubset<T, EmployeeSalaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeSalaries and returns the data saved in the database.
     * @param {EmployeeSalaryCreateManyAndReturnArgs} args - Arguments to create many EmployeeSalaries.
     * @example
     * // Create many EmployeeSalaries
     * const employeeSalary = await prisma.employeeSalary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeSalaries and only return the `id`
     * const employeeSalaryWithIdOnly = await prisma.employeeSalary.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeSalaryCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeSalaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeSalaryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeSalary.
     * @param {EmployeeSalaryDeleteArgs} args - Arguments to delete one EmployeeSalary.
     * @example
     * // Delete one EmployeeSalary
     * const EmployeeSalary = await prisma.employeeSalary.delete({
     *   where: {
     *     // ... filter to delete one EmployeeSalary
     *   }
     * })
     * 
     */
    delete<T extends EmployeeSalaryDeleteArgs>(args: SelectSubset<T, EmployeeSalaryDeleteArgs<ExtArgs>>): Prisma__EmployeeSalaryClient<$Result.GetResult<Prisma.$EmployeeSalaryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeSalary.
     * @param {EmployeeSalaryUpdateArgs} args - Arguments to update one EmployeeSalary.
     * @example
     * // Update one EmployeeSalary
     * const employeeSalary = await prisma.employeeSalary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeSalaryUpdateArgs>(args: SelectSubset<T, EmployeeSalaryUpdateArgs<ExtArgs>>): Prisma__EmployeeSalaryClient<$Result.GetResult<Prisma.$EmployeeSalaryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeSalaries.
     * @param {EmployeeSalaryDeleteManyArgs} args - Arguments to filter EmployeeSalaries to delete.
     * @example
     * // Delete a few EmployeeSalaries
     * const { count } = await prisma.employeeSalary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeSalaryDeleteManyArgs>(args?: SelectSubset<T, EmployeeSalaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeSalaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeSalaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeSalaries
     * const employeeSalary = await prisma.employeeSalary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeSalaryUpdateManyArgs>(args: SelectSubset<T, EmployeeSalaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeSalary.
     * @param {EmployeeSalaryUpsertArgs} args - Arguments to update or create a EmployeeSalary.
     * @example
     * // Update or create a EmployeeSalary
     * const employeeSalary = await prisma.employeeSalary.upsert({
     *   create: {
     *     // ... data to create a EmployeeSalary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeSalary we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeSalaryUpsertArgs>(args: SelectSubset<T, EmployeeSalaryUpsertArgs<ExtArgs>>): Prisma__EmployeeSalaryClient<$Result.GetResult<Prisma.$EmployeeSalaryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeSalaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeSalaryCountArgs} args - Arguments to filter EmployeeSalaries to count.
     * @example
     * // Count the number of EmployeeSalaries
     * const count = await prisma.employeeSalary.count({
     *   where: {
     *     // ... the filter for the EmployeeSalaries we want to count
     *   }
     * })
    **/
    count<T extends EmployeeSalaryCountArgs>(
      args?: Subset<T, EmployeeSalaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeSalaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeSalary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeSalaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeSalaryAggregateArgs>(args: Subset<T, EmployeeSalaryAggregateArgs>): Prisma.PrismaPromise<GetEmployeeSalaryAggregateType<T>>

    /**
     * Group by EmployeeSalary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeSalaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeSalaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeSalaryGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeSalaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeSalaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeSalaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeSalary model
   */
  readonly fields: EmployeeSalaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeSalary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeSalaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    monthlySalaries<T extends EmployeeSalary$monthlySalariesArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeSalary$monthlySalariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeSalary model
   */ 
  interface EmployeeSalaryFieldRefs {
    readonly id: FieldRef<"EmployeeSalary", 'String'>
    readonly userId: FieldRef<"EmployeeSalary", 'String'>
    readonly baseSalary: FieldRef<"EmployeeSalary", 'Decimal'>
    readonly hourlyRate: FieldRef<"EmployeeSalary", 'Decimal'>
    readonly currency: FieldRef<"EmployeeSalary", 'String'>
    readonly effectiveDate: FieldRef<"EmployeeSalary", 'DateTime'>
    readonly endDate: FieldRef<"EmployeeSalary", 'DateTime'>
    readonly isActive: FieldRef<"EmployeeSalary", 'Boolean'>
    readonly createdAt: FieldRef<"EmployeeSalary", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeSalary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeSalary findUnique
   */
  export type EmployeeSalaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalary
     */
    select?: EmployeeSalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeSalaryInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeSalary to fetch.
     */
    where: EmployeeSalaryWhereUniqueInput
  }

  /**
   * EmployeeSalary findUniqueOrThrow
   */
  export type EmployeeSalaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalary
     */
    select?: EmployeeSalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeSalaryInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeSalary to fetch.
     */
    where: EmployeeSalaryWhereUniqueInput
  }

  /**
   * EmployeeSalary findFirst
   */
  export type EmployeeSalaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalary
     */
    select?: EmployeeSalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeSalaryInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeSalary to fetch.
     */
    where?: EmployeeSalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeSalaries to fetch.
     */
    orderBy?: EmployeeSalaryOrderByWithRelationInput | EmployeeSalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeSalaries.
     */
    cursor?: EmployeeSalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeSalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeSalaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeSalaries.
     */
    distinct?: EmployeeSalaryScalarFieldEnum | EmployeeSalaryScalarFieldEnum[]
  }

  /**
   * EmployeeSalary findFirstOrThrow
   */
  export type EmployeeSalaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalary
     */
    select?: EmployeeSalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeSalaryInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeSalary to fetch.
     */
    where?: EmployeeSalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeSalaries to fetch.
     */
    orderBy?: EmployeeSalaryOrderByWithRelationInput | EmployeeSalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeSalaries.
     */
    cursor?: EmployeeSalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeSalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeSalaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeSalaries.
     */
    distinct?: EmployeeSalaryScalarFieldEnum | EmployeeSalaryScalarFieldEnum[]
  }

  /**
   * EmployeeSalary findMany
   */
  export type EmployeeSalaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalary
     */
    select?: EmployeeSalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeSalaryInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeSalaries to fetch.
     */
    where?: EmployeeSalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeSalaries to fetch.
     */
    orderBy?: EmployeeSalaryOrderByWithRelationInput | EmployeeSalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeSalaries.
     */
    cursor?: EmployeeSalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeSalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeSalaries.
     */
    skip?: number
    distinct?: EmployeeSalaryScalarFieldEnum | EmployeeSalaryScalarFieldEnum[]
  }

  /**
   * EmployeeSalary create
   */
  export type EmployeeSalaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalary
     */
    select?: EmployeeSalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeSalaryInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeSalary.
     */
    data: XOR<EmployeeSalaryCreateInput, EmployeeSalaryUncheckedCreateInput>
  }

  /**
   * EmployeeSalary createMany
   */
  export type EmployeeSalaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeSalaries.
     */
    data: EmployeeSalaryCreateManyInput | EmployeeSalaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeSalary createManyAndReturn
   */
  export type EmployeeSalaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalary
     */
    select?: EmployeeSalarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeSalaries.
     */
    data: EmployeeSalaryCreateManyInput | EmployeeSalaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeSalaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeSalary update
   */
  export type EmployeeSalaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalary
     */
    select?: EmployeeSalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeSalaryInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeSalary.
     */
    data: XOR<EmployeeSalaryUpdateInput, EmployeeSalaryUncheckedUpdateInput>
    /**
     * Choose, which EmployeeSalary to update.
     */
    where: EmployeeSalaryWhereUniqueInput
  }

  /**
   * EmployeeSalary updateMany
   */
  export type EmployeeSalaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeSalaries.
     */
    data: XOR<EmployeeSalaryUpdateManyMutationInput, EmployeeSalaryUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeSalaries to update
     */
    where?: EmployeeSalaryWhereInput
  }

  /**
   * EmployeeSalary upsert
   */
  export type EmployeeSalaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalary
     */
    select?: EmployeeSalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeSalaryInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeSalary to update in case it exists.
     */
    where: EmployeeSalaryWhereUniqueInput
    /**
     * In case the EmployeeSalary found by the `where` argument doesn't exist, create a new EmployeeSalary with this data.
     */
    create: XOR<EmployeeSalaryCreateInput, EmployeeSalaryUncheckedCreateInput>
    /**
     * In case the EmployeeSalary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeSalaryUpdateInput, EmployeeSalaryUncheckedUpdateInput>
  }

  /**
   * EmployeeSalary delete
   */
  export type EmployeeSalaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalary
     */
    select?: EmployeeSalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeSalaryInclude<ExtArgs> | null
    /**
     * Filter which EmployeeSalary to delete.
     */
    where: EmployeeSalaryWhereUniqueInput
  }

  /**
   * EmployeeSalary deleteMany
   */
  export type EmployeeSalaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeSalaries to delete
     */
    where?: EmployeeSalaryWhereInput
  }

  /**
   * EmployeeSalary.monthlySalaries
   */
  export type EmployeeSalary$monthlySalariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
    where?: MonthlySalaryWhereInput
    orderBy?: MonthlySalaryOrderByWithRelationInput | MonthlySalaryOrderByWithRelationInput[]
    cursor?: MonthlySalaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthlySalaryScalarFieldEnum | MonthlySalaryScalarFieldEnum[]
  }

  /**
   * EmployeeSalary without action
   */
  export type EmployeeSalaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSalary
     */
    select?: EmployeeSalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeSalaryInclude<ExtArgs> | null
  }


  /**
   * Model MonthlySalary
   */

  export type AggregateMonthlySalary = {
    _count: MonthlySalaryCountAggregateOutputType | null
    _avg: MonthlySalaryAvgAggregateOutputType | null
    _sum: MonthlySalarySumAggregateOutputType | null
    _min: MonthlySalaryMinAggregateOutputType | null
    _max: MonthlySalaryMaxAggregateOutputType | null
  }

  export type MonthlySalaryAvgAggregateOutputType = {
    year: number | null
    month: number | null
    baseSalary: Decimal | null
    grossSalary: Decimal | null
    totalDeductions: Decimal | null
    netSalary: Decimal | null
  }

  export type MonthlySalarySumAggregateOutputType = {
    year: number | null
    month: number | null
    baseSalary: Decimal | null
    grossSalary: Decimal | null
    totalDeductions: Decimal | null
    netSalary: Decimal | null
  }

  export type MonthlySalaryMinAggregateOutputType = {
    id: string | null
    employeeSalaryId: string | null
    userId: string | null
    year: number | null
    month: number | null
    baseSalary: Decimal | null
    grossSalary: Decimal | null
    totalDeductions: Decimal | null
    netSalary: Decimal | null
    status: $Enums.SalaryStatus | null
    calculatedAt: Date | null
    approvedAt: Date | null
    paidAt: Date | null
    approvedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MonthlySalaryMaxAggregateOutputType = {
    id: string | null
    employeeSalaryId: string | null
    userId: string | null
    year: number | null
    month: number | null
    baseSalary: Decimal | null
    grossSalary: Decimal | null
    totalDeductions: Decimal | null
    netSalary: Decimal | null
    status: $Enums.SalaryStatus | null
    calculatedAt: Date | null
    approvedAt: Date | null
    paidAt: Date | null
    approvedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MonthlySalaryCountAggregateOutputType = {
    id: number
    employeeSalaryId: number
    userId: number
    year: number
    month: number
    baseSalary: number
    grossSalary: number
    totalDeductions: number
    netSalary: number
    status: number
    calculatedAt: number
    approvedAt: number
    paidAt: number
    approvedBy: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MonthlySalaryAvgAggregateInputType = {
    year?: true
    month?: true
    baseSalary?: true
    grossSalary?: true
    totalDeductions?: true
    netSalary?: true
  }

  export type MonthlySalarySumAggregateInputType = {
    year?: true
    month?: true
    baseSalary?: true
    grossSalary?: true
    totalDeductions?: true
    netSalary?: true
  }

  export type MonthlySalaryMinAggregateInputType = {
    id?: true
    employeeSalaryId?: true
    userId?: true
    year?: true
    month?: true
    baseSalary?: true
    grossSalary?: true
    totalDeductions?: true
    netSalary?: true
    status?: true
    calculatedAt?: true
    approvedAt?: true
    paidAt?: true
    approvedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MonthlySalaryMaxAggregateInputType = {
    id?: true
    employeeSalaryId?: true
    userId?: true
    year?: true
    month?: true
    baseSalary?: true
    grossSalary?: true
    totalDeductions?: true
    netSalary?: true
    status?: true
    calculatedAt?: true
    approvedAt?: true
    paidAt?: true
    approvedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MonthlySalaryCountAggregateInputType = {
    id?: true
    employeeSalaryId?: true
    userId?: true
    year?: true
    month?: true
    baseSalary?: true
    grossSalary?: true
    totalDeductions?: true
    netSalary?: true
    status?: true
    calculatedAt?: true
    approvedAt?: true
    paidAt?: true
    approvedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MonthlySalaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthlySalary to aggregate.
     */
    where?: MonthlySalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlySalaries to fetch.
     */
    orderBy?: MonthlySalaryOrderByWithRelationInput | MonthlySalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonthlySalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlySalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlySalaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonthlySalaries
    **/
    _count?: true | MonthlySalaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonthlySalaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonthlySalarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonthlySalaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonthlySalaryMaxAggregateInputType
  }

  export type GetMonthlySalaryAggregateType<T extends MonthlySalaryAggregateArgs> = {
        [P in keyof T & keyof AggregateMonthlySalary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonthlySalary[P]>
      : GetScalarType<T[P], AggregateMonthlySalary[P]>
  }




  export type MonthlySalaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlySalaryWhereInput
    orderBy?: MonthlySalaryOrderByWithAggregationInput | MonthlySalaryOrderByWithAggregationInput[]
    by: MonthlySalaryScalarFieldEnum[] | MonthlySalaryScalarFieldEnum
    having?: MonthlySalaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonthlySalaryCountAggregateInputType | true
    _avg?: MonthlySalaryAvgAggregateInputType
    _sum?: MonthlySalarySumAggregateInputType
    _min?: MonthlySalaryMinAggregateInputType
    _max?: MonthlySalaryMaxAggregateInputType
  }

  export type MonthlySalaryGroupByOutputType = {
    id: string
    employeeSalaryId: string
    userId: string
    year: number
    month: number
    baseSalary: Decimal
    grossSalary: Decimal
    totalDeductions: Decimal
    netSalary: Decimal
    status: $Enums.SalaryStatus
    calculatedAt: Date | null
    approvedAt: Date | null
    paidAt: Date | null
    approvedBy: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: MonthlySalaryCountAggregateOutputType | null
    _avg: MonthlySalaryAvgAggregateOutputType | null
    _sum: MonthlySalarySumAggregateOutputType | null
    _min: MonthlySalaryMinAggregateOutputType | null
    _max: MonthlySalaryMaxAggregateOutputType | null
  }

  type GetMonthlySalaryGroupByPayload<T extends MonthlySalaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonthlySalaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonthlySalaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonthlySalaryGroupByOutputType[P]>
            : GetScalarType<T[P], MonthlySalaryGroupByOutputType[P]>
        }
      >
    >


  export type MonthlySalarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeSalaryId?: boolean
    userId?: boolean
    year?: boolean
    month?: boolean
    baseSalary?: boolean
    grossSalary?: boolean
    totalDeductions?: boolean
    netSalary?: boolean
    status?: boolean
    calculatedAt?: boolean
    approvedAt?: boolean
    paidAt?: boolean
    approvedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeSalary?: boolean | EmployeeSalaryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | MonthlySalary$approverArgs<ExtArgs>
    deductions?: boolean | MonthlySalary$deductionsArgs<ExtArgs>
    _count?: boolean | MonthlySalaryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthlySalary"]>

  export type MonthlySalarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeSalaryId?: boolean
    userId?: boolean
    year?: boolean
    month?: boolean
    baseSalary?: boolean
    grossSalary?: boolean
    totalDeductions?: boolean
    netSalary?: boolean
    status?: boolean
    calculatedAt?: boolean
    approvedAt?: boolean
    paidAt?: boolean
    approvedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeSalary?: boolean | EmployeeSalaryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | MonthlySalary$approverArgs<ExtArgs>
  }, ExtArgs["result"]["monthlySalary"]>

  export type MonthlySalarySelectScalar = {
    id?: boolean
    employeeSalaryId?: boolean
    userId?: boolean
    year?: boolean
    month?: boolean
    baseSalary?: boolean
    grossSalary?: boolean
    totalDeductions?: boolean
    netSalary?: boolean
    status?: boolean
    calculatedAt?: boolean
    approvedAt?: boolean
    paidAt?: boolean
    approvedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MonthlySalaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeSalary?: boolean | EmployeeSalaryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | MonthlySalary$approverArgs<ExtArgs>
    deductions?: boolean | MonthlySalary$deductionsArgs<ExtArgs>
    _count?: boolean | MonthlySalaryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MonthlySalaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeSalary?: boolean | EmployeeSalaryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | MonthlySalary$approverArgs<ExtArgs>
  }

  export type $MonthlySalaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonthlySalary"
    objects: {
      employeeSalary: Prisma.$EmployeeSalaryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
      deductions: Prisma.$SalaryDeductionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeSalaryId: string
      userId: string
      year: number
      month: number
      baseSalary: Prisma.Decimal
      grossSalary: Prisma.Decimal
      totalDeductions: Prisma.Decimal
      netSalary: Prisma.Decimal
      status: $Enums.SalaryStatus
      calculatedAt: Date | null
      approvedAt: Date | null
      paidAt: Date | null
      approvedBy: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["monthlySalary"]>
    composites: {}
  }

  type MonthlySalaryGetPayload<S extends boolean | null | undefined | MonthlySalaryDefaultArgs> = $Result.GetResult<Prisma.$MonthlySalaryPayload, S>

  type MonthlySalaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MonthlySalaryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MonthlySalaryCountAggregateInputType | true
    }

  export interface MonthlySalaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonthlySalary'], meta: { name: 'MonthlySalary' } }
    /**
     * Find zero or one MonthlySalary that matches the filter.
     * @param {MonthlySalaryFindUniqueArgs} args - Arguments to find a MonthlySalary
     * @example
     * // Get one MonthlySalary
     * const monthlySalary = await prisma.monthlySalary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonthlySalaryFindUniqueArgs>(args: SelectSubset<T, MonthlySalaryFindUniqueArgs<ExtArgs>>): Prisma__MonthlySalaryClient<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MonthlySalary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MonthlySalaryFindUniqueOrThrowArgs} args - Arguments to find a MonthlySalary
     * @example
     * // Get one MonthlySalary
     * const monthlySalary = await prisma.monthlySalary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonthlySalaryFindUniqueOrThrowArgs>(args: SelectSubset<T, MonthlySalaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonthlySalaryClient<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MonthlySalary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlySalaryFindFirstArgs} args - Arguments to find a MonthlySalary
     * @example
     * // Get one MonthlySalary
     * const monthlySalary = await prisma.monthlySalary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonthlySalaryFindFirstArgs>(args?: SelectSubset<T, MonthlySalaryFindFirstArgs<ExtArgs>>): Prisma__MonthlySalaryClient<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MonthlySalary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlySalaryFindFirstOrThrowArgs} args - Arguments to find a MonthlySalary
     * @example
     * // Get one MonthlySalary
     * const monthlySalary = await prisma.monthlySalary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonthlySalaryFindFirstOrThrowArgs>(args?: SelectSubset<T, MonthlySalaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonthlySalaryClient<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MonthlySalaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlySalaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonthlySalaries
     * const monthlySalaries = await prisma.monthlySalary.findMany()
     * 
     * // Get first 10 MonthlySalaries
     * const monthlySalaries = await prisma.monthlySalary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monthlySalaryWithIdOnly = await prisma.monthlySalary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonthlySalaryFindManyArgs>(args?: SelectSubset<T, MonthlySalaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MonthlySalary.
     * @param {MonthlySalaryCreateArgs} args - Arguments to create a MonthlySalary.
     * @example
     * // Create one MonthlySalary
     * const MonthlySalary = await prisma.monthlySalary.create({
     *   data: {
     *     // ... data to create a MonthlySalary
     *   }
     * })
     * 
     */
    create<T extends MonthlySalaryCreateArgs>(args: SelectSubset<T, MonthlySalaryCreateArgs<ExtArgs>>): Prisma__MonthlySalaryClient<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MonthlySalaries.
     * @param {MonthlySalaryCreateManyArgs} args - Arguments to create many MonthlySalaries.
     * @example
     * // Create many MonthlySalaries
     * const monthlySalary = await prisma.monthlySalary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonthlySalaryCreateManyArgs>(args?: SelectSubset<T, MonthlySalaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonthlySalaries and returns the data saved in the database.
     * @param {MonthlySalaryCreateManyAndReturnArgs} args - Arguments to create many MonthlySalaries.
     * @example
     * // Create many MonthlySalaries
     * const monthlySalary = await prisma.monthlySalary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonthlySalaries and only return the `id`
     * const monthlySalaryWithIdOnly = await prisma.monthlySalary.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonthlySalaryCreateManyAndReturnArgs>(args?: SelectSubset<T, MonthlySalaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MonthlySalary.
     * @param {MonthlySalaryDeleteArgs} args - Arguments to delete one MonthlySalary.
     * @example
     * // Delete one MonthlySalary
     * const MonthlySalary = await prisma.monthlySalary.delete({
     *   where: {
     *     // ... filter to delete one MonthlySalary
     *   }
     * })
     * 
     */
    delete<T extends MonthlySalaryDeleteArgs>(args: SelectSubset<T, MonthlySalaryDeleteArgs<ExtArgs>>): Prisma__MonthlySalaryClient<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MonthlySalary.
     * @param {MonthlySalaryUpdateArgs} args - Arguments to update one MonthlySalary.
     * @example
     * // Update one MonthlySalary
     * const monthlySalary = await prisma.monthlySalary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonthlySalaryUpdateArgs>(args: SelectSubset<T, MonthlySalaryUpdateArgs<ExtArgs>>): Prisma__MonthlySalaryClient<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MonthlySalaries.
     * @param {MonthlySalaryDeleteManyArgs} args - Arguments to filter MonthlySalaries to delete.
     * @example
     * // Delete a few MonthlySalaries
     * const { count } = await prisma.monthlySalary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonthlySalaryDeleteManyArgs>(args?: SelectSubset<T, MonthlySalaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonthlySalaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlySalaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonthlySalaries
     * const monthlySalary = await prisma.monthlySalary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonthlySalaryUpdateManyArgs>(args: SelectSubset<T, MonthlySalaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MonthlySalary.
     * @param {MonthlySalaryUpsertArgs} args - Arguments to update or create a MonthlySalary.
     * @example
     * // Update or create a MonthlySalary
     * const monthlySalary = await prisma.monthlySalary.upsert({
     *   create: {
     *     // ... data to create a MonthlySalary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonthlySalary we want to update
     *   }
     * })
     */
    upsert<T extends MonthlySalaryUpsertArgs>(args: SelectSubset<T, MonthlySalaryUpsertArgs<ExtArgs>>): Prisma__MonthlySalaryClient<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MonthlySalaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlySalaryCountArgs} args - Arguments to filter MonthlySalaries to count.
     * @example
     * // Count the number of MonthlySalaries
     * const count = await prisma.monthlySalary.count({
     *   where: {
     *     // ... the filter for the MonthlySalaries we want to count
     *   }
     * })
    **/
    count<T extends MonthlySalaryCountArgs>(
      args?: Subset<T, MonthlySalaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonthlySalaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonthlySalary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlySalaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonthlySalaryAggregateArgs>(args: Subset<T, MonthlySalaryAggregateArgs>): Prisma.PrismaPromise<GetMonthlySalaryAggregateType<T>>

    /**
     * Group by MonthlySalary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlySalaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonthlySalaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonthlySalaryGroupByArgs['orderBy'] }
        : { orderBy?: MonthlySalaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonthlySalaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonthlySalaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonthlySalary model
   */
  readonly fields: MonthlySalaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonthlySalary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonthlySalaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employeeSalary<T extends EmployeeSalaryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeSalaryDefaultArgs<ExtArgs>>): Prisma__EmployeeSalaryClient<$Result.GetResult<Prisma.$EmployeeSalaryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approver<T extends MonthlySalary$approverArgs<ExtArgs> = {}>(args?: Subset<T, MonthlySalary$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    deductions<T extends MonthlySalary$deductionsArgs<ExtArgs> = {}>(args?: Subset<T, MonthlySalary$deductionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryDeductionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonthlySalary model
   */ 
  interface MonthlySalaryFieldRefs {
    readonly id: FieldRef<"MonthlySalary", 'String'>
    readonly employeeSalaryId: FieldRef<"MonthlySalary", 'String'>
    readonly userId: FieldRef<"MonthlySalary", 'String'>
    readonly year: FieldRef<"MonthlySalary", 'Int'>
    readonly month: FieldRef<"MonthlySalary", 'Int'>
    readonly baseSalary: FieldRef<"MonthlySalary", 'Decimal'>
    readonly grossSalary: FieldRef<"MonthlySalary", 'Decimal'>
    readonly totalDeductions: FieldRef<"MonthlySalary", 'Decimal'>
    readonly netSalary: FieldRef<"MonthlySalary", 'Decimal'>
    readonly status: FieldRef<"MonthlySalary", 'SalaryStatus'>
    readonly calculatedAt: FieldRef<"MonthlySalary", 'DateTime'>
    readonly approvedAt: FieldRef<"MonthlySalary", 'DateTime'>
    readonly paidAt: FieldRef<"MonthlySalary", 'DateTime'>
    readonly approvedBy: FieldRef<"MonthlySalary", 'String'>
    readonly notes: FieldRef<"MonthlySalary", 'String'>
    readonly createdAt: FieldRef<"MonthlySalary", 'DateTime'>
    readonly updatedAt: FieldRef<"MonthlySalary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MonthlySalary findUnique
   */
  export type MonthlySalaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
    /**
     * Filter, which MonthlySalary to fetch.
     */
    where: MonthlySalaryWhereUniqueInput
  }

  /**
   * MonthlySalary findUniqueOrThrow
   */
  export type MonthlySalaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
    /**
     * Filter, which MonthlySalary to fetch.
     */
    where: MonthlySalaryWhereUniqueInput
  }

  /**
   * MonthlySalary findFirst
   */
  export type MonthlySalaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
    /**
     * Filter, which MonthlySalary to fetch.
     */
    where?: MonthlySalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlySalaries to fetch.
     */
    orderBy?: MonthlySalaryOrderByWithRelationInput | MonthlySalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthlySalaries.
     */
    cursor?: MonthlySalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlySalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlySalaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthlySalaries.
     */
    distinct?: MonthlySalaryScalarFieldEnum | MonthlySalaryScalarFieldEnum[]
  }

  /**
   * MonthlySalary findFirstOrThrow
   */
  export type MonthlySalaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
    /**
     * Filter, which MonthlySalary to fetch.
     */
    where?: MonthlySalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlySalaries to fetch.
     */
    orderBy?: MonthlySalaryOrderByWithRelationInput | MonthlySalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthlySalaries.
     */
    cursor?: MonthlySalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlySalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlySalaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthlySalaries.
     */
    distinct?: MonthlySalaryScalarFieldEnum | MonthlySalaryScalarFieldEnum[]
  }

  /**
   * MonthlySalary findMany
   */
  export type MonthlySalaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
    /**
     * Filter, which MonthlySalaries to fetch.
     */
    where?: MonthlySalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlySalaries to fetch.
     */
    orderBy?: MonthlySalaryOrderByWithRelationInput | MonthlySalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonthlySalaries.
     */
    cursor?: MonthlySalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlySalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlySalaries.
     */
    skip?: number
    distinct?: MonthlySalaryScalarFieldEnum | MonthlySalaryScalarFieldEnum[]
  }

  /**
   * MonthlySalary create
   */
  export type MonthlySalaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
    /**
     * The data needed to create a MonthlySalary.
     */
    data: XOR<MonthlySalaryCreateInput, MonthlySalaryUncheckedCreateInput>
  }

  /**
   * MonthlySalary createMany
   */
  export type MonthlySalaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonthlySalaries.
     */
    data: MonthlySalaryCreateManyInput | MonthlySalaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonthlySalary createManyAndReturn
   */
  export type MonthlySalaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MonthlySalaries.
     */
    data: MonthlySalaryCreateManyInput | MonthlySalaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonthlySalary update
   */
  export type MonthlySalaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
    /**
     * The data needed to update a MonthlySalary.
     */
    data: XOR<MonthlySalaryUpdateInput, MonthlySalaryUncheckedUpdateInput>
    /**
     * Choose, which MonthlySalary to update.
     */
    where: MonthlySalaryWhereUniqueInput
  }

  /**
   * MonthlySalary updateMany
   */
  export type MonthlySalaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonthlySalaries.
     */
    data: XOR<MonthlySalaryUpdateManyMutationInput, MonthlySalaryUncheckedUpdateManyInput>
    /**
     * Filter which MonthlySalaries to update
     */
    where?: MonthlySalaryWhereInput
  }

  /**
   * MonthlySalary upsert
   */
  export type MonthlySalaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
    /**
     * The filter to search for the MonthlySalary to update in case it exists.
     */
    where: MonthlySalaryWhereUniqueInput
    /**
     * In case the MonthlySalary found by the `where` argument doesn't exist, create a new MonthlySalary with this data.
     */
    create: XOR<MonthlySalaryCreateInput, MonthlySalaryUncheckedCreateInput>
    /**
     * In case the MonthlySalary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonthlySalaryUpdateInput, MonthlySalaryUncheckedUpdateInput>
  }

  /**
   * MonthlySalary delete
   */
  export type MonthlySalaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
    /**
     * Filter which MonthlySalary to delete.
     */
    where: MonthlySalaryWhereUniqueInput
  }

  /**
   * MonthlySalary deleteMany
   */
  export type MonthlySalaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthlySalaries to delete
     */
    where?: MonthlySalaryWhereInput
  }

  /**
   * MonthlySalary.approver
   */
  export type MonthlySalary$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MonthlySalary.deductions
   */
  export type MonthlySalary$deductionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionInclude<ExtArgs> | null
    where?: SalaryDeductionWhereInput
    orderBy?: SalaryDeductionOrderByWithRelationInput | SalaryDeductionOrderByWithRelationInput[]
    cursor?: SalaryDeductionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryDeductionScalarFieldEnum | SalaryDeductionScalarFieldEnum[]
  }

  /**
   * MonthlySalary without action
   */
  export type MonthlySalaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlySalary
     */
    select?: MonthlySalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlySalaryInclude<ExtArgs> | null
  }


  /**
   * Model SalaryDeduction
   */

  export type AggregateSalaryDeduction = {
    _count: SalaryDeductionCountAggregateOutputType | null
    _avg: SalaryDeductionAvgAggregateOutputType | null
    _sum: SalaryDeductionSumAggregateOutputType | null
    _min: SalaryDeductionMinAggregateOutputType | null
    _max: SalaryDeductionMaxAggregateOutputType | null
  }

  export type SalaryDeductionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type SalaryDeductionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type SalaryDeductionMinAggregateOutputType = {
    id: string | null
    monthlySalaryId: string | null
    type: $Enums.DeductionType | null
    description: string | null
    amount: Decimal | null
    leaveRequestId: string | null
    isTaxable: boolean | null
    createdAt: Date | null
  }

  export type SalaryDeductionMaxAggregateOutputType = {
    id: string | null
    monthlySalaryId: string | null
    type: $Enums.DeductionType | null
    description: string | null
    amount: Decimal | null
    leaveRequestId: string | null
    isTaxable: boolean | null
    createdAt: Date | null
  }

  export type SalaryDeductionCountAggregateOutputType = {
    id: number
    monthlySalaryId: number
    type: number
    description: number
    amount: number
    leaveRequestId: number
    isTaxable: number
    createdAt: number
    _all: number
  }


  export type SalaryDeductionAvgAggregateInputType = {
    amount?: true
  }

  export type SalaryDeductionSumAggregateInputType = {
    amount?: true
  }

  export type SalaryDeductionMinAggregateInputType = {
    id?: true
    monthlySalaryId?: true
    type?: true
    description?: true
    amount?: true
    leaveRequestId?: true
    isTaxable?: true
    createdAt?: true
  }

  export type SalaryDeductionMaxAggregateInputType = {
    id?: true
    monthlySalaryId?: true
    type?: true
    description?: true
    amount?: true
    leaveRequestId?: true
    isTaxable?: true
    createdAt?: true
  }

  export type SalaryDeductionCountAggregateInputType = {
    id?: true
    monthlySalaryId?: true
    type?: true
    description?: true
    amount?: true
    leaveRequestId?: true
    isTaxable?: true
    createdAt?: true
    _all?: true
  }

  export type SalaryDeductionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryDeduction to aggregate.
     */
    where?: SalaryDeductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryDeductions to fetch.
     */
    orderBy?: SalaryDeductionOrderByWithRelationInput | SalaryDeductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryDeductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryDeductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryDeductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryDeductions
    **/
    _count?: true | SalaryDeductionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryDeductionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryDeductionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryDeductionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryDeductionMaxAggregateInputType
  }

  export type GetSalaryDeductionAggregateType<T extends SalaryDeductionAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryDeduction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryDeduction[P]>
      : GetScalarType<T[P], AggregateSalaryDeduction[P]>
  }




  export type SalaryDeductionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryDeductionWhereInput
    orderBy?: SalaryDeductionOrderByWithAggregationInput | SalaryDeductionOrderByWithAggregationInput[]
    by: SalaryDeductionScalarFieldEnum[] | SalaryDeductionScalarFieldEnum
    having?: SalaryDeductionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryDeductionCountAggregateInputType | true
    _avg?: SalaryDeductionAvgAggregateInputType
    _sum?: SalaryDeductionSumAggregateInputType
    _min?: SalaryDeductionMinAggregateInputType
    _max?: SalaryDeductionMaxAggregateInputType
  }

  export type SalaryDeductionGroupByOutputType = {
    id: string
    monthlySalaryId: string
    type: $Enums.DeductionType
    description: string
    amount: Decimal
    leaveRequestId: string | null
    isTaxable: boolean
    createdAt: Date
    _count: SalaryDeductionCountAggregateOutputType | null
    _avg: SalaryDeductionAvgAggregateOutputType | null
    _sum: SalaryDeductionSumAggregateOutputType | null
    _min: SalaryDeductionMinAggregateOutputType | null
    _max: SalaryDeductionMaxAggregateOutputType | null
  }

  type GetSalaryDeductionGroupByPayload<T extends SalaryDeductionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryDeductionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryDeductionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryDeductionGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryDeductionGroupByOutputType[P]>
        }
      >
    >


  export type SalaryDeductionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monthlySalaryId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    leaveRequestId?: boolean
    isTaxable?: boolean
    createdAt?: boolean
    monthlySalary?: boolean | MonthlySalaryDefaultArgs<ExtArgs>
    leaveRequest?: boolean | SalaryDeduction$leaveRequestArgs<ExtArgs>
  }, ExtArgs["result"]["salaryDeduction"]>

  export type SalaryDeductionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monthlySalaryId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    leaveRequestId?: boolean
    isTaxable?: boolean
    createdAt?: boolean
    monthlySalary?: boolean | MonthlySalaryDefaultArgs<ExtArgs>
    leaveRequest?: boolean | SalaryDeduction$leaveRequestArgs<ExtArgs>
  }, ExtArgs["result"]["salaryDeduction"]>

  export type SalaryDeductionSelectScalar = {
    id?: boolean
    monthlySalaryId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    leaveRequestId?: boolean
    isTaxable?: boolean
    createdAt?: boolean
  }

  export type SalaryDeductionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthlySalary?: boolean | MonthlySalaryDefaultArgs<ExtArgs>
    leaveRequest?: boolean | SalaryDeduction$leaveRequestArgs<ExtArgs>
  }
  export type SalaryDeductionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthlySalary?: boolean | MonthlySalaryDefaultArgs<ExtArgs>
    leaveRequest?: boolean | SalaryDeduction$leaveRequestArgs<ExtArgs>
  }

  export type $SalaryDeductionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryDeduction"
    objects: {
      monthlySalary: Prisma.$MonthlySalaryPayload<ExtArgs>
      leaveRequest: Prisma.$LeaveRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      monthlySalaryId: string
      type: $Enums.DeductionType
      description: string
      amount: Prisma.Decimal
      leaveRequestId: string | null
      isTaxable: boolean
      createdAt: Date
    }, ExtArgs["result"]["salaryDeduction"]>
    composites: {}
  }

  type SalaryDeductionGetPayload<S extends boolean | null | undefined | SalaryDeductionDefaultArgs> = $Result.GetResult<Prisma.$SalaryDeductionPayload, S>

  type SalaryDeductionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalaryDeductionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalaryDeductionCountAggregateInputType | true
    }

  export interface SalaryDeductionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryDeduction'], meta: { name: 'SalaryDeduction' } }
    /**
     * Find zero or one SalaryDeduction that matches the filter.
     * @param {SalaryDeductionFindUniqueArgs} args - Arguments to find a SalaryDeduction
     * @example
     * // Get one SalaryDeduction
     * const salaryDeduction = await prisma.salaryDeduction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryDeductionFindUniqueArgs>(args: SelectSubset<T, SalaryDeductionFindUniqueArgs<ExtArgs>>): Prisma__SalaryDeductionClient<$Result.GetResult<Prisma.$SalaryDeductionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalaryDeduction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalaryDeductionFindUniqueOrThrowArgs} args - Arguments to find a SalaryDeduction
     * @example
     * // Get one SalaryDeduction
     * const salaryDeduction = await prisma.salaryDeduction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryDeductionFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryDeductionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryDeductionClient<$Result.GetResult<Prisma.$SalaryDeductionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalaryDeduction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDeductionFindFirstArgs} args - Arguments to find a SalaryDeduction
     * @example
     * // Get one SalaryDeduction
     * const salaryDeduction = await prisma.salaryDeduction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryDeductionFindFirstArgs>(args?: SelectSubset<T, SalaryDeductionFindFirstArgs<ExtArgs>>): Prisma__SalaryDeductionClient<$Result.GetResult<Prisma.$SalaryDeductionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalaryDeduction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDeductionFindFirstOrThrowArgs} args - Arguments to find a SalaryDeduction
     * @example
     * // Get one SalaryDeduction
     * const salaryDeduction = await prisma.salaryDeduction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryDeductionFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryDeductionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryDeductionClient<$Result.GetResult<Prisma.$SalaryDeductionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalaryDeductions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDeductionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryDeductions
     * const salaryDeductions = await prisma.salaryDeduction.findMany()
     * 
     * // Get first 10 SalaryDeductions
     * const salaryDeductions = await prisma.salaryDeduction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryDeductionWithIdOnly = await prisma.salaryDeduction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryDeductionFindManyArgs>(args?: SelectSubset<T, SalaryDeductionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryDeductionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalaryDeduction.
     * @param {SalaryDeductionCreateArgs} args - Arguments to create a SalaryDeduction.
     * @example
     * // Create one SalaryDeduction
     * const SalaryDeduction = await prisma.salaryDeduction.create({
     *   data: {
     *     // ... data to create a SalaryDeduction
     *   }
     * })
     * 
     */
    create<T extends SalaryDeductionCreateArgs>(args: SelectSubset<T, SalaryDeductionCreateArgs<ExtArgs>>): Prisma__SalaryDeductionClient<$Result.GetResult<Prisma.$SalaryDeductionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalaryDeductions.
     * @param {SalaryDeductionCreateManyArgs} args - Arguments to create many SalaryDeductions.
     * @example
     * // Create many SalaryDeductions
     * const salaryDeduction = await prisma.salaryDeduction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryDeductionCreateManyArgs>(args?: SelectSubset<T, SalaryDeductionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryDeductions and returns the data saved in the database.
     * @param {SalaryDeductionCreateManyAndReturnArgs} args - Arguments to create many SalaryDeductions.
     * @example
     * // Create many SalaryDeductions
     * const salaryDeduction = await prisma.salaryDeduction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryDeductions and only return the `id`
     * const salaryDeductionWithIdOnly = await prisma.salaryDeduction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryDeductionCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryDeductionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryDeductionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalaryDeduction.
     * @param {SalaryDeductionDeleteArgs} args - Arguments to delete one SalaryDeduction.
     * @example
     * // Delete one SalaryDeduction
     * const SalaryDeduction = await prisma.salaryDeduction.delete({
     *   where: {
     *     // ... filter to delete one SalaryDeduction
     *   }
     * })
     * 
     */
    delete<T extends SalaryDeductionDeleteArgs>(args: SelectSubset<T, SalaryDeductionDeleteArgs<ExtArgs>>): Prisma__SalaryDeductionClient<$Result.GetResult<Prisma.$SalaryDeductionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalaryDeduction.
     * @param {SalaryDeductionUpdateArgs} args - Arguments to update one SalaryDeduction.
     * @example
     * // Update one SalaryDeduction
     * const salaryDeduction = await prisma.salaryDeduction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryDeductionUpdateArgs>(args: SelectSubset<T, SalaryDeductionUpdateArgs<ExtArgs>>): Prisma__SalaryDeductionClient<$Result.GetResult<Prisma.$SalaryDeductionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalaryDeductions.
     * @param {SalaryDeductionDeleteManyArgs} args - Arguments to filter SalaryDeductions to delete.
     * @example
     * // Delete a few SalaryDeductions
     * const { count } = await prisma.salaryDeduction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryDeductionDeleteManyArgs>(args?: SelectSubset<T, SalaryDeductionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryDeductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDeductionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryDeductions
     * const salaryDeduction = await prisma.salaryDeduction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryDeductionUpdateManyArgs>(args: SelectSubset<T, SalaryDeductionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalaryDeduction.
     * @param {SalaryDeductionUpsertArgs} args - Arguments to update or create a SalaryDeduction.
     * @example
     * // Update or create a SalaryDeduction
     * const salaryDeduction = await prisma.salaryDeduction.upsert({
     *   create: {
     *     // ... data to create a SalaryDeduction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryDeduction we want to update
     *   }
     * })
     */
    upsert<T extends SalaryDeductionUpsertArgs>(args: SelectSubset<T, SalaryDeductionUpsertArgs<ExtArgs>>): Prisma__SalaryDeductionClient<$Result.GetResult<Prisma.$SalaryDeductionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalaryDeductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDeductionCountArgs} args - Arguments to filter SalaryDeductions to count.
     * @example
     * // Count the number of SalaryDeductions
     * const count = await prisma.salaryDeduction.count({
     *   where: {
     *     // ... the filter for the SalaryDeductions we want to count
     *   }
     * })
    **/
    count<T extends SalaryDeductionCountArgs>(
      args?: Subset<T, SalaryDeductionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryDeductionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryDeduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDeductionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryDeductionAggregateArgs>(args: Subset<T, SalaryDeductionAggregateArgs>): Prisma.PrismaPromise<GetSalaryDeductionAggregateType<T>>

    /**
     * Group by SalaryDeduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryDeductionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryDeductionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryDeductionGroupByArgs['orderBy'] }
        : { orderBy?: SalaryDeductionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryDeductionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryDeductionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryDeduction model
   */
  readonly fields: SalaryDeductionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryDeduction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryDeductionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monthlySalary<T extends MonthlySalaryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MonthlySalaryDefaultArgs<ExtArgs>>): Prisma__MonthlySalaryClient<$Result.GetResult<Prisma.$MonthlySalaryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    leaveRequest<T extends SalaryDeduction$leaveRequestArgs<ExtArgs> = {}>(args?: Subset<T, SalaryDeduction$leaveRequestArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryDeduction model
   */ 
  interface SalaryDeductionFieldRefs {
    readonly id: FieldRef<"SalaryDeduction", 'String'>
    readonly monthlySalaryId: FieldRef<"SalaryDeduction", 'String'>
    readonly type: FieldRef<"SalaryDeduction", 'DeductionType'>
    readonly description: FieldRef<"SalaryDeduction", 'String'>
    readonly amount: FieldRef<"SalaryDeduction", 'Decimal'>
    readonly leaveRequestId: FieldRef<"SalaryDeduction", 'String'>
    readonly isTaxable: FieldRef<"SalaryDeduction", 'Boolean'>
    readonly createdAt: FieldRef<"SalaryDeduction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalaryDeduction findUnique
   */
  export type SalaryDeductionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionInclude<ExtArgs> | null
    /**
     * Filter, which SalaryDeduction to fetch.
     */
    where: SalaryDeductionWhereUniqueInput
  }

  /**
   * SalaryDeduction findUniqueOrThrow
   */
  export type SalaryDeductionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionInclude<ExtArgs> | null
    /**
     * Filter, which SalaryDeduction to fetch.
     */
    where: SalaryDeductionWhereUniqueInput
  }

  /**
   * SalaryDeduction findFirst
   */
  export type SalaryDeductionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionInclude<ExtArgs> | null
    /**
     * Filter, which SalaryDeduction to fetch.
     */
    where?: SalaryDeductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryDeductions to fetch.
     */
    orderBy?: SalaryDeductionOrderByWithRelationInput | SalaryDeductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryDeductions.
     */
    cursor?: SalaryDeductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryDeductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryDeductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryDeductions.
     */
    distinct?: SalaryDeductionScalarFieldEnum | SalaryDeductionScalarFieldEnum[]
  }

  /**
   * SalaryDeduction findFirstOrThrow
   */
  export type SalaryDeductionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionInclude<ExtArgs> | null
    /**
     * Filter, which SalaryDeduction to fetch.
     */
    where?: SalaryDeductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryDeductions to fetch.
     */
    orderBy?: SalaryDeductionOrderByWithRelationInput | SalaryDeductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryDeductions.
     */
    cursor?: SalaryDeductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryDeductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryDeductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryDeductions.
     */
    distinct?: SalaryDeductionScalarFieldEnum | SalaryDeductionScalarFieldEnum[]
  }

  /**
   * SalaryDeduction findMany
   */
  export type SalaryDeductionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionInclude<ExtArgs> | null
    /**
     * Filter, which SalaryDeductions to fetch.
     */
    where?: SalaryDeductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryDeductions to fetch.
     */
    orderBy?: SalaryDeductionOrderByWithRelationInput | SalaryDeductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryDeductions.
     */
    cursor?: SalaryDeductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryDeductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryDeductions.
     */
    skip?: number
    distinct?: SalaryDeductionScalarFieldEnum | SalaryDeductionScalarFieldEnum[]
  }

  /**
   * SalaryDeduction create
   */
  export type SalaryDeductionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryDeduction.
     */
    data: XOR<SalaryDeductionCreateInput, SalaryDeductionUncheckedCreateInput>
  }

  /**
   * SalaryDeduction createMany
   */
  export type SalaryDeductionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryDeductions.
     */
    data: SalaryDeductionCreateManyInput | SalaryDeductionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryDeduction createManyAndReturn
   */
  export type SalaryDeductionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalaryDeductions.
     */
    data: SalaryDeductionCreateManyInput | SalaryDeductionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryDeduction update
   */
  export type SalaryDeductionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryDeduction.
     */
    data: XOR<SalaryDeductionUpdateInput, SalaryDeductionUncheckedUpdateInput>
    /**
     * Choose, which SalaryDeduction to update.
     */
    where: SalaryDeductionWhereUniqueInput
  }

  /**
   * SalaryDeduction updateMany
   */
  export type SalaryDeductionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryDeductions.
     */
    data: XOR<SalaryDeductionUpdateManyMutationInput, SalaryDeductionUncheckedUpdateManyInput>
    /**
     * Filter which SalaryDeductions to update
     */
    where?: SalaryDeductionWhereInput
  }

  /**
   * SalaryDeduction upsert
   */
  export type SalaryDeductionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryDeduction to update in case it exists.
     */
    where: SalaryDeductionWhereUniqueInput
    /**
     * In case the SalaryDeduction found by the `where` argument doesn't exist, create a new SalaryDeduction with this data.
     */
    create: XOR<SalaryDeductionCreateInput, SalaryDeductionUncheckedCreateInput>
    /**
     * In case the SalaryDeduction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryDeductionUpdateInput, SalaryDeductionUncheckedUpdateInput>
  }

  /**
   * SalaryDeduction delete
   */
  export type SalaryDeductionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionInclude<ExtArgs> | null
    /**
     * Filter which SalaryDeduction to delete.
     */
    where: SalaryDeductionWhereUniqueInput
  }

  /**
   * SalaryDeduction deleteMany
   */
  export type SalaryDeductionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryDeductions to delete
     */
    where?: SalaryDeductionWhereInput
  }

  /**
   * SalaryDeduction.leaveRequest
   */
  export type SalaryDeduction$leaveRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
  }

  /**
   * SalaryDeduction without action
   */
  export type SalaryDeductionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryDeduction
     */
    select?: SalaryDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryDeductionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    department: 'department',
    managerId: 'managerId',
    profilePicture: 'profilePicture',
    phone: 'phone',
    bio: 'bio',
    address: 'address',
    emergencyContact: 'emergencyContact',
    emergencyPhone: 'emergencyPhone',
    isActive: 'isActive',
    lastLogin: 'lastLogin',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LeaveRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    leaveType: 'leaveType',
    startDate: 'startDate',
    endDate: 'endDate',
    totalDays: 'totalDays',
    reason: 'reason',
    status: 'status',
    submittedAt: 'submittedAt',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectedReason: 'rejectedReason',
    isHalfDay: 'isHalfDay',
    halfDayPeriod: 'halfDayPeriod',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


  export const LeaveBalanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    year: 'year',
    annualTotal: 'annualTotal',
    annualUsed: 'annualUsed',
    annualRemaining: 'annualRemaining',
    sickTotal: 'sickTotal',
    sickUsed: 'sickUsed',
    sickRemaining: 'sickRemaining',
    casualTotal: 'casualTotal',
    casualUsed: 'casualUsed',
    casualRemaining: 'casualRemaining',
    maternityTotal: 'maternityTotal',
    maternityUsed: 'maternityUsed',
    maternityRemaining: 'maternityRemaining',
    paternityTotal: 'paternityTotal',
    paternityUsed: 'paternityUsed',
    paternityRemaining: 'paternityRemaining',
    emergencyTotal: 'emergencyTotal',
    emergencyUsed: 'emergencyUsed',
    emergencyRemaining: 'emergencyRemaining',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveBalanceScalarFieldEnum = (typeof LeaveBalanceScalarFieldEnum)[keyof typeof LeaveBalanceScalarFieldEnum]


  export const LeavePolicyScalarFieldEnum: {
    id: 'id',
    leaveType: 'leaveType',
    totalDaysPerYear: 'totalDaysPerYear',
    canCarryForward: 'canCarryForward',
    maxCarryForwardDays: 'maxCarryForwardDays',
    requiresApproval: 'requiresApproval',
    allowHalfDay: 'allowHalfDay',
    description: 'description',
    isActive: 'isActive',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeavePolicyScalarFieldEnum = (typeof LeavePolicyScalarFieldEnum)[keyof typeof LeavePolicyScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    action: 'action',
    targetId: 'targetId',
    targetType: 'targetType',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const LeaveDocumentScalarFieldEnum: {
    id: 'id',
    leaveRequestId: 'leaveRequestId',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    uploadedAt: 'uploadedAt'
  };

  export type LeaveDocumentScalarFieldEnum = (typeof LeaveDocumentScalarFieldEnum)[keyof typeof LeaveDocumentScalarFieldEnum]


  export const HolidayScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    date: 'date',
    type: 'type',
    isRecurring: 'isRecurring',
    isActive: 'isActive',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HolidayScalarFieldEnum = (typeof HolidayScalarFieldEnum)[keyof typeof HolidayScalarFieldEnum]


  export const AttendanceRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    status: 'status',
    hoursWorked: 'hoursWorked',
    overtimeHours: 'overtimeHours',
    notes: 'notes',
    isHoliday: 'isHoliday',
    isWeekend: 'isWeekend',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceRecordScalarFieldEnum = (typeof AttendanceRecordScalarFieldEnum)[keyof typeof AttendanceRecordScalarFieldEnum]


  export const AttendancePolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    workingHoursPerDay: 'workingHoursPerDay',
    lateThresholdMinutes: 'lateThresholdMinutes',
    overtimeThresholdHours: 'overtimeThresholdHours',
    allowFlexibleHours: 'allowFlexibleHours',
    requireCheckIn: 'requireCheckIn',
    requireCheckOut: 'requireCheckOut',
    isActive: 'isActive',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendancePolicyScalarFieldEnum = (typeof AttendancePolicyScalarFieldEnum)[keyof typeof AttendancePolicyScalarFieldEnum]


  export const EmployeeSalaryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    baseSalary: 'baseSalary',
    hourlyRate: 'hourlyRate',
    currency: 'currency',
    effectiveDate: 'effectiveDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeSalaryScalarFieldEnum = (typeof EmployeeSalaryScalarFieldEnum)[keyof typeof EmployeeSalaryScalarFieldEnum]


  export const MonthlySalaryScalarFieldEnum: {
    id: 'id',
    employeeSalaryId: 'employeeSalaryId',
    userId: 'userId',
    year: 'year',
    month: 'month',
    baseSalary: 'baseSalary',
    grossSalary: 'grossSalary',
    totalDeductions: 'totalDeductions',
    netSalary: 'netSalary',
    status: 'status',
    calculatedAt: 'calculatedAt',
    approvedAt: 'approvedAt',
    paidAt: 'paidAt',
    approvedBy: 'approvedBy',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MonthlySalaryScalarFieldEnum = (typeof MonthlySalaryScalarFieldEnum)[keyof typeof MonthlySalaryScalarFieldEnum]


  export const SalaryDeductionScalarFieldEnum: {
    id: 'id',
    monthlySalaryId: 'monthlySalaryId',
    type: 'type',
    description: 'description',
    amount: 'amount',
    leaveRequestId: 'leaveRequestId',
    isTaxable: 'isTaxable',
    createdAt: 'createdAt'
  };

  export type SalaryDeductionScalarFieldEnum = (typeof SalaryDeductionScalarFieldEnum)[keyof typeof SalaryDeductionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'LeaveType'
   */
  export type EnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType'>
    


  /**
   * Reference to a field of type 'LeaveType[]'
   */
  export type ListEnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'LeaveStatus'
   */
  export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


  /**
   * Reference to a field of type 'LeaveStatus[]'
   */
  export type ListEnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus[]'>
    


  /**
   * Reference to a field of type 'HalfDayPeriod'
   */
  export type EnumHalfDayPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HalfDayPeriod'>
    


  /**
   * Reference to a field of type 'HalfDayPeriod[]'
   */
  export type ListEnumHalfDayPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HalfDayPeriod[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'HolidayType'
   */
  export type EnumHolidayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HolidayType'>
    


  /**
   * Reference to a field of type 'HolidayType[]'
   */
  export type ListEnumHolidayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HolidayType[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'SalaryStatus'
   */
  export type EnumSalaryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalaryStatus'>
    


  /**
   * Reference to a field of type 'SalaryStatus[]'
   */
  export type ListEnumSalaryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalaryStatus[]'>
    


  /**
   * Reference to a field of type 'DeductionType'
   */
  export type EnumDeductionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeductionType'>
    


  /**
   * Reference to a field of type 'DeductionType[]'
   */
  export type ListEnumDeductionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeductionType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    department?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    emergencyContact?: StringNullableFilter<"User"> | string | null
    emergencyPhone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    subordinates?: UserListRelationFilter
    leaveRequests?: LeaveRequestListRelationFilter
    approvedLeaves?: LeaveRequestListRelationFilter
    leaveBalances?: LeaveBalanceListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    createdPolicies?: LeavePolicyListRelationFilter
    createdHolidays?: HolidayListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    createdAttendancePolicies?: AttendancePolicyListRelationFilter
    employeeSalary?: EmployeeSalaryListRelationFilter
    monthlySalaries?: MonthlySalaryListRelationFilter
    approvedSalaries?: MonthlySalaryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    manager?: UserOrderByWithRelationInput
    subordinates?: UserOrderByRelationAggregateInput
    leaveRequests?: LeaveRequestOrderByRelationAggregateInput
    approvedLeaves?: LeaveRequestOrderByRelationAggregateInput
    leaveBalances?: LeaveBalanceOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    createdPolicies?: LeavePolicyOrderByRelationAggregateInput
    createdHolidays?: HolidayOrderByRelationAggregateInput
    attendanceRecords?: AttendanceRecordOrderByRelationAggregateInput
    createdAttendancePolicies?: AttendancePolicyOrderByRelationAggregateInput
    employeeSalary?: EmployeeSalaryOrderByRelationAggregateInput
    monthlySalaries?: MonthlySalaryOrderByRelationAggregateInput
    approvedSalaries?: MonthlySalaryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    department?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    emergencyContact?: StringNullableFilter<"User"> | string | null
    emergencyPhone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    subordinates?: UserListRelationFilter
    leaveRequests?: LeaveRequestListRelationFilter
    approvedLeaves?: LeaveRequestListRelationFilter
    leaveBalances?: LeaveBalanceListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    createdPolicies?: LeavePolicyListRelationFilter
    createdHolidays?: HolidayListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    createdAttendancePolicies?: AttendancePolicyListRelationFilter
    employeeSalary?: EmployeeSalaryListRelationFilter
    monthlySalaries?: MonthlySalaryListRelationFilter
    approvedSalaries?: MonthlySalaryListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"User"> | string | null
    emergencyPhone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type LeaveRequestWhereInput = {
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    userId?: StringFilter<"LeaveRequest"> | string
    leaveType?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    totalDays?: DecimalFilter<"LeaveRequest"> | Decimal | DecimalJsLike | number | string
    reason?: StringFilter<"LeaveRequest"> | string
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    submittedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    approvedBy?: StringNullableFilter<"LeaveRequest"> | string | null
    approvedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    rejectedReason?: StringNullableFilter<"LeaveRequest"> | string | null
    isHalfDay?: BoolFilter<"LeaveRequest"> | boolean
    halfDayPeriod?: EnumHalfDayPeriodNullableFilter<"LeaveRequest"> | $Enums.HalfDayPeriod | null
    comments?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    documents?: LeaveDocumentListRelationFilter
    salaryDeductions?: SalaryDeductionListRelationFilter
  }

  export type LeaveRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedReason?: SortOrderInput | SortOrder
    isHalfDay?: SortOrder
    halfDayPeriod?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    documents?: LeaveDocumentOrderByRelationAggregateInput
    salaryDeductions?: SalaryDeductionOrderByRelationAggregateInput
  }

  export type LeaveRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    userId?: StringFilter<"LeaveRequest"> | string
    leaveType?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    totalDays?: DecimalFilter<"LeaveRequest"> | Decimal | DecimalJsLike | number | string
    reason?: StringFilter<"LeaveRequest"> | string
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    submittedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    approvedBy?: StringNullableFilter<"LeaveRequest"> | string | null
    approvedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    rejectedReason?: StringNullableFilter<"LeaveRequest"> | string | null
    isHalfDay?: BoolFilter<"LeaveRequest"> | boolean
    halfDayPeriod?: EnumHalfDayPeriodNullableFilter<"LeaveRequest"> | $Enums.HalfDayPeriod | null
    comments?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    documents?: LeaveDocumentListRelationFilter
    salaryDeductions?: SalaryDeductionListRelationFilter
  }, "id">

  export type LeaveRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedReason?: SortOrderInput | SortOrder
    isHalfDay?: SortOrder
    halfDayPeriod?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveRequestCountOrderByAggregateInput
    _avg?: LeaveRequestAvgOrderByAggregateInput
    _max?: LeaveRequestMaxOrderByAggregateInput
    _min?: LeaveRequestMinOrderByAggregateInput
    _sum?: LeaveRequestSumOrderByAggregateInput
  }

  export type LeaveRequestScalarWhereWithAggregatesInput = {
    AND?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    OR?: LeaveRequestScalarWhereWithAggregatesInput[]
    NOT?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveRequest"> | string
    userId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    leaveType?: EnumLeaveTypeWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    totalDays?: DecimalWithAggregatesFilter<"LeaveRequest"> | Decimal | DecimalJsLike | number | string
    reason?: StringWithAggregatesFilter<"LeaveRequest"> | string
    status?: EnumLeaveStatusWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveStatus
    submittedAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    approvedBy?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"LeaveRequest"> | Date | string | null
    rejectedReason?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    isHalfDay?: BoolWithAggregatesFilter<"LeaveRequest"> | boolean
    halfDayPeriod?: EnumHalfDayPeriodNullableWithAggregatesFilter<"LeaveRequest"> | $Enums.HalfDayPeriod | null
    comments?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
  }

  export type LeaveBalanceWhereInput = {
    AND?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    OR?: LeaveBalanceWhereInput[]
    NOT?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    id?: StringFilter<"LeaveBalance"> | string
    userId?: StringFilter<"LeaveBalance"> | string
    year?: IntFilter<"LeaveBalance"> | number
    annualTotal?: IntFilter<"LeaveBalance"> | number
    annualUsed?: IntFilter<"LeaveBalance"> | number
    annualRemaining?: IntFilter<"LeaveBalance"> | number
    sickTotal?: IntFilter<"LeaveBalance"> | number
    sickUsed?: IntFilter<"LeaveBalance"> | number
    sickRemaining?: IntFilter<"LeaveBalance"> | number
    casualTotal?: IntFilter<"LeaveBalance"> | number
    casualUsed?: IntFilter<"LeaveBalance"> | number
    casualRemaining?: IntFilter<"LeaveBalance"> | number
    maternityTotal?: IntFilter<"LeaveBalance"> | number
    maternityUsed?: IntFilter<"LeaveBalance"> | number
    maternityRemaining?: IntFilter<"LeaveBalance"> | number
    paternityTotal?: IntFilter<"LeaveBalance"> | number
    paternityUsed?: IntFilter<"LeaveBalance"> | number
    paternityRemaining?: IntFilter<"LeaveBalance"> | number
    emergencyTotal?: IntFilter<"LeaveBalance"> | number
    emergencyUsed?: IntFilter<"LeaveBalance"> | number
    emergencyRemaining?: IntFilter<"LeaveBalance"> | number
    createdAt?: DateTimeFilter<"LeaveBalance"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveBalance"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LeaveBalanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    annualTotal?: SortOrder
    annualUsed?: SortOrder
    annualRemaining?: SortOrder
    sickTotal?: SortOrder
    sickUsed?: SortOrder
    sickRemaining?: SortOrder
    casualTotal?: SortOrder
    casualUsed?: SortOrder
    casualRemaining?: SortOrder
    maternityTotal?: SortOrder
    maternityUsed?: SortOrder
    maternityRemaining?: SortOrder
    paternityTotal?: SortOrder
    paternityUsed?: SortOrder
    paternityRemaining?: SortOrder
    emergencyTotal?: SortOrder
    emergencyUsed?: SortOrder
    emergencyRemaining?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LeaveBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_year?: LeaveBalanceUserIdYearCompoundUniqueInput
    AND?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    OR?: LeaveBalanceWhereInput[]
    NOT?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    userId?: StringFilter<"LeaveBalance"> | string
    year?: IntFilter<"LeaveBalance"> | number
    annualTotal?: IntFilter<"LeaveBalance"> | number
    annualUsed?: IntFilter<"LeaveBalance"> | number
    annualRemaining?: IntFilter<"LeaveBalance"> | number
    sickTotal?: IntFilter<"LeaveBalance"> | number
    sickUsed?: IntFilter<"LeaveBalance"> | number
    sickRemaining?: IntFilter<"LeaveBalance"> | number
    casualTotal?: IntFilter<"LeaveBalance"> | number
    casualUsed?: IntFilter<"LeaveBalance"> | number
    casualRemaining?: IntFilter<"LeaveBalance"> | number
    maternityTotal?: IntFilter<"LeaveBalance"> | number
    maternityUsed?: IntFilter<"LeaveBalance"> | number
    maternityRemaining?: IntFilter<"LeaveBalance"> | number
    paternityTotal?: IntFilter<"LeaveBalance"> | number
    paternityUsed?: IntFilter<"LeaveBalance"> | number
    paternityRemaining?: IntFilter<"LeaveBalance"> | number
    emergencyTotal?: IntFilter<"LeaveBalance"> | number
    emergencyUsed?: IntFilter<"LeaveBalance"> | number
    emergencyRemaining?: IntFilter<"LeaveBalance"> | number
    createdAt?: DateTimeFilter<"LeaveBalance"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveBalance"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_year">

  export type LeaveBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    annualTotal?: SortOrder
    annualUsed?: SortOrder
    annualRemaining?: SortOrder
    sickTotal?: SortOrder
    sickUsed?: SortOrder
    sickRemaining?: SortOrder
    casualTotal?: SortOrder
    casualUsed?: SortOrder
    casualRemaining?: SortOrder
    maternityTotal?: SortOrder
    maternityUsed?: SortOrder
    maternityRemaining?: SortOrder
    paternityTotal?: SortOrder
    paternityUsed?: SortOrder
    paternityRemaining?: SortOrder
    emergencyTotal?: SortOrder
    emergencyUsed?: SortOrder
    emergencyRemaining?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveBalanceCountOrderByAggregateInput
    _avg?: LeaveBalanceAvgOrderByAggregateInput
    _max?: LeaveBalanceMaxOrderByAggregateInput
    _min?: LeaveBalanceMinOrderByAggregateInput
    _sum?: LeaveBalanceSumOrderByAggregateInput
  }

  export type LeaveBalanceScalarWhereWithAggregatesInput = {
    AND?: LeaveBalanceScalarWhereWithAggregatesInput | LeaveBalanceScalarWhereWithAggregatesInput[]
    OR?: LeaveBalanceScalarWhereWithAggregatesInput[]
    NOT?: LeaveBalanceScalarWhereWithAggregatesInput | LeaveBalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveBalance"> | string
    userId?: StringWithAggregatesFilter<"LeaveBalance"> | string
    year?: IntWithAggregatesFilter<"LeaveBalance"> | number
    annualTotal?: IntWithAggregatesFilter<"LeaveBalance"> | number
    annualUsed?: IntWithAggregatesFilter<"LeaveBalance"> | number
    annualRemaining?: IntWithAggregatesFilter<"LeaveBalance"> | number
    sickTotal?: IntWithAggregatesFilter<"LeaveBalance"> | number
    sickUsed?: IntWithAggregatesFilter<"LeaveBalance"> | number
    sickRemaining?: IntWithAggregatesFilter<"LeaveBalance"> | number
    casualTotal?: IntWithAggregatesFilter<"LeaveBalance"> | number
    casualUsed?: IntWithAggregatesFilter<"LeaveBalance"> | number
    casualRemaining?: IntWithAggregatesFilter<"LeaveBalance"> | number
    maternityTotal?: IntWithAggregatesFilter<"LeaveBalance"> | number
    maternityUsed?: IntWithAggregatesFilter<"LeaveBalance"> | number
    maternityRemaining?: IntWithAggregatesFilter<"LeaveBalance"> | number
    paternityTotal?: IntWithAggregatesFilter<"LeaveBalance"> | number
    paternityUsed?: IntWithAggregatesFilter<"LeaveBalance"> | number
    paternityRemaining?: IntWithAggregatesFilter<"LeaveBalance"> | number
    emergencyTotal?: IntWithAggregatesFilter<"LeaveBalance"> | number
    emergencyUsed?: IntWithAggregatesFilter<"LeaveBalance"> | number
    emergencyRemaining?: IntWithAggregatesFilter<"LeaveBalance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LeaveBalance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveBalance"> | Date | string
  }

  export type LeavePolicyWhereInput = {
    AND?: LeavePolicyWhereInput | LeavePolicyWhereInput[]
    OR?: LeavePolicyWhereInput[]
    NOT?: LeavePolicyWhereInput | LeavePolicyWhereInput[]
    id?: StringFilter<"LeavePolicy"> | string
    leaveType?: StringFilter<"LeavePolicy"> | string
    totalDaysPerYear?: IntFilter<"LeavePolicy"> | number
    canCarryForward?: BoolFilter<"LeavePolicy"> | boolean
    maxCarryForwardDays?: IntNullableFilter<"LeavePolicy"> | number | null
    requiresApproval?: BoolFilter<"LeavePolicy"> | boolean
    allowHalfDay?: BoolFilter<"LeavePolicy"> | boolean
    description?: StringNullableFilter<"LeavePolicy"> | string | null
    isActive?: BoolFilter<"LeavePolicy"> | boolean
    createdBy?: StringFilter<"LeavePolicy"> | string
    createdAt?: DateTimeFilter<"LeavePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"LeavePolicy"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LeavePolicyOrderByWithRelationInput = {
    id?: SortOrder
    leaveType?: SortOrder
    totalDaysPerYear?: SortOrder
    canCarryForward?: SortOrder
    maxCarryForwardDays?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    allowHalfDay?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type LeavePolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    leaveType?: string
    AND?: LeavePolicyWhereInput | LeavePolicyWhereInput[]
    OR?: LeavePolicyWhereInput[]
    NOT?: LeavePolicyWhereInput | LeavePolicyWhereInput[]
    totalDaysPerYear?: IntFilter<"LeavePolicy"> | number
    canCarryForward?: BoolFilter<"LeavePolicy"> | boolean
    maxCarryForwardDays?: IntNullableFilter<"LeavePolicy"> | number | null
    requiresApproval?: BoolFilter<"LeavePolicy"> | boolean
    allowHalfDay?: BoolFilter<"LeavePolicy"> | boolean
    description?: StringNullableFilter<"LeavePolicy"> | string | null
    isActive?: BoolFilter<"LeavePolicy"> | boolean
    createdBy?: StringFilter<"LeavePolicy"> | string
    createdAt?: DateTimeFilter<"LeavePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"LeavePolicy"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "leaveType">

  export type LeavePolicyOrderByWithAggregationInput = {
    id?: SortOrder
    leaveType?: SortOrder
    totalDaysPerYear?: SortOrder
    canCarryForward?: SortOrder
    maxCarryForwardDays?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    allowHalfDay?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeavePolicyCountOrderByAggregateInput
    _avg?: LeavePolicyAvgOrderByAggregateInput
    _max?: LeavePolicyMaxOrderByAggregateInput
    _min?: LeavePolicyMinOrderByAggregateInput
    _sum?: LeavePolicySumOrderByAggregateInput
  }

  export type LeavePolicyScalarWhereWithAggregatesInput = {
    AND?: LeavePolicyScalarWhereWithAggregatesInput | LeavePolicyScalarWhereWithAggregatesInput[]
    OR?: LeavePolicyScalarWhereWithAggregatesInput[]
    NOT?: LeavePolicyScalarWhereWithAggregatesInput | LeavePolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeavePolicy"> | string
    leaveType?: StringWithAggregatesFilter<"LeavePolicy"> | string
    totalDaysPerYear?: IntWithAggregatesFilter<"LeavePolicy"> | number
    canCarryForward?: BoolWithAggregatesFilter<"LeavePolicy"> | boolean
    maxCarryForwardDays?: IntNullableWithAggregatesFilter<"LeavePolicy"> | number | null
    requiresApproval?: BoolWithAggregatesFilter<"LeavePolicy"> | boolean
    allowHalfDay?: BoolWithAggregatesFilter<"LeavePolicy"> | boolean
    description?: StringNullableWithAggregatesFilter<"LeavePolicy"> | string | null
    isActive?: BoolWithAggregatesFilter<"LeavePolicy"> | boolean
    createdBy?: StringWithAggregatesFilter<"LeavePolicy"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LeavePolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeavePolicy"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    userName?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    targetId?: StringNullableFilter<"AuditLog"> | string | null
    targetType?: StringNullableFilter<"AuditLog"> | string | null
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    targetId?: SortOrderInput | SortOrder
    targetType?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    userName?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    targetId?: StringNullableFilter<"AuditLog"> | string | null
    targetType?: StringNullableFilter<"AuditLog"> | string | null
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    targetId?: SortOrderInput | SortOrder
    targetType?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    userName?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    targetId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    targetType?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type LeaveDocumentWhereInput = {
    AND?: LeaveDocumentWhereInput | LeaveDocumentWhereInput[]
    OR?: LeaveDocumentWhereInput[]
    NOT?: LeaveDocumentWhereInput | LeaveDocumentWhereInput[]
    id?: StringFilter<"LeaveDocument"> | string
    leaveRequestId?: StringFilter<"LeaveDocument"> | string
    fileName?: StringFilter<"LeaveDocument"> | string
    filePath?: StringFilter<"LeaveDocument"> | string
    fileSize?: IntFilter<"LeaveDocument"> | number
    mimeType?: StringFilter<"LeaveDocument"> | string
    uploadedAt?: DateTimeFilter<"LeaveDocument"> | Date | string
    leaveRequest?: XOR<LeaveRequestRelationFilter, LeaveRequestWhereInput>
  }

  export type LeaveDocumentOrderByWithRelationInput = {
    id?: SortOrder
    leaveRequestId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
    leaveRequest?: LeaveRequestOrderByWithRelationInput
  }

  export type LeaveDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveDocumentWhereInput | LeaveDocumentWhereInput[]
    OR?: LeaveDocumentWhereInput[]
    NOT?: LeaveDocumentWhereInput | LeaveDocumentWhereInput[]
    leaveRequestId?: StringFilter<"LeaveDocument"> | string
    fileName?: StringFilter<"LeaveDocument"> | string
    filePath?: StringFilter<"LeaveDocument"> | string
    fileSize?: IntFilter<"LeaveDocument"> | number
    mimeType?: StringFilter<"LeaveDocument"> | string
    uploadedAt?: DateTimeFilter<"LeaveDocument"> | Date | string
    leaveRequest?: XOR<LeaveRequestRelationFilter, LeaveRequestWhereInput>
  }, "id">

  export type LeaveDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    leaveRequestId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
    _count?: LeaveDocumentCountOrderByAggregateInput
    _avg?: LeaveDocumentAvgOrderByAggregateInput
    _max?: LeaveDocumentMaxOrderByAggregateInput
    _min?: LeaveDocumentMinOrderByAggregateInput
    _sum?: LeaveDocumentSumOrderByAggregateInput
  }

  export type LeaveDocumentScalarWhereWithAggregatesInput = {
    AND?: LeaveDocumentScalarWhereWithAggregatesInput | LeaveDocumentScalarWhereWithAggregatesInput[]
    OR?: LeaveDocumentScalarWhereWithAggregatesInput[]
    NOT?: LeaveDocumentScalarWhereWithAggregatesInput | LeaveDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveDocument"> | string
    leaveRequestId?: StringWithAggregatesFilter<"LeaveDocument"> | string
    fileName?: StringWithAggregatesFilter<"LeaveDocument"> | string
    filePath?: StringWithAggregatesFilter<"LeaveDocument"> | string
    fileSize?: IntWithAggregatesFilter<"LeaveDocument"> | number
    mimeType?: StringWithAggregatesFilter<"LeaveDocument"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"LeaveDocument"> | Date | string
  }

  export type HolidayWhereInput = {
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    id?: StringFilter<"Holiday"> | string
    name?: StringFilter<"Holiday"> | string
    description?: StringNullableFilter<"Holiday"> | string | null
    date?: DateTimeFilter<"Holiday"> | Date | string
    type?: EnumHolidayTypeFilter<"Holiday"> | $Enums.HolidayType
    isRecurring?: BoolFilter<"Holiday"> | boolean
    isActive?: BoolFilter<"Holiday"> | boolean
    createdBy?: StringFilter<"Holiday"> | string
    createdAt?: DateTimeFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeFilter<"Holiday"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type HolidayOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    type?: SortOrder
    isRecurring?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type HolidayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_date?: HolidayName_dateCompoundUniqueInput
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    name?: StringFilter<"Holiday"> | string
    description?: StringNullableFilter<"Holiday"> | string | null
    date?: DateTimeFilter<"Holiday"> | Date | string
    type?: EnumHolidayTypeFilter<"Holiday"> | $Enums.HolidayType
    isRecurring?: BoolFilter<"Holiday"> | boolean
    isActive?: BoolFilter<"Holiday"> | boolean
    createdBy?: StringFilter<"Holiday"> | string
    createdAt?: DateTimeFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeFilter<"Holiday"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "name_date">

  export type HolidayOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    type?: SortOrder
    isRecurring?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HolidayCountOrderByAggregateInput
    _max?: HolidayMaxOrderByAggregateInput
    _min?: HolidayMinOrderByAggregateInput
  }

  export type HolidayScalarWhereWithAggregatesInput = {
    AND?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    OR?: HolidayScalarWhereWithAggregatesInput[]
    NOT?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Holiday"> | string
    name?: StringWithAggregatesFilter<"Holiday"> | string
    description?: StringNullableWithAggregatesFilter<"Holiday"> | string | null
    date?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
    type?: EnumHolidayTypeWithAggregatesFilter<"Holiday"> | $Enums.HolidayType
    isRecurring?: BoolWithAggregatesFilter<"Holiday"> | boolean
    isActive?: BoolWithAggregatesFilter<"Holiday"> | boolean
    createdBy?: StringWithAggregatesFilter<"Holiday"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
  }

  export type AttendanceRecordWhereInput = {
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    id?: StringFilter<"AttendanceRecord"> | string
    userId?: StringFilter<"AttendanceRecord"> | string
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    checkInTime?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    hoursWorked?: DecimalFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"AttendanceRecord"> | string | null
    isHoliday?: BoolFilter<"AttendanceRecord"> | boolean
    isWeekend?: BoolFilter<"AttendanceRecord"> | boolean
    createdAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AttendanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    status?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    notes?: SortOrderInput | SortOrder
    isHoliday?: SortOrder
    isWeekend?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AttendanceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: AttendanceRecordUserIdDateCompoundUniqueInput
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    userId?: StringFilter<"AttendanceRecord"> | string
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    checkInTime?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    hoursWorked?: DecimalFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"AttendanceRecord"> | string | null
    isHoliday?: BoolFilter<"AttendanceRecord"> | boolean
    isWeekend?: BoolFilter<"AttendanceRecord"> | boolean
    createdAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type AttendanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    status?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    notes?: SortOrderInput | SortOrder
    isHoliday?: SortOrder
    isWeekend?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceRecordCountOrderByAggregateInput
    _avg?: AttendanceRecordAvgOrderByAggregateInput
    _max?: AttendanceRecordMaxOrderByAggregateInput
    _min?: AttendanceRecordMinOrderByAggregateInput
    _sum?: AttendanceRecordSumOrderByAggregateInput
  }

  export type AttendanceRecordScalarWhereWithAggregatesInput = {
    AND?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    OR?: AttendanceRecordScalarWhereWithAggregatesInput[]
    NOT?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    userId?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    date?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
    checkInTime?: DateTimeNullableWithAggregatesFilter<"AttendanceRecord"> | Date | string | null
    checkOutTime?: DateTimeNullableWithAggregatesFilter<"AttendanceRecord"> | Date | string | null
    status?: EnumAttendanceStatusWithAggregatesFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    hoursWorked?: DecimalWithAggregatesFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalWithAggregatesFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"AttendanceRecord"> | string | null
    isHoliday?: BoolWithAggregatesFilter<"AttendanceRecord"> | boolean
    isWeekend?: BoolWithAggregatesFilter<"AttendanceRecord"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
  }

  export type AttendancePolicyWhereInput = {
    AND?: AttendancePolicyWhereInput | AttendancePolicyWhereInput[]
    OR?: AttendancePolicyWhereInput[]
    NOT?: AttendancePolicyWhereInput | AttendancePolicyWhereInput[]
    id?: StringFilter<"AttendancePolicy"> | string
    name?: StringFilter<"AttendancePolicy"> | string
    workingHoursPerDay?: DecimalFilter<"AttendancePolicy"> | Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: IntFilter<"AttendancePolicy"> | number
    overtimeThresholdHours?: DecimalFilter<"AttendancePolicy"> | Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: BoolFilter<"AttendancePolicy"> | boolean
    requireCheckIn?: BoolFilter<"AttendancePolicy"> | boolean
    requireCheckOut?: BoolFilter<"AttendancePolicy"> | boolean
    isActive?: BoolFilter<"AttendancePolicy"> | boolean
    createdBy?: StringFilter<"AttendancePolicy"> | string
    createdAt?: DateTimeFilter<"AttendancePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"AttendancePolicy"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AttendancePolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    workingHoursPerDay?: SortOrder
    lateThresholdMinutes?: SortOrder
    overtimeThresholdHours?: SortOrder
    allowFlexibleHours?: SortOrder
    requireCheckIn?: SortOrder
    requireCheckOut?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type AttendancePolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendancePolicyWhereInput | AttendancePolicyWhereInput[]
    OR?: AttendancePolicyWhereInput[]
    NOT?: AttendancePolicyWhereInput | AttendancePolicyWhereInput[]
    name?: StringFilter<"AttendancePolicy"> | string
    workingHoursPerDay?: DecimalFilter<"AttendancePolicy"> | Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: IntFilter<"AttendancePolicy"> | number
    overtimeThresholdHours?: DecimalFilter<"AttendancePolicy"> | Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: BoolFilter<"AttendancePolicy"> | boolean
    requireCheckIn?: BoolFilter<"AttendancePolicy"> | boolean
    requireCheckOut?: BoolFilter<"AttendancePolicy"> | boolean
    isActive?: BoolFilter<"AttendancePolicy"> | boolean
    createdBy?: StringFilter<"AttendancePolicy"> | string
    createdAt?: DateTimeFilter<"AttendancePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"AttendancePolicy"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AttendancePolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    workingHoursPerDay?: SortOrder
    lateThresholdMinutes?: SortOrder
    overtimeThresholdHours?: SortOrder
    allowFlexibleHours?: SortOrder
    requireCheckIn?: SortOrder
    requireCheckOut?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendancePolicyCountOrderByAggregateInput
    _avg?: AttendancePolicyAvgOrderByAggregateInput
    _max?: AttendancePolicyMaxOrderByAggregateInput
    _min?: AttendancePolicyMinOrderByAggregateInput
    _sum?: AttendancePolicySumOrderByAggregateInput
  }

  export type AttendancePolicyScalarWhereWithAggregatesInput = {
    AND?: AttendancePolicyScalarWhereWithAggregatesInput | AttendancePolicyScalarWhereWithAggregatesInput[]
    OR?: AttendancePolicyScalarWhereWithAggregatesInput[]
    NOT?: AttendancePolicyScalarWhereWithAggregatesInput | AttendancePolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendancePolicy"> | string
    name?: StringWithAggregatesFilter<"AttendancePolicy"> | string
    workingHoursPerDay?: DecimalWithAggregatesFilter<"AttendancePolicy"> | Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: IntWithAggregatesFilter<"AttendancePolicy"> | number
    overtimeThresholdHours?: DecimalWithAggregatesFilter<"AttendancePolicy"> | Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: BoolWithAggregatesFilter<"AttendancePolicy"> | boolean
    requireCheckIn?: BoolWithAggregatesFilter<"AttendancePolicy"> | boolean
    requireCheckOut?: BoolWithAggregatesFilter<"AttendancePolicy"> | boolean
    isActive?: BoolWithAggregatesFilter<"AttendancePolicy"> | boolean
    createdBy?: StringWithAggregatesFilter<"AttendancePolicy"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AttendancePolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AttendancePolicy"> | Date | string
  }

  export type EmployeeSalaryWhereInput = {
    AND?: EmployeeSalaryWhereInput | EmployeeSalaryWhereInput[]
    OR?: EmployeeSalaryWhereInput[]
    NOT?: EmployeeSalaryWhereInput | EmployeeSalaryWhereInput[]
    id?: StringFilter<"EmployeeSalary"> | string
    userId?: StringFilter<"EmployeeSalary"> | string
    baseSalary?: DecimalFilter<"EmployeeSalary"> | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalNullableFilter<"EmployeeSalary"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"EmployeeSalary"> | string
    effectiveDate?: DateTimeFilter<"EmployeeSalary"> | Date | string
    endDate?: DateTimeNullableFilter<"EmployeeSalary"> | Date | string | null
    isActive?: BoolFilter<"EmployeeSalary"> | boolean
    createdAt?: DateTimeFilter<"EmployeeSalary"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeSalary"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    monthlySalaries?: MonthlySalaryListRelationFilter
  }

  export type EmployeeSalaryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    baseSalary?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    currency?: SortOrder
    effectiveDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    monthlySalaries?: MonthlySalaryOrderByRelationAggregateInput
  }

  export type EmployeeSalaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeSalaryWhereInput | EmployeeSalaryWhereInput[]
    OR?: EmployeeSalaryWhereInput[]
    NOT?: EmployeeSalaryWhereInput | EmployeeSalaryWhereInput[]
    userId?: StringFilter<"EmployeeSalary"> | string
    baseSalary?: DecimalFilter<"EmployeeSalary"> | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalNullableFilter<"EmployeeSalary"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"EmployeeSalary"> | string
    effectiveDate?: DateTimeFilter<"EmployeeSalary"> | Date | string
    endDate?: DateTimeNullableFilter<"EmployeeSalary"> | Date | string | null
    isActive?: BoolFilter<"EmployeeSalary"> | boolean
    createdAt?: DateTimeFilter<"EmployeeSalary"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeSalary"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    monthlySalaries?: MonthlySalaryListRelationFilter
  }, "id">

  export type EmployeeSalaryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    baseSalary?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    currency?: SortOrder
    effectiveDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeSalaryCountOrderByAggregateInput
    _avg?: EmployeeSalaryAvgOrderByAggregateInput
    _max?: EmployeeSalaryMaxOrderByAggregateInput
    _min?: EmployeeSalaryMinOrderByAggregateInput
    _sum?: EmployeeSalarySumOrderByAggregateInput
  }

  export type EmployeeSalaryScalarWhereWithAggregatesInput = {
    AND?: EmployeeSalaryScalarWhereWithAggregatesInput | EmployeeSalaryScalarWhereWithAggregatesInput[]
    OR?: EmployeeSalaryScalarWhereWithAggregatesInput[]
    NOT?: EmployeeSalaryScalarWhereWithAggregatesInput | EmployeeSalaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeSalary"> | string
    userId?: StringWithAggregatesFilter<"EmployeeSalary"> | string
    baseSalary?: DecimalWithAggregatesFilter<"EmployeeSalary"> | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalNullableWithAggregatesFilter<"EmployeeSalary"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"EmployeeSalary"> | string
    effectiveDate?: DateTimeWithAggregatesFilter<"EmployeeSalary"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"EmployeeSalary"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"EmployeeSalary"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeSalary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeSalary"> | Date | string
  }

  export type MonthlySalaryWhereInput = {
    AND?: MonthlySalaryWhereInput | MonthlySalaryWhereInput[]
    OR?: MonthlySalaryWhereInput[]
    NOT?: MonthlySalaryWhereInput | MonthlySalaryWhereInput[]
    id?: StringFilter<"MonthlySalary"> | string
    employeeSalaryId?: StringFilter<"MonthlySalary"> | string
    userId?: StringFilter<"MonthlySalary"> | string
    year?: IntFilter<"MonthlySalary"> | number
    month?: IntFilter<"MonthlySalary"> | number
    baseSalary?: DecimalFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFilter<"MonthlySalary"> | $Enums.SalaryStatus
    calculatedAt?: DateTimeNullableFilter<"MonthlySalary"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"MonthlySalary"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"MonthlySalary"> | Date | string | null
    approvedBy?: StringNullableFilter<"MonthlySalary"> | string | null
    notes?: StringNullableFilter<"MonthlySalary"> | string | null
    createdAt?: DateTimeFilter<"MonthlySalary"> | Date | string
    updatedAt?: DateTimeFilter<"MonthlySalary"> | Date | string
    employeeSalary?: XOR<EmployeeSalaryRelationFilter, EmployeeSalaryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    deductions?: SalaryDeductionListRelationFilter
  }

  export type MonthlySalaryOrderByWithRelationInput = {
    id?: SortOrder
    employeeSalaryId?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    baseSalary?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    calculatedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeSalary?: EmployeeSalaryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    deductions?: SalaryDeductionOrderByRelationAggregateInput
  }

  export type MonthlySalaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_year_month?: MonthlySalaryUserIdYearMonthCompoundUniqueInput
    AND?: MonthlySalaryWhereInput | MonthlySalaryWhereInput[]
    OR?: MonthlySalaryWhereInput[]
    NOT?: MonthlySalaryWhereInput | MonthlySalaryWhereInput[]
    employeeSalaryId?: StringFilter<"MonthlySalary"> | string
    userId?: StringFilter<"MonthlySalary"> | string
    year?: IntFilter<"MonthlySalary"> | number
    month?: IntFilter<"MonthlySalary"> | number
    baseSalary?: DecimalFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFilter<"MonthlySalary"> | $Enums.SalaryStatus
    calculatedAt?: DateTimeNullableFilter<"MonthlySalary"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"MonthlySalary"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"MonthlySalary"> | Date | string | null
    approvedBy?: StringNullableFilter<"MonthlySalary"> | string | null
    notes?: StringNullableFilter<"MonthlySalary"> | string | null
    createdAt?: DateTimeFilter<"MonthlySalary"> | Date | string
    updatedAt?: DateTimeFilter<"MonthlySalary"> | Date | string
    employeeSalary?: XOR<EmployeeSalaryRelationFilter, EmployeeSalaryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    deductions?: SalaryDeductionListRelationFilter
  }, "id" | "userId_year_month">

  export type MonthlySalaryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeSalaryId?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    baseSalary?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    calculatedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MonthlySalaryCountOrderByAggregateInput
    _avg?: MonthlySalaryAvgOrderByAggregateInput
    _max?: MonthlySalaryMaxOrderByAggregateInput
    _min?: MonthlySalaryMinOrderByAggregateInput
    _sum?: MonthlySalarySumOrderByAggregateInput
  }

  export type MonthlySalaryScalarWhereWithAggregatesInput = {
    AND?: MonthlySalaryScalarWhereWithAggregatesInput | MonthlySalaryScalarWhereWithAggregatesInput[]
    OR?: MonthlySalaryScalarWhereWithAggregatesInput[]
    NOT?: MonthlySalaryScalarWhereWithAggregatesInput | MonthlySalaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MonthlySalary"> | string
    employeeSalaryId?: StringWithAggregatesFilter<"MonthlySalary"> | string
    userId?: StringWithAggregatesFilter<"MonthlySalary"> | string
    year?: IntWithAggregatesFilter<"MonthlySalary"> | number
    month?: IntWithAggregatesFilter<"MonthlySalary"> | number
    baseSalary?: DecimalWithAggregatesFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalWithAggregatesFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalWithAggregatesFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalWithAggregatesFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusWithAggregatesFilter<"MonthlySalary"> | $Enums.SalaryStatus
    calculatedAt?: DateTimeNullableWithAggregatesFilter<"MonthlySalary"> | Date | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"MonthlySalary"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"MonthlySalary"> | Date | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"MonthlySalary"> | string | null
    notes?: StringNullableWithAggregatesFilter<"MonthlySalary"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MonthlySalary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MonthlySalary"> | Date | string
  }

  export type SalaryDeductionWhereInput = {
    AND?: SalaryDeductionWhereInput | SalaryDeductionWhereInput[]
    OR?: SalaryDeductionWhereInput[]
    NOT?: SalaryDeductionWhereInput | SalaryDeductionWhereInput[]
    id?: StringFilter<"SalaryDeduction"> | string
    monthlySalaryId?: StringFilter<"SalaryDeduction"> | string
    type?: EnumDeductionTypeFilter<"SalaryDeduction"> | $Enums.DeductionType
    description?: StringFilter<"SalaryDeduction"> | string
    amount?: DecimalFilter<"SalaryDeduction"> | Decimal | DecimalJsLike | number | string
    leaveRequestId?: StringNullableFilter<"SalaryDeduction"> | string | null
    isTaxable?: BoolFilter<"SalaryDeduction"> | boolean
    createdAt?: DateTimeFilter<"SalaryDeduction"> | Date | string
    monthlySalary?: XOR<MonthlySalaryRelationFilter, MonthlySalaryWhereInput>
    leaveRequest?: XOR<LeaveRequestNullableRelationFilter, LeaveRequestWhereInput> | null
  }

  export type SalaryDeductionOrderByWithRelationInput = {
    id?: SortOrder
    monthlySalaryId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    leaveRequestId?: SortOrderInput | SortOrder
    isTaxable?: SortOrder
    createdAt?: SortOrder
    monthlySalary?: MonthlySalaryOrderByWithRelationInput
    leaveRequest?: LeaveRequestOrderByWithRelationInput
  }

  export type SalaryDeductionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalaryDeductionWhereInput | SalaryDeductionWhereInput[]
    OR?: SalaryDeductionWhereInput[]
    NOT?: SalaryDeductionWhereInput | SalaryDeductionWhereInput[]
    monthlySalaryId?: StringFilter<"SalaryDeduction"> | string
    type?: EnumDeductionTypeFilter<"SalaryDeduction"> | $Enums.DeductionType
    description?: StringFilter<"SalaryDeduction"> | string
    amount?: DecimalFilter<"SalaryDeduction"> | Decimal | DecimalJsLike | number | string
    leaveRequestId?: StringNullableFilter<"SalaryDeduction"> | string | null
    isTaxable?: BoolFilter<"SalaryDeduction"> | boolean
    createdAt?: DateTimeFilter<"SalaryDeduction"> | Date | string
    monthlySalary?: XOR<MonthlySalaryRelationFilter, MonthlySalaryWhereInput>
    leaveRequest?: XOR<LeaveRequestNullableRelationFilter, LeaveRequestWhereInput> | null
  }, "id">

  export type SalaryDeductionOrderByWithAggregationInput = {
    id?: SortOrder
    monthlySalaryId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    leaveRequestId?: SortOrderInput | SortOrder
    isTaxable?: SortOrder
    createdAt?: SortOrder
    _count?: SalaryDeductionCountOrderByAggregateInput
    _avg?: SalaryDeductionAvgOrderByAggregateInput
    _max?: SalaryDeductionMaxOrderByAggregateInput
    _min?: SalaryDeductionMinOrderByAggregateInput
    _sum?: SalaryDeductionSumOrderByAggregateInput
  }

  export type SalaryDeductionScalarWhereWithAggregatesInput = {
    AND?: SalaryDeductionScalarWhereWithAggregatesInput | SalaryDeductionScalarWhereWithAggregatesInput[]
    OR?: SalaryDeductionScalarWhereWithAggregatesInput[]
    NOT?: SalaryDeductionScalarWhereWithAggregatesInput | SalaryDeductionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalaryDeduction"> | string
    monthlySalaryId?: StringWithAggregatesFilter<"SalaryDeduction"> | string
    type?: EnumDeductionTypeWithAggregatesFilter<"SalaryDeduction"> | $Enums.DeductionType
    description?: StringWithAggregatesFilter<"SalaryDeduction"> | string
    amount?: DecimalWithAggregatesFilter<"SalaryDeduction"> | Decimal | DecimalJsLike | number | string
    leaveRequestId?: StringNullableWithAggregatesFilter<"SalaryDeduction"> | string | null
    isTaxable?: BoolWithAggregatesFilter<"SalaryDeduction"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SalaryDeduction"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestCreateInput = {
    id?: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaveRequestsInput
    approver?: UserCreateNestedOneWithoutApprovedLeavesInput
    documents?: LeaveDocumentCreateNestedManyWithoutLeaveRequestInput
    salaryDeductions?: SalaryDeductionCreateNestedManyWithoutLeaveRequestInput
  }

  export type LeaveRequestUncheckedCreateInput = {
    id?: string
    userId: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: LeaveDocumentUncheckedCreateNestedManyWithoutLeaveRequestInput
    salaryDeductions?: SalaryDeductionUncheckedCreateNestedManyWithoutLeaveRequestInput
  }

  export type LeaveRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaveRequestsNestedInput
    approver?: UserUpdateOneWithoutApprovedLeavesNestedInput
    documents?: LeaveDocumentUpdateManyWithoutLeaveRequestNestedInput
    salaryDeductions?: SalaryDeductionUpdateManyWithoutLeaveRequestNestedInput
  }

  export type LeaveRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: LeaveDocumentUncheckedUpdateManyWithoutLeaveRequestNestedInput
    salaryDeductions?: SalaryDeductionUncheckedUpdateManyWithoutLeaveRequestNestedInput
  }

  export type LeaveRequestCreateManyInput = {
    id?: string
    userId: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceCreateInput = {
    id?: string
    year: number
    annualTotal?: number
    annualUsed?: number
    annualRemaining?: number
    sickTotal?: number
    sickUsed?: number
    sickRemaining?: number
    casualTotal?: number
    casualUsed?: number
    casualRemaining?: number
    maternityTotal?: number
    maternityUsed?: number
    maternityRemaining?: number
    paternityTotal?: number
    paternityUsed?: number
    paternityRemaining?: number
    emergencyTotal?: number
    emergencyUsed?: number
    emergencyRemaining?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaveBalancesInput
  }

  export type LeaveBalanceUncheckedCreateInput = {
    id?: string
    userId: string
    year: number
    annualTotal?: number
    annualUsed?: number
    annualRemaining?: number
    sickTotal?: number
    sickUsed?: number
    sickRemaining?: number
    casualTotal?: number
    casualUsed?: number
    casualRemaining?: number
    maternityTotal?: number
    maternityUsed?: number
    maternityRemaining?: number
    paternityTotal?: number
    paternityUsed?: number
    paternityRemaining?: number
    emergencyTotal?: number
    emergencyUsed?: number
    emergencyRemaining?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveBalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    annualTotal?: IntFieldUpdateOperationsInput | number
    annualUsed?: IntFieldUpdateOperationsInput | number
    annualRemaining?: IntFieldUpdateOperationsInput | number
    sickTotal?: IntFieldUpdateOperationsInput | number
    sickUsed?: IntFieldUpdateOperationsInput | number
    sickRemaining?: IntFieldUpdateOperationsInput | number
    casualTotal?: IntFieldUpdateOperationsInput | number
    casualUsed?: IntFieldUpdateOperationsInput | number
    casualRemaining?: IntFieldUpdateOperationsInput | number
    maternityTotal?: IntFieldUpdateOperationsInput | number
    maternityUsed?: IntFieldUpdateOperationsInput | number
    maternityRemaining?: IntFieldUpdateOperationsInput | number
    paternityTotal?: IntFieldUpdateOperationsInput | number
    paternityUsed?: IntFieldUpdateOperationsInput | number
    paternityRemaining?: IntFieldUpdateOperationsInput | number
    emergencyTotal?: IntFieldUpdateOperationsInput | number
    emergencyUsed?: IntFieldUpdateOperationsInput | number
    emergencyRemaining?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaveBalancesNestedInput
  }

  export type LeaveBalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    annualTotal?: IntFieldUpdateOperationsInput | number
    annualUsed?: IntFieldUpdateOperationsInput | number
    annualRemaining?: IntFieldUpdateOperationsInput | number
    sickTotal?: IntFieldUpdateOperationsInput | number
    sickUsed?: IntFieldUpdateOperationsInput | number
    sickRemaining?: IntFieldUpdateOperationsInput | number
    casualTotal?: IntFieldUpdateOperationsInput | number
    casualUsed?: IntFieldUpdateOperationsInput | number
    casualRemaining?: IntFieldUpdateOperationsInput | number
    maternityTotal?: IntFieldUpdateOperationsInput | number
    maternityUsed?: IntFieldUpdateOperationsInput | number
    maternityRemaining?: IntFieldUpdateOperationsInput | number
    paternityTotal?: IntFieldUpdateOperationsInput | number
    paternityUsed?: IntFieldUpdateOperationsInput | number
    paternityRemaining?: IntFieldUpdateOperationsInput | number
    emergencyTotal?: IntFieldUpdateOperationsInput | number
    emergencyUsed?: IntFieldUpdateOperationsInput | number
    emergencyRemaining?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceCreateManyInput = {
    id?: string
    userId: string
    year: number
    annualTotal?: number
    annualUsed?: number
    annualRemaining?: number
    sickTotal?: number
    sickUsed?: number
    sickRemaining?: number
    casualTotal?: number
    casualUsed?: number
    casualRemaining?: number
    maternityTotal?: number
    maternityUsed?: number
    maternityRemaining?: number
    paternityTotal?: number
    paternityUsed?: number
    paternityRemaining?: number
    emergencyTotal?: number
    emergencyUsed?: number
    emergencyRemaining?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveBalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    annualTotal?: IntFieldUpdateOperationsInput | number
    annualUsed?: IntFieldUpdateOperationsInput | number
    annualRemaining?: IntFieldUpdateOperationsInput | number
    sickTotal?: IntFieldUpdateOperationsInput | number
    sickUsed?: IntFieldUpdateOperationsInput | number
    sickRemaining?: IntFieldUpdateOperationsInput | number
    casualTotal?: IntFieldUpdateOperationsInput | number
    casualUsed?: IntFieldUpdateOperationsInput | number
    casualRemaining?: IntFieldUpdateOperationsInput | number
    maternityTotal?: IntFieldUpdateOperationsInput | number
    maternityUsed?: IntFieldUpdateOperationsInput | number
    maternityRemaining?: IntFieldUpdateOperationsInput | number
    paternityTotal?: IntFieldUpdateOperationsInput | number
    paternityUsed?: IntFieldUpdateOperationsInput | number
    paternityRemaining?: IntFieldUpdateOperationsInput | number
    emergencyTotal?: IntFieldUpdateOperationsInput | number
    emergencyUsed?: IntFieldUpdateOperationsInput | number
    emergencyRemaining?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    annualTotal?: IntFieldUpdateOperationsInput | number
    annualUsed?: IntFieldUpdateOperationsInput | number
    annualRemaining?: IntFieldUpdateOperationsInput | number
    sickTotal?: IntFieldUpdateOperationsInput | number
    sickUsed?: IntFieldUpdateOperationsInput | number
    sickRemaining?: IntFieldUpdateOperationsInput | number
    casualTotal?: IntFieldUpdateOperationsInput | number
    casualUsed?: IntFieldUpdateOperationsInput | number
    casualRemaining?: IntFieldUpdateOperationsInput | number
    maternityTotal?: IntFieldUpdateOperationsInput | number
    maternityUsed?: IntFieldUpdateOperationsInput | number
    maternityRemaining?: IntFieldUpdateOperationsInput | number
    paternityTotal?: IntFieldUpdateOperationsInput | number
    paternityUsed?: IntFieldUpdateOperationsInput | number
    paternityRemaining?: IntFieldUpdateOperationsInput | number
    emergencyTotal?: IntFieldUpdateOperationsInput | number
    emergencyUsed?: IntFieldUpdateOperationsInput | number
    emergencyRemaining?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeavePolicyCreateInput = {
    id?: string
    leaveType: string
    totalDaysPerYear: number
    canCarryForward?: boolean
    maxCarryForwardDays?: number | null
    requiresApproval?: boolean
    allowHalfDay?: boolean
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedPoliciesInput
  }

  export type LeavePolicyUncheckedCreateInput = {
    id?: string
    leaveType: string
    totalDaysPerYear: number
    canCarryForward?: boolean
    maxCarryForwardDays?: number | null
    requiresApproval?: boolean
    allowHalfDay?: boolean
    description?: string | null
    isActive?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeavePolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    totalDaysPerYear?: IntFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForwardDays?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedPoliciesNestedInput
  }

  export type LeavePolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    totalDaysPerYear?: IntFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForwardDays?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeavePolicyCreateManyInput = {
    id?: string
    leaveType: string
    totalDaysPerYear: number
    canCarryForward?: boolean
    maxCarryForwardDays?: number | null
    requiresApproval?: boolean
    allowHalfDay?: boolean
    description?: string | null
    isActive?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeavePolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    totalDaysPerYear?: IntFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForwardDays?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeavePolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    totalDaysPerYear?: IntFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForwardDays?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    userName: string
    action: string
    targetId?: string | null
    targetType?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    userName: string
    action: string
    targetId?: string | null
    targetType?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    userName: string
    action: string
    targetId?: string | null
    targetType?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveDocumentCreateInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    leaveRequest: LeaveRequestCreateNestedOneWithoutDocumentsInput
  }

  export type LeaveDocumentUncheckedCreateInput = {
    id?: string
    leaveRequestId: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
  }

  export type LeaveDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveRequest?: LeaveRequestUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type LeaveDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveRequestId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveDocumentCreateManyInput = {
    id?: string
    leaveRequestId: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
  }

  export type LeaveDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveRequestId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayCreateInput = {
    id?: string
    name: string
    description?: string | null
    date: Date | string
    type: $Enums.HolidayType
    isRecurring?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedHolidaysInput
  }

  export type HolidayUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    date: Date | string
    type: $Enums.HolidayType
    isRecurring?: boolean
    isActive?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumHolidayTypeFieldUpdateOperationsInput | $Enums.HolidayType
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedHolidaysNestedInput
  }

  export type HolidayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumHolidayTypeFieldUpdateOperationsInput | $Enums.HolidayType
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    date: Date | string
    type: $Enums.HolidayType
    isRecurring?: boolean
    isActive?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumHolidayTypeFieldUpdateOperationsInput | $Enums.HolidayType
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumHolidayTypeFieldUpdateOperationsInput | $Enums.HolidayType
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordCreateInput = {
    id?: string
    date: Date | string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    status?: $Enums.AttendanceStatus
    hoursWorked?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isHoliday?: boolean
    isWeekend?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    status?: $Enums.AttendanceStatus
    hoursWorked?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isHoliday?: boolean
    isWeekend?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    isWeekend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    isWeekend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    status?: $Enums.AttendanceStatus
    hoursWorked?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isHoliday?: boolean
    isWeekend?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    isWeekend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    isWeekend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendancePolicyCreateInput = {
    id?: string
    name: string
    workingHoursPerDay?: Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: number
    overtimeThresholdHours?: Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: boolean
    requireCheckIn?: boolean
    requireCheckOut?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedAttendancePoliciesInput
  }

  export type AttendancePolicyUncheckedCreateInput = {
    id?: string
    name: string
    workingHoursPerDay?: Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: number
    overtimeThresholdHours?: Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: boolean
    requireCheckIn?: boolean
    requireCheckOut?: boolean
    isActive?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendancePolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingHoursPerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: IntFieldUpdateOperationsInput | number
    overtimeThresholdHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: BoolFieldUpdateOperationsInput | boolean
    requireCheckIn?: BoolFieldUpdateOperationsInput | boolean
    requireCheckOut?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedAttendancePoliciesNestedInput
  }

  export type AttendancePolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingHoursPerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: IntFieldUpdateOperationsInput | number
    overtimeThresholdHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: BoolFieldUpdateOperationsInput | boolean
    requireCheckIn?: BoolFieldUpdateOperationsInput | boolean
    requireCheckOut?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendancePolicyCreateManyInput = {
    id?: string
    name: string
    workingHoursPerDay?: Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: number
    overtimeThresholdHours?: Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: boolean
    requireCheckIn?: boolean
    requireCheckOut?: boolean
    isActive?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendancePolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingHoursPerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: IntFieldUpdateOperationsInput | number
    overtimeThresholdHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: BoolFieldUpdateOperationsInput | boolean
    requireCheckIn?: BoolFieldUpdateOperationsInput | boolean
    requireCheckOut?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendancePolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingHoursPerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: IntFieldUpdateOperationsInput | number
    overtimeThresholdHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: BoolFieldUpdateOperationsInput | boolean
    requireCheckIn?: BoolFieldUpdateOperationsInput | boolean
    requireCheckOut?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeSalaryCreateInput = {
    id?: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeSalaryInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutEmployeeSalaryInput
  }

  export type EmployeeSalaryUncheckedCreateInput = {
    id?: string
    userId: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutEmployeeSalaryInput
  }

  export type EmployeeSalaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeSalaryNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutEmployeeSalaryNestedInput
  }

  export type EmployeeSalaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutEmployeeSalaryNestedInput
  }

  export type EmployeeSalaryCreateManyInput = {
    id?: string
    userId: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeSalaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeSalaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlySalaryCreateInput = {
    id?: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeSalary: EmployeeSalaryCreateNestedOneWithoutMonthlySalariesInput
    user: UserCreateNestedOneWithoutMonthlySalariesInput
    approver?: UserCreateNestedOneWithoutApprovedSalariesInput
    deductions?: SalaryDeductionCreateNestedManyWithoutMonthlySalaryInput
  }

  export type MonthlySalaryUncheckedCreateInput = {
    id?: string
    employeeSalaryId: string
    userId: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    approvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deductions?: SalaryDeductionUncheckedCreateNestedManyWithoutMonthlySalaryInput
  }

  export type MonthlySalaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeSalary?: EmployeeSalaryUpdateOneRequiredWithoutMonthlySalariesNestedInput
    user?: UserUpdateOneRequiredWithoutMonthlySalariesNestedInput
    approver?: UserUpdateOneWithoutApprovedSalariesNestedInput
    deductions?: SalaryDeductionUpdateManyWithoutMonthlySalaryNestedInput
  }

  export type MonthlySalaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeSalaryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deductions?: SalaryDeductionUncheckedUpdateManyWithoutMonthlySalaryNestedInput
  }

  export type MonthlySalaryCreateManyInput = {
    id?: string
    employeeSalaryId: string
    userId: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    approvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonthlySalaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlySalaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeSalaryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryDeductionCreateInput = {
    id?: string
    type: $Enums.DeductionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    createdAt?: Date | string
    monthlySalary: MonthlySalaryCreateNestedOneWithoutDeductionsInput
    leaveRequest?: LeaveRequestCreateNestedOneWithoutSalaryDeductionsInput
  }

  export type SalaryDeductionUncheckedCreateInput = {
    id?: string
    monthlySalaryId: string
    type: $Enums.DeductionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    leaveRequestId?: string | null
    isTaxable?: boolean
    createdAt?: Date | string
  }

  export type SalaryDeductionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDeductionTypeFieldUpdateOperationsInput | $Enums.DeductionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlySalary?: MonthlySalaryUpdateOneRequiredWithoutDeductionsNestedInput
    leaveRequest?: LeaveRequestUpdateOneWithoutSalaryDeductionsNestedInput
  }

  export type SalaryDeductionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthlySalaryId?: StringFieldUpdateOperationsInput | string
    type?: EnumDeductionTypeFieldUpdateOperationsInput | $Enums.DeductionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaveRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryDeductionCreateManyInput = {
    id?: string
    monthlySalaryId: string
    type: $Enums.DeductionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    leaveRequestId?: string | null
    isTaxable?: boolean
    createdAt?: Date | string
  }

  export type SalaryDeductionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDeductionTypeFieldUpdateOperationsInput | $Enums.DeductionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryDeductionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthlySalaryId?: StringFieldUpdateOperationsInput | string
    type?: EnumDeductionTypeFieldUpdateOperationsInput | $Enums.DeductionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaveRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type LeaveRequestListRelationFilter = {
    every?: LeaveRequestWhereInput
    some?: LeaveRequestWhereInput
    none?: LeaveRequestWhereInput
  }

  export type LeaveBalanceListRelationFilter = {
    every?: LeaveBalanceWhereInput
    some?: LeaveBalanceWhereInput
    none?: LeaveBalanceWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type LeavePolicyListRelationFilter = {
    every?: LeavePolicyWhereInput
    some?: LeavePolicyWhereInput
    none?: LeavePolicyWhereInput
  }

  export type HolidayListRelationFilter = {
    every?: HolidayWhereInput
    some?: HolidayWhereInput
    none?: HolidayWhereInput
  }

  export type AttendanceRecordListRelationFilter = {
    every?: AttendanceRecordWhereInput
    some?: AttendanceRecordWhereInput
    none?: AttendanceRecordWhereInput
  }

  export type AttendancePolicyListRelationFilter = {
    every?: AttendancePolicyWhereInput
    some?: AttendancePolicyWhereInput
    none?: AttendancePolicyWhereInput
  }

  export type EmployeeSalaryListRelationFilter = {
    every?: EmployeeSalaryWhereInput
    some?: EmployeeSalaryWhereInput
    none?: EmployeeSalaryWhereInput
  }

  export type MonthlySalaryListRelationFilter = {
    every?: MonthlySalaryWhereInput
    some?: MonthlySalaryWhereInput
    none?: MonthlySalaryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeavePolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HolidayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendancePolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeSalaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MonthlySalaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    department?: SortOrder
    managerId?: SortOrder
    profilePicture?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    address?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    department?: SortOrder
    managerId?: SortOrder
    profilePicture?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    address?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    department?: SortOrder
    managerId?: SortOrder
    profilePicture?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    address?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type EnumHalfDayPeriodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.HalfDayPeriod | EnumHalfDayPeriodFieldRefInput<$PrismaModel> | null
    in?: $Enums.HalfDayPeriod[] | ListEnumHalfDayPeriodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HalfDayPeriod[] | ListEnumHalfDayPeriodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHalfDayPeriodNullableFilter<$PrismaModel> | $Enums.HalfDayPeriod | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type LeaveDocumentListRelationFilter = {
    every?: LeaveDocumentWhereInput
    some?: LeaveDocumentWhereInput
    none?: LeaveDocumentWhereInput
  }

  export type SalaryDeductionListRelationFilter = {
    every?: SalaryDeductionWhereInput
    some?: SalaryDeductionWhereInput
    none?: SalaryDeductionWhereInput
  }

  export type LeaveDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryDeductionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedReason?: SortOrder
    isHalfDay?: SortOrder
    halfDayPeriod?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestAvgOrderByAggregateInput = {
    totalDays?: SortOrder
  }

  export type LeaveRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedReason?: SortOrder
    isHalfDay?: SortOrder
    halfDayPeriod?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedReason?: SortOrder
    isHalfDay?: SortOrder
    halfDayPeriod?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestSumOrderByAggregateInput = {
    totalDays?: SortOrder
  }

  export type EnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type EnumHalfDayPeriodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HalfDayPeriod | EnumHalfDayPeriodFieldRefInput<$PrismaModel> | null
    in?: $Enums.HalfDayPeriod[] | ListEnumHalfDayPeriodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HalfDayPeriod[] | ListEnumHalfDayPeriodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHalfDayPeriodNullableWithAggregatesFilter<$PrismaModel> | $Enums.HalfDayPeriod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumHalfDayPeriodNullableFilter<$PrismaModel>
    _max?: NestedEnumHalfDayPeriodNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type LeaveBalanceUserIdYearCompoundUniqueInput = {
    userId: string
    year: number
  }

  export type LeaveBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    annualTotal?: SortOrder
    annualUsed?: SortOrder
    annualRemaining?: SortOrder
    sickTotal?: SortOrder
    sickUsed?: SortOrder
    sickRemaining?: SortOrder
    casualTotal?: SortOrder
    casualUsed?: SortOrder
    casualRemaining?: SortOrder
    maternityTotal?: SortOrder
    maternityUsed?: SortOrder
    maternityRemaining?: SortOrder
    paternityTotal?: SortOrder
    paternityUsed?: SortOrder
    paternityRemaining?: SortOrder
    emergencyTotal?: SortOrder
    emergencyUsed?: SortOrder
    emergencyRemaining?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveBalanceAvgOrderByAggregateInput = {
    year?: SortOrder
    annualTotal?: SortOrder
    annualUsed?: SortOrder
    annualRemaining?: SortOrder
    sickTotal?: SortOrder
    sickUsed?: SortOrder
    sickRemaining?: SortOrder
    casualTotal?: SortOrder
    casualUsed?: SortOrder
    casualRemaining?: SortOrder
    maternityTotal?: SortOrder
    maternityUsed?: SortOrder
    maternityRemaining?: SortOrder
    paternityTotal?: SortOrder
    paternityUsed?: SortOrder
    paternityRemaining?: SortOrder
    emergencyTotal?: SortOrder
    emergencyUsed?: SortOrder
    emergencyRemaining?: SortOrder
  }

  export type LeaveBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    annualTotal?: SortOrder
    annualUsed?: SortOrder
    annualRemaining?: SortOrder
    sickTotal?: SortOrder
    sickUsed?: SortOrder
    sickRemaining?: SortOrder
    casualTotal?: SortOrder
    casualUsed?: SortOrder
    casualRemaining?: SortOrder
    maternityTotal?: SortOrder
    maternityUsed?: SortOrder
    maternityRemaining?: SortOrder
    paternityTotal?: SortOrder
    paternityUsed?: SortOrder
    paternityRemaining?: SortOrder
    emergencyTotal?: SortOrder
    emergencyUsed?: SortOrder
    emergencyRemaining?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    annualTotal?: SortOrder
    annualUsed?: SortOrder
    annualRemaining?: SortOrder
    sickTotal?: SortOrder
    sickUsed?: SortOrder
    sickRemaining?: SortOrder
    casualTotal?: SortOrder
    casualUsed?: SortOrder
    casualRemaining?: SortOrder
    maternityTotal?: SortOrder
    maternityUsed?: SortOrder
    maternityRemaining?: SortOrder
    paternityTotal?: SortOrder
    paternityUsed?: SortOrder
    paternityRemaining?: SortOrder
    emergencyTotal?: SortOrder
    emergencyUsed?: SortOrder
    emergencyRemaining?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveBalanceSumOrderByAggregateInput = {
    year?: SortOrder
    annualTotal?: SortOrder
    annualUsed?: SortOrder
    annualRemaining?: SortOrder
    sickTotal?: SortOrder
    sickUsed?: SortOrder
    sickRemaining?: SortOrder
    casualTotal?: SortOrder
    casualUsed?: SortOrder
    casualRemaining?: SortOrder
    maternityTotal?: SortOrder
    maternityUsed?: SortOrder
    maternityRemaining?: SortOrder
    paternityTotal?: SortOrder
    paternityUsed?: SortOrder
    paternityRemaining?: SortOrder
    emergencyTotal?: SortOrder
    emergencyUsed?: SortOrder
    emergencyRemaining?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type LeavePolicyCountOrderByAggregateInput = {
    id?: SortOrder
    leaveType?: SortOrder
    totalDaysPerYear?: SortOrder
    canCarryForward?: SortOrder
    maxCarryForwardDays?: SortOrder
    requiresApproval?: SortOrder
    allowHalfDay?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeavePolicyAvgOrderByAggregateInput = {
    totalDaysPerYear?: SortOrder
    maxCarryForwardDays?: SortOrder
  }

  export type LeavePolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    leaveType?: SortOrder
    totalDaysPerYear?: SortOrder
    canCarryForward?: SortOrder
    maxCarryForwardDays?: SortOrder
    requiresApproval?: SortOrder
    allowHalfDay?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeavePolicyMinOrderByAggregateInput = {
    id?: SortOrder
    leaveType?: SortOrder
    totalDaysPerYear?: SortOrder
    canCarryForward?: SortOrder
    maxCarryForwardDays?: SortOrder
    requiresApproval?: SortOrder
    allowHalfDay?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeavePolicySumOrderByAggregateInput = {
    totalDaysPerYear?: SortOrder
    maxCarryForwardDays?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type LeaveRequestRelationFilter = {
    is?: LeaveRequestWhereInput
    isNot?: LeaveRequestWhereInput
  }

  export type LeaveDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    leaveRequestId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type LeaveDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type LeaveDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    leaveRequestId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type LeaveDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    leaveRequestId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type LeaveDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumHolidayTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.HolidayType | EnumHolidayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HolidayType[] | ListEnumHolidayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HolidayType[] | ListEnumHolidayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHolidayTypeFilter<$PrismaModel> | $Enums.HolidayType
  }

  export type HolidayName_dateCompoundUniqueInput = {
    name: string
    date: Date | string
  }

  export type HolidayCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    type?: SortOrder
    isRecurring?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    type?: SortOrder
    isRecurring?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    type?: SortOrder
    isRecurring?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumHolidayTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HolidayType | EnumHolidayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HolidayType[] | ListEnumHolidayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HolidayType[] | ListEnumHolidayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHolidayTypeWithAggregatesFilter<$PrismaModel> | $Enums.HolidayType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHolidayTypeFilter<$PrismaModel>
    _max?: NestedEnumHolidayTypeFilter<$PrismaModel>
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceRecordUserIdDateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type AttendanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    status?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    notes?: SortOrder
    isHoliday?: SortOrder
    isWeekend?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceRecordAvgOrderByAggregateInput = {
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
  }

  export type AttendanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    status?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    notes?: SortOrder
    isHoliday?: SortOrder
    isWeekend?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    status?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    notes?: SortOrder
    isHoliday?: SortOrder
    isWeekend?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceRecordSumOrderByAggregateInput = {
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type AttendancePolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    workingHoursPerDay?: SortOrder
    lateThresholdMinutes?: SortOrder
    overtimeThresholdHours?: SortOrder
    allowFlexibleHours?: SortOrder
    requireCheckIn?: SortOrder
    requireCheckOut?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendancePolicyAvgOrderByAggregateInput = {
    workingHoursPerDay?: SortOrder
    lateThresholdMinutes?: SortOrder
    overtimeThresholdHours?: SortOrder
  }

  export type AttendancePolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    workingHoursPerDay?: SortOrder
    lateThresholdMinutes?: SortOrder
    overtimeThresholdHours?: SortOrder
    allowFlexibleHours?: SortOrder
    requireCheckIn?: SortOrder
    requireCheckOut?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendancePolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    workingHoursPerDay?: SortOrder
    lateThresholdMinutes?: SortOrder
    overtimeThresholdHours?: SortOrder
    allowFlexibleHours?: SortOrder
    requireCheckIn?: SortOrder
    requireCheckOut?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendancePolicySumOrderByAggregateInput = {
    workingHoursPerDay?: SortOrder
    lateThresholdMinutes?: SortOrder
    overtimeThresholdHours?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeSalaryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    baseSalary?: SortOrder
    hourlyRate?: SortOrder
    currency?: SortOrder
    effectiveDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSalaryAvgOrderByAggregateInput = {
    baseSalary?: SortOrder
    hourlyRate?: SortOrder
  }

  export type EmployeeSalaryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    baseSalary?: SortOrder
    hourlyRate?: SortOrder
    currency?: SortOrder
    effectiveDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSalaryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    baseSalary?: SortOrder
    hourlyRate?: SortOrder
    currency?: SortOrder
    effectiveDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSalarySumOrderByAggregateInput = {
    baseSalary?: SortOrder
    hourlyRate?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumSalaryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryStatus | EnumSalaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryStatusFilter<$PrismaModel> | $Enums.SalaryStatus
  }

  export type EmployeeSalaryRelationFilter = {
    is?: EmployeeSalaryWhereInput
    isNot?: EmployeeSalaryWhereInput
  }

  export type MonthlySalaryUserIdYearMonthCompoundUniqueInput = {
    userId: string
    year: number
    month: number
  }

  export type MonthlySalaryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeSalaryId?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    baseSalary?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    calculatedAt?: SortOrder
    approvedAt?: SortOrder
    paidAt?: SortOrder
    approvedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonthlySalaryAvgOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    baseSalary?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
  }

  export type MonthlySalaryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeSalaryId?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    baseSalary?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    calculatedAt?: SortOrder
    approvedAt?: SortOrder
    paidAt?: SortOrder
    approvedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonthlySalaryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeSalaryId?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    baseSalary?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    calculatedAt?: SortOrder
    approvedAt?: SortOrder
    paidAt?: SortOrder
    approvedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonthlySalarySumOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    baseSalary?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
  }

  export type EnumSalaryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryStatus | EnumSalaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryStatusWithAggregatesFilter<$PrismaModel> | $Enums.SalaryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalaryStatusFilter<$PrismaModel>
    _max?: NestedEnumSalaryStatusFilter<$PrismaModel>
  }

  export type EnumDeductionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeductionType | EnumDeductionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeductionType[] | ListEnumDeductionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeductionType[] | ListEnumDeductionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeductionTypeFilter<$PrismaModel> | $Enums.DeductionType
  }

  export type MonthlySalaryRelationFilter = {
    is?: MonthlySalaryWhereInput
    isNot?: MonthlySalaryWhereInput
  }

  export type LeaveRequestNullableRelationFilter = {
    is?: LeaveRequestWhereInput | null
    isNot?: LeaveRequestWhereInput | null
  }

  export type SalaryDeductionCountOrderByAggregateInput = {
    id?: SortOrder
    monthlySalaryId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    leaveRequestId?: SortOrder
    isTaxable?: SortOrder
    createdAt?: SortOrder
  }

  export type SalaryDeductionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SalaryDeductionMaxOrderByAggregateInput = {
    id?: SortOrder
    monthlySalaryId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    leaveRequestId?: SortOrder
    isTaxable?: SortOrder
    createdAt?: SortOrder
  }

  export type SalaryDeductionMinOrderByAggregateInput = {
    id?: SortOrder
    monthlySalaryId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    leaveRequestId?: SortOrder
    isTaxable?: SortOrder
    createdAt?: SortOrder
  }

  export type SalaryDeductionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumDeductionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeductionType | EnumDeductionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeductionType[] | ListEnumDeductionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeductionType[] | ListEnumDeductionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeductionTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeductionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeductionTypeFilter<$PrismaModel>
    _max?: NestedEnumDeductionTypeFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutSubordinatesInput = {
    create?: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubordinatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput> | LeaveRequestCreateWithoutUserInput[] | LeaveRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutUserInput | LeaveRequestCreateOrConnectWithoutUserInput[]
    createMany?: LeaveRequestCreateManyUserInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutApproverInput = {
    create?: XOR<LeaveRequestCreateWithoutApproverInput, LeaveRequestUncheckedCreateWithoutApproverInput> | LeaveRequestCreateWithoutApproverInput[] | LeaveRequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutApproverInput | LeaveRequestCreateOrConnectWithoutApproverInput[]
    createMany?: LeaveRequestCreateManyApproverInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LeaveBalanceCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveBalanceCreateWithoutUserInput, LeaveBalanceUncheckedCreateWithoutUserInput> | LeaveBalanceCreateWithoutUserInput[] | LeaveBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutUserInput | LeaveBalanceCreateOrConnectWithoutUserInput[]
    createMany?: LeaveBalanceCreateManyUserInputEnvelope
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type LeavePolicyCreateNestedManyWithoutCreatorInput = {
    create?: XOR<LeavePolicyCreateWithoutCreatorInput, LeavePolicyUncheckedCreateWithoutCreatorInput> | LeavePolicyCreateWithoutCreatorInput[] | LeavePolicyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LeavePolicyCreateOrConnectWithoutCreatorInput | LeavePolicyCreateOrConnectWithoutCreatorInput[]
    createMany?: LeavePolicyCreateManyCreatorInputEnvelope
    connect?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
  }

  export type HolidayCreateNestedManyWithoutCreatorInput = {
    create?: XOR<HolidayCreateWithoutCreatorInput, HolidayUncheckedCreateWithoutCreatorInput> | HolidayCreateWithoutCreatorInput[] | HolidayUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: HolidayCreateOrConnectWithoutCreatorInput | HolidayCreateOrConnectWithoutCreatorInput[]
    createMany?: HolidayCreateManyCreatorInputEnvelope
    connect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceRecordCreateWithoutUserInput, AttendanceRecordUncheckedCreateWithoutUserInput> | AttendanceRecordCreateWithoutUserInput[] | AttendanceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutUserInput | AttendanceRecordCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceRecordCreateManyUserInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type AttendancePolicyCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AttendancePolicyCreateWithoutCreatorInput, AttendancePolicyUncheckedCreateWithoutCreatorInput> | AttendancePolicyCreateWithoutCreatorInput[] | AttendancePolicyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AttendancePolicyCreateOrConnectWithoutCreatorInput | AttendancePolicyCreateOrConnectWithoutCreatorInput[]
    createMany?: AttendancePolicyCreateManyCreatorInputEnvelope
    connect?: AttendancePolicyWhereUniqueInput | AttendancePolicyWhereUniqueInput[]
  }

  export type EmployeeSalaryCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeSalaryCreateWithoutUserInput, EmployeeSalaryUncheckedCreateWithoutUserInput> | EmployeeSalaryCreateWithoutUserInput[] | EmployeeSalaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeSalaryCreateOrConnectWithoutUserInput | EmployeeSalaryCreateOrConnectWithoutUserInput[]
    createMany?: EmployeeSalaryCreateManyUserInputEnvelope
    connect?: EmployeeSalaryWhereUniqueInput | EmployeeSalaryWhereUniqueInput[]
  }

  export type MonthlySalaryCreateNestedManyWithoutUserInput = {
    create?: XOR<MonthlySalaryCreateWithoutUserInput, MonthlySalaryUncheckedCreateWithoutUserInput> | MonthlySalaryCreateWithoutUserInput[] | MonthlySalaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutUserInput | MonthlySalaryCreateOrConnectWithoutUserInput[]
    createMany?: MonthlySalaryCreateManyUserInputEnvelope
    connect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
  }

  export type MonthlySalaryCreateNestedManyWithoutApproverInput = {
    create?: XOR<MonthlySalaryCreateWithoutApproverInput, MonthlySalaryUncheckedCreateWithoutApproverInput> | MonthlySalaryCreateWithoutApproverInput[] | MonthlySalaryUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutApproverInput | MonthlySalaryCreateOrConnectWithoutApproverInput[]
    createMany?: MonthlySalaryCreateManyApproverInputEnvelope
    connect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput> | LeaveRequestCreateWithoutUserInput[] | LeaveRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutUserInput | LeaveRequestCreateOrConnectWithoutUserInput[]
    createMany?: LeaveRequestCreateManyUserInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<LeaveRequestCreateWithoutApproverInput, LeaveRequestUncheckedCreateWithoutApproverInput> | LeaveRequestCreateWithoutApproverInput[] | LeaveRequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutApproverInput | LeaveRequestCreateOrConnectWithoutApproverInput[]
    createMany?: LeaveRequestCreateManyApproverInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LeaveBalanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveBalanceCreateWithoutUserInput, LeaveBalanceUncheckedCreateWithoutUserInput> | LeaveBalanceCreateWithoutUserInput[] | LeaveBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutUserInput | LeaveBalanceCreateOrConnectWithoutUserInput[]
    createMany?: LeaveBalanceCreateManyUserInputEnvelope
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<LeavePolicyCreateWithoutCreatorInput, LeavePolicyUncheckedCreateWithoutCreatorInput> | LeavePolicyCreateWithoutCreatorInput[] | LeavePolicyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LeavePolicyCreateOrConnectWithoutCreatorInput | LeavePolicyCreateOrConnectWithoutCreatorInput[]
    createMany?: LeavePolicyCreateManyCreatorInputEnvelope
    connect?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
  }

  export type HolidayUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<HolidayCreateWithoutCreatorInput, HolidayUncheckedCreateWithoutCreatorInput> | HolidayCreateWithoutCreatorInput[] | HolidayUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: HolidayCreateOrConnectWithoutCreatorInput | HolidayCreateOrConnectWithoutCreatorInput[]
    createMany?: HolidayCreateManyCreatorInputEnvelope
    connect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceRecordCreateWithoutUserInput, AttendanceRecordUncheckedCreateWithoutUserInput> | AttendanceRecordCreateWithoutUserInput[] | AttendanceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutUserInput | AttendanceRecordCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceRecordCreateManyUserInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AttendancePolicyCreateWithoutCreatorInput, AttendancePolicyUncheckedCreateWithoutCreatorInput> | AttendancePolicyCreateWithoutCreatorInput[] | AttendancePolicyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AttendancePolicyCreateOrConnectWithoutCreatorInput | AttendancePolicyCreateOrConnectWithoutCreatorInput[]
    createMany?: AttendancePolicyCreateManyCreatorInputEnvelope
    connect?: AttendancePolicyWhereUniqueInput | AttendancePolicyWhereUniqueInput[]
  }

  export type EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeSalaryCreateWithoutUserInput, EmployeeSalaryUncheckedCreateWithoutUserInput> | EmployeeSalaryCreateWithoutUserInput[] | EmployeeSalaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeSalaryCreateOrConnectWithoutUserInput | EmployeeSalaryCreateOrConnectWithoutUserInput[]
    createMany?: EmployeeSalaryCreateManyUserInputEnvelope
    connect?: EmployeeSalaryWhereUniqueInput | EmployeeSalaryWhereUniqueInput[]
  }

  export type MonthlySalaryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MonthlySalaryCreateWithoutUserInput, MonthlySalaryUncheckedCreateWithoutUserInput> | MonthlySalaryCreateWithoutUserInput[] | MonthlySalaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutUserInput | MonthlySalaryCreateOrConnectWithoutUserInput[]
    createMany?: MonthlySalaryCreateManyUserInputEnvelope
    connect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
  }

  export type MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<MonthlySalaryCreateWithoutApproverInput, MonthlySalaryUncheckedCreateWithoutApproverInput> | MonthlySalaryCreateWithoutApproverInput[] | MonthlySalaryUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutApproverInput | MonthlySalaryCreateOrConnectWithoutApproverInput[]
    createMany?: MonthlySalaryCreateManyApproverInputEnvelope
    connect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneWithoutSubordinatesNestedInput = {
    create?: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubordinatesInput
    upsert?: UserUpsertWithoutSubordinatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubordinatesInput, UserUpdateWithoutSubordinatesInput>, UserUncheckedUpdateWithoutSubordinatesInput>
  }

  export type UserUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput> | LeaveRequestCreateWithoutUserInput[] | LeaveRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutUserInput | LeaveRequestCreateOrConnectWithoutUserInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutUserInput | LeaveRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaveRequestCreateManyUserInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutUserInput | LeaveRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutUserInput | LeaveRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutApproverNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutApproverInput, LeaveRequestUncheckedCreateWithoutApproverInput> | LeaveRequestCreateWithoutApproverInput[] | LeaveRequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutApproverInput | LeaveRequestCreateOrConnectWithoutApproverInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutApproverInput | LeaveRequestUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: LeaveRequestCreateManyApproverInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutApproverInput | LeaveRequestUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutApproverInput | LeaveRequestUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LeaveBalanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutUserInput, LeaveBalanceUncheckedCreateWithoutUserInput> | LeaveBalanceCreateWithoutUserInput[] | LeaveBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutUserInput | LeaveBalanceCreateOrConnectWithoutUserInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutUserInput | LeaveBalanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaveBalanceCreateManyUserInputEnvelope
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutUserInput | LeaveBalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutUserInput | LeaveBalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type LeavePolicyUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<LeavePolicyCreateWithoutCreatorInput, LeavePolicyUncheckedCreateWithoutCreatorInput> | LeavePolicyCreateWithoutCreatorInput[] | LeavePolicyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LeavePolicyCreateOrConnectWithoutCreatorInput | LeavePolicyCreateOrConnectWithoutCreatorInput[]
    upsert?: LeavePolicyUpsertWithWhereUniqueWithoutCreatorInput | LeavePolicyUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: LeavePolicyCreateManyCreatorInputEnvelope
    set?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    disconnect?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    delete?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    connect?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    update?: LeavePolicyUpdateWithWhereUniqueWithoutCreatorInput | LeavePolicyUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: LeavePolicyUpdateManyWithWhereWithoutCreatorInput | LeavePolicyUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: LeavePolicyScalarWhereInput | LeavePolicyScalarWhereInput[]
  }

  export type HolidayUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<HolidayCreateWithoutCreatorInput, HolidayUncheckedCreateWithoutCreatorInput> | HolidayCreateWithoutCreatorInput[] | HolidayUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: HolidayCreateOrConnectWithoutCreatorInput | HolidayCreateOrConnectWithoutCreatorInput[]
    upsert?: HolidayUpsertWithWhereUniqueWithoutCreatorInput | HolidayUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: HolidayCreateManyCreatorInputEnvelope
    set?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    disconnect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    delete?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    connect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    update?: HolidayUpdateWithWhereUniqueWithoutCreatorInput | HolidayUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: HolidayUpdateManyWithWhereWithoutCreatorInput | HolidayUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: HolidayScalarWhereInput | HolidayScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutUserInput, AttendanceRecordUncheckedCreateWithoutUserInput> | AttendanceRecordCreateWithoutUserInput[] | AttendanceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutUserInput | AttendanceRecordCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutUserInput | AttendanceRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceRecordCreateManyUserInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutUserInput | AttendanceRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutUserInput | AttendanceRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type AttendancePolicyUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AttendancePolicyCreateWithoutCreatorInput, AttendancePolicyUncheckedCreateWithoutCreatorInput> | AttendancePolicyCreateWithoutCreatorInput[] | AttendancePolicyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AttendancePolicyCreateOrConnectWithoutCreatorInput | AttendancePolicyCreateOrConnectWithoutCreatorInput[]
    upsert?: AttendancePolicyUpsertWithWhereUniqueWithoutCreatorInput | AttendancePolicyUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AttendancePolicyCreateManyCreatorInputEnvelope
    set?: AttendancePolicyWhereUniqueInput | AttendancePolicyWhereUniqueInput[]
    disconnect?: AttendancePolicyWhereUniqueInput | AttendancePolicyWhereUniqueInput[]
    delete?: AttendancePolicyWhereUniqueInput | AttendancePolicyWhereUniqueInput[]
    connect?: AttendancePolicyWhereUniqueInput | AttendancePolicyWhereUniqueInput[]
    update?: AttendancePolicyUpdateWithWhereUniqueWithoutCreatorInput | AttendancePolicyUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AttendancePolicyUpdateManyWithWhereWithoutCreatorInput | AttendancePolicyUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AttendancePolicyScalarWhereInput | AttendancePolicyScalarWhereInput[]
  }

  export type EmployeeSalaryUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeSalaryCreateWithoutUserInput, EmployeeSalaryUncheckedCreateWithoutUserInput> | EmployeeSalaryCreateWithoutUserInput[] | EmployeeSalaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeSalaryCreateOrConnectWithoutUserInput | EmployeeSalaryCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeSalaryUpsertWithWhereUniqueWithoutUserInput | EmployeeSalaryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmployeeSalaryCreateManyUserInputEnvelope
    set?: EmployeeSalaryWhereUniqueInput | EmployeeSalaryWhereUniqueInput[]
    disconnect?: EmployeeSalaryWhereUniqueInput | EmployeeSalaryWhereUniqueInput[]
    delete?: EmployeeSalaryWhereUniqueInput | EmployeeSalaryWhereUniqueInput[]
    connect?: EmployeeSalaryWhereUniqueInput | EmployeeSalaryWhereUniqueInput[]
    update?: EmployeeSalaryUpdateWithWhereUniqueWithoutUserInput | EmployeeSalaryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeSalaryUpdateManyWithWhereWithoutUserInput | EmployeeSalaryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeSalaryScalarWhereInput | EmployeeSalaryScalarWhereInput[]
  }

  export type MonthlySalaryUpdateManyWithoutUserNestedInput = {
    create?: XOR<MonthlySalaryCreateWithoutUserInput, MonthlySalaryUncheckedCreateWithoutUserInput> | MonthlySalaryCreateWithoutUserInput[] | MonthlySalaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutUserInput | MonthlySalaryCreateOrConnectWithoutUserInput[]
    upsert?: MonthlySalaryUpsertWithWhereUniqueWithoutUserInput | MonthlySalaryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MonthlySalaryCreateManyUserInputEnvelope
    set?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    disconnect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    delete?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    connect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    update?: MonthlySalaryUpdateWithWhereUniqueWithoutUserInput | MonthlySalaryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MonthlySalaryUpdateManyWithWhereWithoutUserInput | MonthlySalaryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MonthlySalaryScalarWhereInput | MonthlySalaryScalarWhereInput[]
  }

  export type MonthlySalaryUpdateManyWithoutApproverNestedInput = {
    create?: XOR<MonthlySalaryCreateWithoutApproverInput, MonthlySalaryUncheckedCreateWithoutApproverInput> | MonthlySalaryCreateWithoutApproverInput[] | MonthlySalaryUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutApproverInput | MonthlySalaryCreateOrConnectWithoutApproverInput[]
    upsert?: MonthlySalaryUpsertWithWhereUniqueWithoutApproverInput | MonthlySalaryUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: MonthlySalaryCreateManyApproverInputEnvelope
    set?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    disconnect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    delete?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    connect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    update?: MonthlySalaryUpdateWithWhereUniqueWithoutApproverInput | MonthlySalaryUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: MonthlySalaryUpdateManyWithWhereWithoutApproverInput | MonthlySalaryUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: MonthlySalaryScalarWhereInput | MonthlySalaryScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput> | LeaveRequestCreateWithoutUserInput[] | LeaveRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutUserInput | LeaveRequestCreateOrConnectWithoutUserInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutUserInput | LeaveRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaveRequestCreateManyUserInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutUserInput | LeaveRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutUserInput | LeaveRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutApproverInput, LeaveRequestUncheckedCreateWithoutApproverInput> | LeaveRequestCreateWithoutApproverInput[] | LeaveRequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutApproverInput | LeaveRequestCreateOrConnectWithoutApproverInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutApproverInput | LeaveRequestUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: LeaveRequestCreateManyApproverInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutApproverInput | LeaveRequestUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutApproverInput | LeaveRequestUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutUserInput, LeaveBalanceUncheckedCreateWithoutUserInput> | LeaveBalanceCreateWithoutUserInput[] | LeaveBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutUserInput | LeaveBalanceCreateOrConnectWithoutUserInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutUserInput | LeaveBalanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaveBalanceCreateManyUserInputEnvelope
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutUserInput | LeaveBalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutUserInput | LeaveBalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<LeavePolicyCreateWithoutCreatorInput, LeavePolicyUncheckedCreateWithoutCreatorInput> | LeavePolicyCreateWithoutCreatorInput[] | LeavePolicyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LeavePolicyCreateOrConnectWithoutCreatorInput | LeavePolicyCreateOrConnectWithoutCreatorInput[]
    upsert?: LeavePolicyUpsertWithWhereUniqueWithoutCreatorInput | LeavePolicyUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: LeavePolicyCreateManyCreatorInputEnvelope
    set?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    disconnect?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    delete?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    connect?: LeavePolicyWhereUniqueInput | LeavePolicyWhereUniqueInput[]
    update?: LeavePolicyUpdateWithWhereUniqueWithoutCreatorInput | LeavePolicyUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: LeavePolicyUpdateManyWithWhereWithoutCreatorInput | LeavePolicyUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: LeavePolicyScalarWhereInput | LeavePolicyScalarWhereInput[]
  }

  export type HolidayUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<HolidayCreateWithoutCreatorInput, HolidayUncheckedCreateWithoutCreatorInput> | HolidayCreateWithoutCreatorInput[] | HolidayUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: HolidayCreateOrConnectWithoutCreatorInput | HolidayCreateOrConnectWithoutCreatorInput[]
    upsert?: HolidayUpsertWithWhereUniqueWithoutCreatorInput | HolidayUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: HolidayCreateManyCreatorInputEnvelope
    set?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    disconnect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    delete?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    connect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    update?: HolidayUpdateWithWhereUniqueWithoutCreatorInput | HolidayUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: HolidayUpdateManyWithWhereWithoutCreatorInput | HolidayUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: HolidayScalarWhereInput | HolidayScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutUserInput, AttendanceRecordUncheckedCreateWithoutUserInput> | AttendanceRecordCreateWithoutUserInput[] | AttendanceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutUserInput | AttendanceRecordCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutUserInput | AttendanceRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceRecordCreateManyUserInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutUserInput | AttendanceRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutUserInput | AttendanceRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AttendancePolicyCreateWithoutCreatorInput, AttendancePolicyUncheckedCreateWithoutCreatorInput> | AttendancePolicyCreateWithoutCreatorInput[] | AttendancePolicyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AttendancePolicyCreateOrConnectWithoutCreatorInput | AttendancePolicyCreateOrConnectWithoutCreatorInput[]
    upsert?: AttendancePolicyUpsertWithWhereUniqueWithoutCreatorInput | AttendancePolicyUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AttendancePolicyCreateManyCreatorInputEnvelope
    set?: AttendancePolicyWhereUniqueInput | AttendancePolicyWhereUniqueInput[]
    disconnect?: AttendancePolicyWhereUniqueInput | AttendancePolicyWhereUniqueInput[]
    delete?: AttendancePolicyWhereUniqueInput | AttendancePolicyWhereUniqueInput[]
    connect?: AttendancePolicyWhereUniqueInput | AttendancePolicyWhereUniqueInput[]
    update?: AttendancePolicyUpdateWithWhereUniqueWithoutCreatorInput | AttendancePolicyUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AttendancePolicyUpdateManyWithWhereWithoutCreatorInput | AttendancePolicyUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AttendancePolicyScalarWhereInput | AttendancePolicyScalarWhereInput[]
  }

  export type EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeSalaryCreateWithoutUserInput, EmployeeSalaryUncheckedCreateWithoutUserInput> | EmployeeSalaryCreateWithoutUserInput[] | EmployeeSalaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeSalaryCreateOrConnectWithoutUserInput | EmployeeSalaryCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeSalaryUpsertWithWhereUniqueWithoutUserInput | EmployeeSalaryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmployeeSalaryCreateManyUserInputEnvelope
    set?: EmployeeSalaryWhereUniqueInput | EmployeeSalaryWhereUniqueInput[]
    disconnect?: EmployeeSalaryWhereUniqueInput | EmployeeSalaryWhereUniqueInput[]
    delete?: EmployeeSalaryWhereUniqueInput | EmployeeSalaryWhereUniqueInput[]
    connect?: EmployeeSalaryWhereUniqueInput | EmployeeSalaryWhereUniqueInput[]
    update?: EmployeeSalaryUpdateWithWhereUniqueWithoutUserInput | EmployeeSalaryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeSalaryUpdateManyWithWhereWithoutUserInput | EmployeeSalaryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeSalaryScalarWhereInput | EmployeeSalaryScalarWhereInput[]
  }

  export type MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MonthlySalaryCreateWithoutUserInput, MonthlySalaryUncheckedCreateWithoutUserInput> | MonthlySalaryCreateWithoutUserInput[] | MonthlySalaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutUserInput | MonthlySalaryCreateOrConnectWithoutUserInput[]
    upsert?: MonthlySalaryUpsertWithWhereUniqueWithoutUserInput | MonthlySalaryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MonthlySalaryCreateManyUserInputEnvelope
    set?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    disconnect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    delete?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    connect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    update?: MonthlySalaryUpdateWithWhereUniqueWithoutUserInput | MonthlySalaryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MonthlySalaryUpdateManyWithWhereWithoutUserInput | MonthlySalaryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MonthlySalaryScalarWhereInput | MonthlySalaryScalarWhereInput[]
  }

  export type MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<MonthlySalaryCreateWithoutApproverInput, MonthlySalaryUncheckedCreateWithoutApproverInput> | MonthlySalaryCreateWithoutApproverInput[] | MonthlySalaryUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutApproverInput | MonthlySalaryCreateOrConnectWithoutApproverInput[]
    upsert?: MonthlySalaryUpsertWithWhereUniqueWithoutApproverInput | MonthlySalaryUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: MonthlySalaryCreateManyApproverInputEnvelope
    set?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    disconnect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    delete?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    connect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    update?: MonthlySalaryUpdateWithWhereUniqueWithoutApproverInput | MonthlySalaryUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: MonthlySalaryUpdateManyWithWhereWithoutApproverInput | MonthlySalaryUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: MonthlySalaryScalarWhereInput | MonthlySalaryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLeaveRequestsInput = {
    create?: XOR<UserCreateWithoutLeaveRequestsInput, UserUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedLeavesInput = {
    create?: XOR<UserCreateWithoutApprovedLeavesInput, UserUncheckedCreateWithoutApprovedLeavesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedLeavesInput
    connect?: UserWhereUniqueInput
  }

  export type LeaveDocumentCreateNestedManyWithoutLeaveRequestInput = {
    create?: XOR<LeaveDocumentCreateWithoutLeaveRequestInput, LeaveDocumentUncheckedCreateWithoutLeaveRequestInput> | LeaveDocumentCreateWithoutLeaveRequestInput[] | LeaveDocumentUncheckedCreateWithoutLeaveRequestInput[]
    connectOrCreate?: LeaveDocumentCreateOrConnectWithoutLeaveRequestInput | LeaveDocumentCreateOrConnectWithoutLeaveRequestInput[]
    createMany?: LeaveDocumentCreateManyLeaveRequestInputEnvelope
    connect?: LeaveDocumentWhereUniqueInput | LeaveDocumentWhereUniqueInput[]
  }

  export type SalaryDeductionCreateNestedManyWithoutLeaveRequestInput = {
    create?: XOR<SalaryDeductionCreateWithoutLeaveRequestInput, SalaryDeductionUncheckedCreateWithoutLeaveRequestInput> | SalaryDeductionCreateWithoutLeaveRequestInput[] | SalaryDeductionUncheckedCreateWithoutLeaveRequestInput[]
    connectOrCreate?: SalaryDeductionCreateOrConnectWithoutLeaveRequestInput | SalaryDeductionCreateOrConnectWithoutLeaveRequestInput[]
    createMany?: SalaryDeductionCreateManyLeaveRequestInputEnvelope
    connect?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
  }

  export type LeaveDocumentUncheckedCreateNestedManyWithoutLeaveRequestInput = {
    create?: XOR<LeaveDocumentCreateWithoutLeaveRequestInput, LeaveDocumentUncheckedCreateWithoutLeaveRequestInput> | LeaveDocumentCreateWithoutLeaveRequestInput[] | LeaveDocumentUncheckedCreateWithoutLeaveRequestInput[]
    connectOrCreate?: LeaveDocumentCreateOrConnectWithoutLeaveRequestInput | LeaveDocumentCreateOrConnectWithoutLeaveRequestInput[]
    createMany?: LeaveDocumentCreateManyLeaveRequestInputEnvelope
    connect?: LeaveDocumentWhereUniqueInput | LeaveDocumentWhereUniqueInput[]
  }

  export type SalaryDeductionUncheckedCreateNestedManyWithoutLeaveRequestInput = {
    create?: XOR<SalaryDeductionCreateWithoutLeaveRequestInput, SalaryDeductionUncheckedCreateWithoutLeaveRequestInput> | SalaryDeductionCreateWithoutLeaveRequestInput[] | SalaryDeductionUncheckedCreateWithoutLeaveRequestInput[]
    connectOrCreate?: SalaryDeductionCreateOrConnectWithoutLeaveRequestInput | SalaryDeductionCreateOrConnectWithoutLeaveRequestInput[]
    createMany?: SalaryDeductionCreateManyLeaveRequestInputEnvelope
    connect?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
  }

  export type EnumLeaveTypeFieldUpdateOperationsInput = {
    set?: $Enums.LeaveType
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumLeaveStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStatus
  }

  export type NullableEnumHalfDayPeriodFieldUpdateOperationsInput = {
    set?: $Enums.HalfDayPeriod | null
  }

  export type UserUpdateOneRequiredWithoutLeaveRequestsNestedInput = {
    create?: XOR<UserCreateWithoutLeaveRequestsInput, UserUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveRequestsInput
    upsert?: UserUpsertWithoutLeaveRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaveRequestsInput, UserUpdateWithoutLeaveRequestsInput>, UserUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type UserUpdateOneWithoutApprovedLeavesNestedInput = {
    create?: XOR<UserCreateWithoutApprovedLeavesInput, UserUncheckedCreateWithoutApprovedLeavesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedLeavesInput
    upsert?: UserUpsertWithoutApprovedLeavesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedLeavesInput, UserUpdateWithoutApprovedLeavesInput>, UserUncheckedUpdateWithoutApprovedLeavesInput>
  }

  export type LeaveDocumentUpdateManyWithoutLeaveRequestNestedInput = {
    create?: XOR<LeaveDocumentCreateWithoutLeaveRequestInput, LeaveDocumentUncheckedCreateWithoutLeaveRequestInput> | LeaveDocumentCreateWithoutLeaveRequestInput[] | LeaveDocumentUncheckedCreateWithoutLeaveRequestInput[]
    connectOrCreate?: LeaveDocumentCreateOrConnectWithoutLeaveRequestInput | LeaveDocumentCreateOrConnectWithoutLeaveRequestInput[]
    upsert?: LeaveDocumentUpsertWithWhereUniqueWithoutLeaveRequestInput | LeaveDocumentUpsertWithWhereUniqueWithoutLeaveRequestInput[]
    createMany?: LeaveDocumentCreateManyLeaveRequestInputEnvelope
    set?: LeaveDocumentWhereUniqueInput | LeaveDocumentWhereUniqueInput[]
    disconnect?: LeaveDocumentWhereUniqueInput | LeaveDocumentWhereUniqueInput[]
    delete?: LeaveDocumentWhereUniqueInput | LeaveDocumentWhereUniqueInput[]
    connect?: LeaveDocumentWhereUniqueInput | LeaveDocumentWhereUniqueInput[]
    update?: LeaveDocumentUpdateWithWhereUniqueWithoutLeaveRequestInput | LeaveDocumentUpdateWithWhereUniqueWithoutLeaveRequestInput[]
    updateMany?: LeaveDocumentUpdateManyWithWhereWithoutLeaveRequestInput | LeaveDocumentUpdateManyWithWhereWithoutLeaveRequestInput[]
    deleteMany?: LeaveDocumentScalarWhereInput | LeaveDocumentScalarWhereInput[]
  }

  export type SalaryDeductionUpdateManyWithoutLeaveRequestNestedInput = {
    create?: XOR<SalaryDeductionCreateWithoutLeaveRequestInput, SalaryDeductionUncheckedCreateWithoutLeaveRequestInput> | SalaryDeductionCreateWithoutLeaveRequestInput[] | SalaryDeductionUncheckedCreateWithoutLeaveRequestInput[]
    connectOrCreate?: SalaryDeductionCreateOrConnectWithoutLeaveRequestInput | SalaryDeductionCreateOrConnectWithoutLeaveRequestInput[]
    upsert?: SalaryDeductionUpsertWithWhereUniqueWithoutLeaveRequestInput | SalaryDeductionUpsertWithWhereUniqueWithoutLeaveRequestInput[]
    createMany?: SalaryDeductionCreateManyLeaveRequestInputEnvelope
    set?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    disconnect?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    delete?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    connect?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    update?: SalaryDeductionUpdateWithWhereUniqueWithoutLeaveRequestInput | SalaryDeductionUpdateWithWhereUniqueWithoutLeaveRequestInput[]
    updateMany?: SalaryDeductionUpdateManyWithWhereWithoutLeaveRequestInput | SalaryDeductionUpdateManyWithWhereWithoutLeaveRequestInput[]
    deleteMany?: SalaryDeductionScalarWhereInput | SalaryDeductionScalarWhereInput[]
  }

  export type LeaveDocumentUncheckedUpdateManyWithoutLeaveRequestNestedInput = {
    create?: XOR<LeaveDocumentCreateWithoutLeaveRequestInput, LeaveDocumentUncheckedCreateWithoutLeaveRequestInput> | LeaveDocumentCreateWithoutLeaveRequestInput[] | LeaveDocumentUncheckedCreateWithoutLeaveRequestInput[]
    connectOrCreate?: LeaveDocumentCreateOrConnectWithoutLeaveRequestInput | LeaveDocumentCreateOrConnectWithoutLeaveRequestInput[]
    upsert?: LeaveDocumentUpsertWithWhereUniqueWithoutLeaveRequestInput | LeaveDocumentUpsertWithWhereUniqueWithoutLeaveRequestInput[]
    createMany?: LeaveDocumentCreateManyLeaveRequestInputEnvelope
    set?: LeaveDocumentWhereUniqueInput | LeaveDocumentWhereUniqueInput[]
    disconnect?: LeaveDocumentWhereUniqueInput | LeaveDocumentWhereUniqueInput[]
    delete?: LeaveDocumentWhereUniqueInput | LeaveDocumentWhereUniqueInput[]
    connect?: LeaveDocumentWhereUniqueInput | LeaveDocumentWhereUniqueInput[]
    update?: LeaveDocumentUpdateWithWhereUniqueWithoutLeaveRequestInput | LeaveDocumentUpdateWithWhereUniqueWithoutLeaveRequestInput[]
    updateMany?: LeaveDocumentUpdateManyWithWhereWithoutLeaveRequestInput | LeaveDocumentUpdateManyWithWhereWithoutLeaveRequestInput[]
    deleteMany?: LeaveDocumentScalarWhereInput | LeaveDocumentScalarWhereInput[]
  }

  export type SalaryDeductionUncheckedUpdateManyWithoutLeaveRequestNestedInput = {
    create?: XOR<SalaryDeductionCreateWithoutLeaveRequestInput, SalaryDeductionUncheckedCreateWithoutLeaveRequestInput> | SalaryDeductionCreateWithoutLeaveRequestInput[] | SalaryDeductionUncheckedCreateWithoutLeaveRequestInput[]
    connectOrCreate?: SalaryDeductionCreateOrConnectWithoutLeaveRequestInput | SalaryDeductionCreateOrConnectWithoutLeaveRequestInput[]
    upsert?: SalaryDeductionUpsertWithWhereUniqueWithoutLeaveRequestInput | SalaryDeductionUpsertWithWhereUniqueWithoutLeaveRequestInput[]
    createMany?: SalaryDeductionCreateManyLeaveRequestInputEnvelope
    set?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    disconnect?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    delete?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    connect?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    update?: SalaryDeductionUpdateWithWhereUniqueWithoutLeaveRequestInput | SalaryDeductionUpdateWithWhereUniqueWithoutLeaveRequestInput[]
    updateMany?: SalaryDeductionUpdateManyWithWhereWithoutLeaveRequestInput | SalaryDeductionUpdateManyWithWhereWithoutLeaveRequestInput[]
    deleteMany?: SalaryDeductionScalarWhereInput | SalaryDeductionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLeaveBalancesInput = {
    create?: XOR<UserCreateWithoutLeaveBalancesInput, UserUncheckedCreateWithoutLeaveBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveBalancesInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutLeaveBalancesNestedInput = {
    create?: XOR<UserCreateWithoutLeaveBalancesInput, UserUncheckedCreateWithoutLeaveBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveBalancesInput
    upsert?: UserUpsertWithoutLeaveBalancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaveBalancesInput, UserUpdateWithoutLeaveBalancesInput>, UserUncheckedUpdateWithoutLeaveBalancesInput>
  }

  export type UserCreateNestedOneWithoutCreatedPoliciesInput = {
    create?: XOR<UserCreateWithoutCreatedPoliciesInput, UserUncheckedCreateWithoutCreatedPoliciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPoliciesInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCreatedPoliciesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPoliciesInput, UserUncheckedCreateWithoutCreatedPoliciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPoliciesInput
    upsert?: UserUpsertWithoutCreatedPoliciesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPoliciesInput, UserUpdateWithoutCreatedPoliciesInput>, UserUncheckedUpdateWithoutCreatedPoliciesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type LeaveRequestCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<LeaveRequestCreateWithoutDocumentsInput, LeaveRequestUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutDocumentsInput
    connect?: LeaveRequestWhereUniqueInput
  }

  export type LeaveRequestUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutDocumentsInput, LeaveRequestUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutDocumentsInput
    upsert?: LeaveRequestUpsertWithoutDocumentsInput
    connect?: LeaveRequestWhereUniqueInput
    update?: XOR<XOR<LeaveRequestUpdateToOneWithWhereWithoutDocumentsInput, LeaveRequestUpdateWithoutDocumentsInput>, LeaveRequestUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserCreateNestedOneWithoutCreatedHolidaysInput = {
    create?: XOR<UserCreateWithoutCreatedHolidaysInput, UserUncheckedCreateWithoutCreatedHolidaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedHolidaysInput
    connect?: UserWhereUniqueInput
  }

  export type EnumHolidayTypeFieldUpdateOperationsInput = {
    set?: $Enums.HolidayType
  }

  export type UserUpdateOneRequiredWithoutCreatedHolidaysNestedInput = {
    create?: XOR<UserCreateWithoutCreatedHolidaysInput, UserUncheckedCreateWithoutCreatedHolidaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedHolidaysInput
    upsert?: UserUpsertWithoutCreatedHolidaysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedHolidaysInput, UserUpdateWithoutCreatedHolidaysInput>, UserUncheckedUpdateWithoutCreatedHolidaysInput>
  }

  export type UserCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<UserCreateWithoutAttendanceRecordsInput, UserUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type UserUpdateOneRequiredWithoutAttendanceRecordsNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceRecordsInput, UserUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: UserUpsertWithoutAttendanceRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceRecordsInput, UserUpdateWithoutAttendanceRecordsInput>, UserUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type UserCreateNestedOneWithoutCreatedAttendancePoliciesInput = {
    create?: XOR<UserCreateWithoutCreatedAttendancePoliciesInput, UserUncheckedCreateWithoutCreatedAttendancePoliciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAttendancePoliciesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCreatedAttendancePoliciesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedAttendancePoliciesInput, UserUncheckedCreateWithoutCreatedAttendancePoliciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAttendancePoliciesInput
    upsert?: UserUpsertWithoutCreatedAttendancePoliciesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedAttendancePoliciesInput, UserUpdateWithoutCreatedAttendancePoliciesInput>, UserUncheckedUpdateWithoutCreatedAttendancePoliciesInput>
  }

  export type UserCreateNestedOneWithoutEmployeeSalaryInput = {
    create?: XOR<UserCreateWithoutEmployeeSalaryInput, UserUncheckedCreateWithoutEmployeeSalaryInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeSalaryInput
    connect?: UserWhereUniqueInput
  }

  export type MonthlySalaryCreateNestedManyWithoutEmployeeSalaryInput = {
    create?: XOR<MonthlySalaryCreateWithoutEmployeeSalaryInput, MonthlySalaryUncheckedCreateWithoutEmployeeSalaryInput> | MonthlySalaryCreateWithoutEmployeeSalaryInput[] | MonthlySalaryUncheckedCreateWithoutEmployeeSalaryInput[]
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutEmployeeSalaryInput | MonthlySalaryCreateOrConnectWithoutEmployeeSalaryInput[]
    createMany?: MonthlySalaryCreateManyEmployeeSalaryInputEnvelope
    connect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
  }

  export type MonthlySalaryUncheckedCreateNestedManyWithoutEmployeeSalaryInput = {
    create?: XOR<MonthlySalaryCreateWithoutEmployeeSalaryInput, MonthlySalaryUncheckedCreateWithoutEmployeeSalaryInput> | MonthlySalaryCreateWithoutEmployeeSalaryInput[] | MonthlySalaryUncheckedCreateWithoutEmployeeSalaryInput[]
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutEmployeeSalaryInput | MonthlySalaryCreateOrConnectWithoutEmployeeSalaryInput[]
    createMany?: MonthlySalaryCreateManyEmployeeSalaryInputEnvelope
    connect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutEmployeeSalaryNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeSalaryInput, UserUncheckedCreateWithoutEmployeeSalaryInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeSalaryInput
    upsert?: UserUpsertWithoutEmployeeSalaryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeSalaryInput, UserUpdateWithoutEmployeeSalaryInput>, UserUncheckedUpdateWithoutEmployeeSalaryInput>
  }

  export type MonthlySalaryUpdateManyWithoutEmployeeSalaryNestedInput = {
    create?: XOR<MonthlySalaryCreateWithoutEmployeeSalaryInput, MonthlySalaryUncheckedCreateWithoutEmployeeSalaryInput> | MonthlySalaryCreateWithoutEmployeeSalaryInput[] | MonthlySalaryUncheckedCreateWithoutEmployeeSalaryInput[]
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutEmployeeSalaryInput | MonthlySalaryCreateOrConnectWithoutEmployeeSalaryInput[]
    upsert?: MonthlySalaryUpsertWithWhereUniqueWithoutEmployeeSalaryInput | MonthlySalaryUpsertWithWhereUniqueWithoutEmployeeSalaryInput[]
    createMany?: MonthlySalaryCreateManyEmployeeSalaryInputEnvelope
    set?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    disconnect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    delete?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    connect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    update?: MonthlySalaryUpdateWithWhereUniqueWithoutEmployeeSalaryInput | MonthlySalaryUpdateWithWhereUniqueWithoutEmployeeSalaryInput[]
    updateMany?: MonthlySalaryUpdateManyWithWhereWithoutEmployeeSalaryInput | MonthlySalaryUpdateManyWithWhereWithoutEmployeeSalaryInput[]
    deleteMany?: MonthlySalaryScalarWhereInput | MonthlySalaryScalarWhereInput[]
  }

  export type MonthlySalaryUncheckedUpdateManyWithoutEmployeeSalaryNestedInput = {
    create?: XOR<MonthlySalaryCreateWithoutEmployeeSalaryInput, MonthlySalaryUncheckedCreateWithoutEmployeeSalaryInput> | MonthlySalaryCreateWithoutEmployeeSalaryInput[] | MonthlySalaryUncheckedCreateWithoutEmployeeSalaryInput[]
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutEmployeeSalaryInput | MonthlySalaryCreateOrConnectWithoutEmployeeSalaryInput[]
    upsert?: MonthlySalaryUpsertWithWhereUniqueWithoutEmployeeSalaryInput | MonthlySalaryUpsertWithWhereUniqueWithoutEmployeeSalaryInput[]
    createMany?: MonthlySalaryCreateManyEmployeeSalaryInputEnvelope
    set?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    disconnect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    delete?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    connect?: MonthlySalaryWhereUniqueInput | MonthlySalaryWhereUniqueInput[]
    update?: MonthlySalaryUpdateWithWhereUniqueWithoutEmployeeSalaryInput | MonthlySalaryUpdateWithWhereUniqueWithoutEmployeeSalaryInput[]
    updateMany?: MonthlySalaryUpdateManyWithWhereWithoutEmployeeSalaryInput | MonthlySalaryUpdateManyWithWhereWithoutEmployeeSalaryInput[]
    deleteMany?: MonthlySalaryScalarWhereInput | MonthlySalaryScalarWhereInput[]
  }

  export type EmployeeSalaryCreateNestedOneWithoutMonthlySalariesInput = {
    create?: XOR<EmployeeSalaryCreateWithoutMonthlySalariesInput, EmployeeSalaryUncheckedCreateWithoutMonthlySalariesInput>
    connectOrCreate?: EmployeeSalaryCreateOrConnectWithoutMonthlySalariesInput
    connect?: EmployeeSalaryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMonthlySalariesInput = {
    create?: XOR<UserCreateWithoutMonthlySalariesInput, UserUncheckedCreateWithoutMonthlySalariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMonthlySalariesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedSalariesInput = {
    create?: XOR<UserCreateWithoutApprovedSalariesInput, UserUncheckedCreateWithoutApprovedSalariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedSalariesInput
    connect?: UserWhereUniqueInput
  }

  export type SalaryDeductionCreateNestedManyWithoutMonthlySalaryInput = {
    create?: XOR<SalaryDeductionCreateWithoutMonthlySalaryInput, SalaryDeductionUncheckedCreateWithoutMonthlySalaryInput> | SalaryDeductionCreateWithoutMonthlySalaryInput[] | SalaryDeductionUncheckedCreateWithoutMonthlySalaryInput[]
    connectOrCreate?: SalaryDeductionCreateOrConnectWithoutMonthlySalaryInput | SalaryDeductionCreateOrConnectWithoutMonthlySalaryInput[]
    createMany?: SalaryDeductionCreateManyMonthlySalaryInputEnvelope
    connect?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
  }

  export type SalaryDeductionUncheckedCreateNestedManyWithoutMonthlySalaryInput = {
    create?: XOR<SalaryDeductionCreateWithoutMonthlySalaryInput, SalaryDeductionUncheckedCreateWithoutMonthlySalaryInput> | SalaryDeductionCreateWithoutMonthlySalaryInput[] | SalaryDeductionUncheckedCreateWithoutMonthlySalaryInput[]
    connectOrCreate?: SalaryDeductionCreateOrConnectWithoutMonthlySalaryInput | SalaryDeductionCreateOrConnectWithoutMonthlySalaryInput[]
    createMany?: SalaryDeductionCreateManyMonthlySalaryInputEnvelope
    connect?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
  }

  export type EnumSalaryStatusFieldUpdateOperationsInput = {
    set?: $Enums.SalaryStatus
  }

  export type EmployeeSalaryUpdateOneRequiredWithoutMonthlySalariesNestedInput = {
    create?: XOR<EmployeeSalaryCreateWithoutMonthlySalariesInput, EmployeeSalaryUncheckedCreateWithoutMonthlySalariesInput>
    connectOrCreate?: EmployeeSalaryCreateOrConnectWithoutMonthlySalariesInput
    upsert?: EmployeeSalaryUpsertWithoutMonthlySalariesInput
    connect?: EmployeeSalaryWhereUniqueInput
    update?: XOR<XOR<EmployeeSalaryUpdateToOneWithWhereWithoutMonthlySalariesInput, EmployeeSalaryUpdateWithoutMonthlySalariesInput>, EmployeeSalaryUncheckedUpdateWithoutMonthlySalariesInput>
  }

  export type UserUpdateOneRequiredWithoutMonthlySalariesNestedInput = {
    create?: XOR<UserCreateWithoutMonthlySalariesInput, UserUncheckedCreateWithoutMonthlySalariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMonthlySalariesInput
    upsert?: UserUpsertWithoutMonthlySalariesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMonthlySalariesInput, UserUpdateWithoutMonthlySalariesInput>, UserUncheckedUpdateWithoutMonthlySalariesInput>
  }

  export type UserUpdateOneWithoutApprovedSalariesNestedInput = {
    create?: XOR<UserCreateWithoutApprovedSalariesInput, UserUncheckedCreateWithoutApprovedSalariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedSalariesInput
    upsert?: UserUpsertWithoutApprovedSalariesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedSalariesInput, UserUpdateWithoutApprovedSalariesInput>, UserUncheckedUpdateWithoutApprovedSalariesInput>
  }

  export type SalaryDeductionUpdateManyWithoutMonthlySalaryNestedInput = {
    create?: XOR<SalaryDeductionCreateWithoutMonthlySalaryInput, SalaryDeductionUncheckedCreateWithoutMonthlySalaryInput> | SalaryDeductionCreateWithoutMonthlySalaryInput[] | SalaryDeductionUncheckedCreateWithoutMonthlySalaryInput[]
    connectOrCreate?: SalaryDeductionCreateOrConnectWithoutMonthlySalaryInput | SalaryDeductionCreateOrConnectWithoutMonthlySalaryInput[]
    upsert?: SalaryDeductionUpsertWithWhereUniqueWithoutMonthlySalaryInput | SalaryDeductionUpsertWithWhereUniqueWithoutMonthlySalaryInput[]
    createMany?: SalaryDeductionCreateManyMonthlySalaryInputEnvelope
    set?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    disconnect?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    delete?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    connect?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    update?: SalaryDeductionUpdateWithWhereUniqueWithoutMonthlySalaryInput | SalaryDeductionUpdateWithWhereUniqueWithoutMonthlySalaryInput[]
    updateMany?: SalaryDeductionUpdateManyWithWhereWithoutMonthlySalaryInput | SalaryDeductionUpdateManyWithWhereWithoutMonthlySalaryInput[]
    deleteMany?: SalaryDeductionScalarWhereInput | SalaryDeductionScalarWhereInput[]
  }

  export type SalaryDeductionUncheckedUpdateManyWithoutMonthlySalaryNestedInput = {
    create?: XOR<SalaryDeductionCreateWithoutMonthlySalaryInput, SalaryDeductionUncheckedCreateWithoutMonthlySalaryInput> | SalaryDeductionCreateWithoutMonthlySalaryInput[] | SalaryDeductionUncheckedCreateWithoutMonthlySalaryInput[]
    connectOrCreate?: SalaryDeductionCreateOrConnectWithoutMonthlySalaryInput | SalaryDeductionCreateOrConnectWithoutMonthlySalaryInput[]
    upsert?: SalaryDeductionUpsertWithWhereUniqueWithoutMonthlySalaryInput | SalaryDeductionUpsertWithWhereUniqueWithoutMonthlySalaryInput[]
    createMany?: SalaryDeductionCreateManyMonthlySalaryInputEnvelope
    set?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    disconnect?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    delete?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    connect?: SalaryDeductionWhereUniqueInput | SalaryDeductionWhereUniqueInput[]
    update?: SalaryDeductionUpdateWithWhereUniqueWithoutMonthlySalaryInput | SalaryDeductionUpdateWithWhereUniqueWithoutMonthlySalaryInput[]
    updateMany?: SalaryDeductionUpdateManyWithWhereWithoutMonthlySalaryInput | SalaryDeductionUpdateManyWithWhereWithoutMonthlySalaryInput[]
    deleteMany?: SalaryDeductionScalarWhereInput | SalaryDeductionScalarWhereInput[]
  }

  export type MonthlySalaryCreateNestedOneWithoutDeductionsInput = {
    create?: XOR<MonthlySalaryCreateWithoutDeductionsInput, MonthlySalaryUncheckedCreateWithoutDeductionsInput>
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutDeductionsInput
    connect?: MonthlySalaryWhereUniqueInput
  }

  export type LeaveRequestCreateNestedOneWithoutSalaryDeductionsInput = {
    create?: XOR<LeaveRequestCreateWithoutSalaryDeductionsInput, LeaveRequestUncheckedCreateWithoutSalaryDeductionsInput>
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutSalaryDeductionsInput
    connect?: LeaveRequestWhereUniqueInput
  }

  export type EnumDeductionTypeFieldUpdateOperationsInput = {
    set?: $Enums.DeductionType
  }

  export type MonthlySalaryUpdateOneRequiredWithoutDeductionsNestedInput = {
    create?: XOR<MonthlySalaryCreateWithoutDeductionsInput, MonthlySalaryUncheckedCreateWithoutDeductionsInput>
    connectOrCreate?: MonthlySalaryCreateOrConnectWithoutDeductionsInput
    upsert?: MonthlySalaryUpsertWithoutDeductionsInput
    connect?: MonthlySalaryWhereUniqueInput
    update?: XOR<XOR<MonthlySalaryUpdateToOneWithWhereWithoutDeductionsInput, MonthlySalaryUpdateWithoutDeductionsInput>, MonthlySalaryUncheckedUpdateWithoutDeductionsInput>
  }

  export type LeaveRequestUpdateOneWithoutSalaryDeductionsNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutSalaryDeductionsInput, LeaveRequestUncheckedCreateWithoutSalaryDeductionsInput>
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutSalaryDeductionsInput
    upsert?: LeaveRequestUpsertWithoutSalaryDeductionsInput
    disconnect?: LeaveRequestWhereInput | boolean
    delete?: LeaveRequestWhereInput | boolean
    connect?: LeaveRequestWhereUniqueInput
    update?: XOR<XOR<LeaveRequestUpdateToOneWithWhereWithoutSalaryDeductionsInput, LeaveRequestUpdateWithoutSalaryDeductionsInput>, LeaveRequestUncheckedUpdateWithoutSalaryDeductionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type NestedEnumHalfDayPeriodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.HalfDayPeriod | EnumHalfDayPeriodFieldRefInput<$PrismaModel> | null
    in?: $Enums.HalfDayPeriod[] | ListEnumHalfDayPeriodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HalfDayPeriod[] | ListEnumHalfDayPeriodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHalfDayPeriodNullableFilter<$PrismaModel> | $Enums.HalfDayPeriod | null
  }

  export type NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type NestedEnumHalfDayPeriodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HalfDayPeriod | EnumHalfDayPeriodFieldRefInput<$PrismaModel> | null
    in?: $Enums.HalfDayPeriod[] | ListEnumHalfDayPeriodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HalfDayPeriod[] | ListEnumHalfDayPeriodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHalfDayPeriodNullableWithAggregatesFilter<$PrismaModel> | $Enums.HalfDayPeriod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumHalfDayPeriodNullableFilter<$PrismaModel>
    _max?: NestedEnumHalfDayPeriodNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumHolidayTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.HolidayType | EnumHolidayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HolidayType[] | ListEnumHolidayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HolidayType[] | ListEnumHolidayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHolidayTypeFilter<$PrismaModel> | $Enums.HolidayType
  }

  export type NestedEnumHolidayTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HolidayType | EnumHolidayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HolidayType[] | ListEnumHolidayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HolidayType[] | ListEnumHolidayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHolidayTypeWithAggregatesFilter<$PrismaModel> | $Enums.HolidayType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHolidayTypeFilter<$PrismaModel>
    _max?: NestedEnumHolidayTypeFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumSalaryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryStatus | EnumSalaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryStatusFilter<$PrismaModel> | $Enums.SalaryStatus
  }

  export type NestedEnumSalaryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryStatus | EnumSalaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryStatusWithAggregatesFilter<$PrismaModel> | $Enums.SalaryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalaryStatusFilter<$PrismaModel>
    _max?: NestedEnumSalaryStatusFilter<$PrismaModel>
  }

  export type NestedEnumDeductionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeductionType | EnumDeductionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeductionType[] | ListEnumDeductionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeductionType[] | ListEnumDeductionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeductionTypeFilter<$PrismaModel> | $Enums.DeductionType
  }

  export type NestedEnumDeductionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeductionType | EnumDeductionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeductionType[] | ListEnumDeductionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeductionType[] | ListEnumDeductionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeductionTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeductionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeductionTypeFilter<$PrismaModel>
    _max?: NestedEnumDeductionTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutSubordinatesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutSubordinatesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutSubordinatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
  }

  export type UserCreateWithoutManagerInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutManagerInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserCreateManyManagerInputEnvelope = {
    data: UserCreateManyManagerInput | UserCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutUserInput = {
    id?: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutApprovedLeavesInput
    documents?: LeaveDocumentCreateNestedManyWithoutLeaveRequestInput
    salaryDeductions?: SalaryDeductionCreateNestedManyWithoutLeaveRequestInput
  }

  export type LeaveRequestUncheckedCreateWithoutUserInput = {
    id?: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: LeaveDocumentUncheckedCreateNestedManyWithoutLeaveRequestInput
    salaryDeductions?: SalaryDeductionUncheckedCreateNestedManyWithoutLeaveRequestInput
  }

  export type LeaveRequestCreateOrConnectWithoutUserInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput>
  }

  export type LeaveRequestCreateManyUserInputEnvelope = {
    data: LeaveRequestCreateManyUserInput | LeaveRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutApproverInput = {
    id?: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaveRequestsInput
    documents?: LeaveDocumentCreateNestedManyWithoutLeaveRequestInput
    salaryDeductions?: SalaryDeductionCreateNestedManyWithoutLeaveRequestInput
  }

  export type LeaveRequestUncheckedCreateWithoutApproverInput = {
    id?: string
    userId: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: LeaveDocumentUncheckedCreateNestedManyWithoutLeaveRequestInput
    salaryDeductions?: SalaryDeductionUncheckedCreateNestedManyWithoutLeaveRequestInput
  }

  export type LeaveRequestCreateOrConnectWithoutApproverInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutApproverInput, LeaveRequestUncheckedCreateWithoutApproverInput>
  }

  export type LeaveRequestCreateManyApproverInputEnvelope = {
    data: LeaveRequestCreateManyApproverInput | LeaveRequestCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type LeaveBalanceCreateWithoutUserInput = {
    id?: string
    year: number
    annualTotal?: number
    annualUsed?: number
    annualRemaining?: number
    sickTotal?: number
    sickUsed?: number
    sickRemaining?: number
    casualTotal?: number
    casualUsed?: number
    casualRemaining?: number
    maternityTotal?: number
    maternityUsed?: number
    maternityRemaining?: number
    paternityTotal?: number
    paternityUsed?: number
    paternityRemaining?: number
    emergencyTotal?: number
    emergencyUsed?: number
    emergencyRemaining?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveBalanceUncheckedCreateWithoutUserInput = {
    id?: string
    year: number
    annualTotal?: number
    annualUsed?: number
    annualRemaining?: number
    sickTotal?: number
    sickUsed?: number
    sickRemaining?: number
    casualTotal?: number
    casualUsed?: number
    casualRemaining?: number
    maternityTotal?: number
    maternityUsed?: number
    maternityRemaining?: number
    paternityTotal?: number
    paternityUsed?: number
    paternityRemaining?: number
    emergencyTotal?: number
    emergencyUsed?: number
    emergencyRemaining?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveBalanceCreateOrConnectWithoutUserInput = {
    where: LeaveBalanceWhereUniqueInput
    create: XOR<LeaveBalanceCreateWithoutUserInput, LeaveBalanceUncheckedCreateWithoutUserInput>
  }

  export type LeaveBalanceCreateManyUserInputEnvelope = {
    data: LeaveBalanceCreateManyUserInput | LeaveBalanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    userName: string
    action: string
    targetId?: string | null
    targetType?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    userName: string
    action: string
    targetId?: string | null
    targetType?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeavePolicyCreateWithoutCreatorInput = {
    id?: string
    leaveType: string
    totalDaysPerYear: number
    canCarryForward?: boolean
    maxCarryForwardDays?: number | null
    requiresApproval?: boolean
    allowHalfDay?: boolean
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeavePolicyUncheckedCreateWithoutCreatorInput = {
    id?: string
    leaveType: string
    totalDaysPerYear: number
    canCarryForward?: boolean
    maxCarryForwardDays?: number | null
    requiresApproval?: boolean
    allowHalfDay?: boolean
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeavePolicyCreateOrConnectWithoutCreatorInput = {
    where: LeavePolicyWhereUniqueInput
    create: XOR<LeavePolicyCreateWithoutCreatorInput, LeavePolicyUncheckedCreateWithoutCreatorInput>
  }

  export type LeavePolicyCreateManyCreatorInputEnvelope = {
    data: LeavePolicyCreateManyCreatorInput | LeavePolicyCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type HolidayCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    date: Date | string
    type: $Enums.HolidayType
    isRecurring?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    date: Date | string
    type: $Enums.HolidayType
    isRecurring?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayCreateOrConnectWithoutCreatorInput = {
    where: HolidayWhereUniqueInput
    create: XOR<HolidayCreateWithoutCreatorInput, HolidayUncheckedCreateWithoutCreatorInput>
  }

  export type HolidayCreateManyCreatorInputEnvelope = {
    data: HolidayCreateManyCreatorInput | HolidayCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutUserInput = {
    id?: string
    date: Date | string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    status?: $Enums.AttendanceStatus
    hoursWorked?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isHoliday?: boolean
    isWeekend?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    status?: $Enums.AttendanceStatus
    hoursWorked?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isHoliday?: boolean
    isWeekend?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordCreateOrConnectWithoutUserInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutUserInput, AttendanceRecordUncheckedCreateWithoutUserInput>
  }

  export type AttendanceRecordCreateManyUserInputEnvelope = {
    data: AttendanceRecordCreateManyUserInput | AttendanceRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttendancePolicyCreateWithoutCreatorInput = {
    id?: string
    name: string
    workingHoursPerDay?: Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: number
    overtimeThresholdHours?: Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: boolean
    requireCheckIn?: boolean
    requireCheckOut?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendancePolicyUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    workingHoursPerDay?: Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: number
    overtimeThresholdHours?: Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: boolean
    requireCheckIn?: boolean
    requireCheckOut?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendancePolicyCreateOrConnectWithoutCreatorInput = {
    where: AttendancePolicyWhereUniqueInput
    create: XOR<AttendancePolicyCreateWithoutCreatorInput, AttendancePolicyUncheckedCreateWithoutCreatorInput>
  }

  export type AttendancePolicyCreateManyCreatorInputEnvelope = {
    data: AttendancePolicyCreateManyCreatorInput | AttendancePolicyCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeSalaryCreateWithoutUserInput = {
    id?: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutEmployeeSalaryInput
  }

  export type EmployeeSalaryUncheckedCreateWithoutUserInput = {
    id?: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutEmployeeSalaryInput
  }

  export type EmployeeSalaryCreateOrConnectWithoutUserInput = {
    where: EmployeeSalaryWhereUniqueInput
    create: XOR<EmployeeSalaryCreateWithoutUserInput, EmployeeSalaryUncheckedCreateWithoutUserInput>
  }

  export type EmployeeSalaryCreateManyUserInputEnvelope = {
    data: EmployeeSalaryCreateManyUserInput | EmployeeSalaryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MonthlySalaryCreateWithoutUserInput = {
    id?: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeSalary: EmployeeSalaryCreateNestedOneWithoutMonthlySalariesInput
    approver?: UserCreateNestedOneWithoutApprovedSalariesInput
    deductions?: SalaryDeductionCreateNestedManyWithoutMonthlySalaryInput
  }

  export type MonthlySalaryUncheckedCreateWithoutUserInput = {
    id?: string
    employeeSalaryId: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    approvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deductions?: SalaryDeductionUncheckedCreateNestedManyWithoutMonthlySalaryInput
  }

  export type MonthlySalaryCreateOrConnectWithoutUserInput = {
    where: MonthlySalaryWhereUniqueInput
    create: XOR<MonthlySalaryCreateWithoutUserInput, MonthlySalaryUncheckedCreateWithoutUserInput>
  }

  export type MonthlySalaryCreateManyUserInputEnvelope = {
    data: MonthlySalaryCreateManyUserInput | MonthlySalaryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MonthlySalaryCreateWithoutApproverInput = {
    id?: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeSalary: EmployeeSalaryCreateNestedOneWithoutMonthlySalariesInput
    user: UserCreateNestedOneWithoutMonthlySalariesInput
    deductions?: SalaryDeductionCreateNestedManyWithoutMonthlySalaryInput
  }

  export type MonthlySalaryUncheckedCreateWithoutApproverInput = {
    id?: string
    employeeSalaryId: string
    userId: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deductions?: SalaryDeductionUncheckedCreateNestedManyWithoutMonthlySalaryInput
  }

  export type MonthlySalaryCreateOrConnectWithoutApproverInput = {
    where: MonthlySalaryWhereUniqueInput
    create: XOR<MonthlySalaryCreateWithoutApproverInput, MonthlySalaryUncheckedCreateWithoutApproverInput>
  }

  export type MonthlySalaryCreateManyApproverInputEnvelope = {
    data: MonthlySalaryCreateManyApproverInput | MonthlySalaryCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSubordinatesInput = {
    update: XOR<UserUpdateWithoutSubordinatesInput, UserUncheckedUpdateWithoutSubordinatesInput>
    create: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubordinatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubordinatesInput, UserUncheckedUpdateWithoutSubordinatesInput>
  }

  export type UserUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
  }

  export type UserUpdateManyWithWhereWithoutManagerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutManagerInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    department?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    emergencyContact?: StringNullableFilter<"User"> | string | null
    emergencyPhone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutUserInput, LeaveRequestUncheckedUpdateWithoutUserInput>
    create: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutUserInput, LeaveRequestUncheckedUpdateWithoutUserInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutUserInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaveRequestScalarWhereInput = {
    AND?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    OR?: LeaveRequestScalarWhereInput[]
    NOT?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    userId?: StringFilter<"LeaveRequest"> | string
    leaveType?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    totalDays?: DecimalFilter<"LeaveRequest"> | Decimal | DecimalJsLike | number | string
    reason?: StringFilter<"LeaveRequest"> | string
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    submittedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    approvedBy?: StringNullableFilter<"LeaveRequest"> | string | null
    approvedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    rejectedReason?: StringNullableFilter<"LeaveRequest"> | string | null
    isHalfDay?: BoolFilter<"LeaveRequest"> | boolean
    halfDayPeriod?: EnumHalfDayPeriodNullableFilter<"LeaveRequest"> | $Enums.HalfDayPeriod | null
    comments?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutApproverInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutApproverInput, LeaveRequestUncheckedUpdateWithoutApproverInput>
    create: XOR<LeaveRequestCreateWithoutApproverInput, LeaveRequestUncheckedCreateWithoutApproverInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutApproverInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutApproverInput, LeaveRequestUncheckedUpdateWithoutApproverInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutApproverInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutApproverInput>
  }

  export type LeaveBalanceUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaveBalanceWhereUniqueInput
    update: XOR<LeaveBalanceUpdateWithoutUserInput, LeaveBalanceUncheckedUpdateWithoutUserInput>
    create: XOR<LeaveBalanceCreateWithoutUserInput, LeaveBalanceUncheckedCreateWithoutUserInput>
  }

  export type LeaveBalanceUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaveBalanceWhereUniqueInput
    data: XOR<LeaveBalanceUpdateWithoutUserInput, LeaveBalanceUncheckedUpdateWithoutUserInput>
  }

  export type LeaveBalanceUpdateManyWithWhereWithoutUserInput = {
    where: LeaveBalanceScalarWhereInput
    data: XOR<LeaveBalanceUpdateManyMutationInput, LeaveBalanceUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaveBalanceScalarWhereInput = {
    AND?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
    OR?: LeaveBalanceScalarWhereInput[]
    NOT?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
    id?: StringFilter<"LeaveBalance"> | string
    userId?: StringFilter<"LeaveBalance"> | string
    year?: IntFilter<"LeaveBalance"> | number
    annualTotal?: IntFilter<"LeaveBalance"> | number
    annualUsed?: IntFilter<"LeaveBalance"> | number
    annualRemaining?: IntFilter<"LeaveBalance"> | number
    sickTotal?: IntFilter<"LeaveBalance"> | number
    sickUsed?: IntFilter<"LeaveBalance"> | number
    sickRemaining?: IntFilter<"LeaveBalance"> | number
    casualTotal?: IntFilter<"LeaveBalance"> | number
    casualUsed?: IntFilter<"LeaveBalance"> | number
    casualRemaining?: IntFilter<"LeaveBalance"> | number
    maternityTotal?: IntFilter<"LeaveBalance"> | number
    maternityUsed?: IntFilter<"LeaveBalance"> | number
    maternityRemaining?: IntFilter<"LeaveBalance"> | number
    paternityTotal?: IntFilter<"LeaveBalance"> | number
    paternityUsed?: IntFilter<"LeaveBalance"> | number
    paternityRemaining?: IntFilter<"LeaveBalance"> | number
    emergencyTotal?: IntFilter<"LeaveBalance"> | number
    emergencyUsed?: IntFilter<"LeaveBalance"> | number
    emergencyRemaining?: IntFilter<"LeaveBalance"> | number
    createdAt?: DateTimeFilter<"LeaveBalance"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveBalance"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    userName?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    targetId?: StringNullableFilter<"AuditLog"> | string | null
    targetType?: StringNullableFilter<"AuditLog"> | string | null
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type LeavePolicyUpsertWithWhereUniqueWithoutCreatorInput = {
    where: LeavePolicyWhereUniqueInput
    update: XOR<LeavePolicyUpdateWithoutCreatorInput, LeavePolicyUncheckedUpdateWithoutCreatorInput>
    create: XOR<LeavePolicyCreateWithoutCreatorInput, LeavePolicyUncheckedCreateWithoutCreatorInput>
  }

  export type LeavePolicyUpdateWithWhereUniqueWithoutCreatorInput = {
    where: LeavePolicyWhereUniqueInput
    data: XOR<LeavePolicyUpdateWithoutCreatorInput, LeavePolicyUncheckedUpdateWithoutCreatorInput>
  }

  export type LeavePolicyUpdateManyWithWhereWithoutCreatorInput = {
    where: LeavePolicyScalarWhereInput
    data: XOR<LeavePolicyUpdateManyMutationInput, LeavePolicyUncheckedUpdateManyWithoutCreatorInput>
  }

  export type LeavePolicyScalarWhereInput = {
    AND?: LeavePolicyScalarWhereInput | LeavePolicyScalarWhereInput[]
    OR?: LeavePolicyScalarWhereInput[]
    NOT?: LeavePolicyScalarWhereInput | LeavePolicyScalarWhereInput[]
    id?: StringFilter<"LeavePolicy"> | string
    leaveType?: StringFilter<"LeavePolicy"> | string
    totalDaysPerYear?: IntFilter<"LeavePolicy"> | number
    canCarryForward?: BoolFilter<"LeavePolicy"> | boolean
    maxCarryForwardDays?: IntNullableFilter<"LeavePolicy"> | number | null
    requiresApproval?: BoolFilter<"LeavePolicy"> | boolean
    allowHalfDay?: BoolFilter<"LeavePolicy"> | boolean
    description?: StringNullableFilter<"LeavePolicy"> | string | null
    isActive?: BoolFilter<"LeavePolicy"> | boolean
    createdBy?: StringFilter<"LeavePolicy"> | string
    createdAt?: DateTimeFilter<"LeavePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"LeavePolicy"> | Date | string
  }

  export type HolidayUpsertWithWhereUniqueWithoutCreatorInput = {
    where: HolidayWhereUniqueInput
    update: XOR<HolidayUpdateWithoutCreatorInput, HolidayUncheckedUpdateWithoutCreatorInput>
    create: XOR<HolidayCreateWithoutCreatorInput, HolidayUncheckedCreateWithoutCreatorInput>
  }

  export type HolidayUpdateWithWhereUniqueWithoutCreatorInput = {
    where: HolidayWhereUniqueInput
    data: XOR<HolidayUpdateWithoutCreatorInput, HolidayUncheckedUpdateWithoutCreatorInput>
  }

  export type HolidayUpdateManyWithWhereWithoutCreatorInput = {
    where: HolidayScalarWhereInput
    data: XOR<HolidayUpdateManyMutationInput, HolidayUncheckedUpdateManyWithoutCreatorInput>
  }

  export type HolidayScalarWhereInput = {
    AND?: HolidayScalarWhereInput | HolidayScalarWhereInput[]
    OR?: HolidayScalarWhereInput[]
    NOT?: HolidayScalarWhereInput | HolidayScalarWhereInput[]
    id?: StringFilter<"Holiday"> | string
    name?: StringFilter<"Holiday"> | string
    description?: StringNullableFilter<"Holiday"> | string | null
    date?: DateTimeFilter<"Holiday"> | Date | string
    type?: EnumHolidayTypeFilter<"Holiday"> | $Enums.HolidayType
    isRecurring?: BoolFilter<"Holiday"> | boolean
    isActive?: BoolFilter<"Holiday"> | boolean
    createdBy?: StringFilter<"Holiday"> | string
    createdAt?: DateTimeFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeFilter<"Holiday"> | Date | string
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutUserInput, AttendanceRecordUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceRecordCreateWithoutUserInput, AttendanceRecordUncheckedCreateWithoutUserInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutUserInput, AttendanceRecordUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceRecordScalarWhereInput = {
    AND?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    OR?: AttendanceRecordScalarWhereInput[]
    NOT?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    id?: StringFilter<"AttendanceRecord"> | string
    userId?: StringFilter<"AttendanceRecord"> | string
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    checkInTime?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    hoursWorked?: DecimalFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"AttendanceRecord"> | string | null
    isHoliday?: BoolFilter<"AttendanceRecord"> | boolean
    isWeekend?: BoolFilter<"AttendanceRecord"> | boolean
    createdAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
  }

  export type AttendancePolicyUpsertWithWhereUniqueWithoutCreatorInput = {
    where: AttendancePolicyWhereUniqueInput
    update: XOR<AttendancePolicyUpdateWithoutCreatorInput, AttendancePolicyUncheckedUpdateWithoutCreatorInput>
    create: XOR<AttendancePolicyCreateWithoutCreatorInput, AttendancePolicyUncheckedCreateWithoutCreatorInput>
  }

  export type AttendancePolicyUpdateWithWhereUniqueWithoutCreatorInput = {
    where: AttendancePolicyWhereUniqueInput
    data: XOR<AttendancePolicyUpdateWithoutCreatorInput, AttendancePolicyUncheckedUpdateWithoutCreatorInput>
  }

  export type AttendancePolicyUpdateManyWithWhereWithoutCreatorInput = {
    where: AttendancePolicyScalarWhereInput
    data: XOR<AttendancePolicyUpdateManyMutationInput, AttendancePolicyUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AttendancePolicyScalarWhereInput = {
    AND?: AttendancePolicyScalarWhereInput | AttendancePolicyScalarWhereInput[]
    OR?: AttendancePolicyScalarWhereInput[]
    NOT?: AttendancePolicyScalarWhereInput | AttendancePolicyScalarWhereInput[]
    id?: StringFilter<"AttendancePolicy"> | string
    name?: StringFilter<"AttendancePolicy"> | string
    workingHoursPerDay?: DecimalFilter<"AttendancePolicy"> | Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: IntFilter<"AttendancePolicy"> | number
    overtimeThresholdHours?: DecimalFilter<"AttendancePolicy"> | Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: BoolFilter<"AttendancePolicy"> | boolean
    requireCheckIn?: BoolFilter<"AttendancePolicy"> | boolean
    requireCheckOut?: BoolFilter<"AttendancePolicy"> | boolean
    isActive?: BoolFilter<"AttendancePolicy"> | boolean
    createdBy?: StringFilter<"AttendancePolicy"> | string
    createdAt?: DateTimeFilter<"AttendancePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"AttendancePolicy"> | Date | string
  }

  export type EmployeeSalaryUpsertWithWhereUniqueWithoutUserInput = {
    where: EmployeeSalaryWhereUniqueInput
    update: XOR<EmployeeSalaryUpdateWithoutUserInput, EmployeeSalaryUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeSalaryCreateWithoutUserInput, EmployeeSalaryUncheckedCreateWithoutUserInput>
  }

  export type EmployeeSalaryUpdateWithWhereUniqueWithoutUserInput = {
    where: EmployeeSalaryWhereUniqueInput
    data: XOR<EmployeeSalaryUpdateWithoutUserInput, EmployeeSalaryUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeSalaryUpdateManyWithWhereWithoutUserInput = {
    where: EmployeeSalaryScalarWhereInput
    data: XOR<EmployeeSalaryUpdateManyMutationInput, EmployeeSalaryUncheckedUpdateManyWithoutUserInput>
  }

  export type EmployeeSalaryScalarWhereInput = {
    AND?: EmployeeSalaryScalarWhereInput | EmployeeSalaryScalarWhereInput[]
    OR?: EmployeeSalaryScalarWhereInput[]
    NOT?: EmployeeSalaryScalarWhereInput | EmployeeSalaryScalarWhereInput[]
    id?: StringFilter<"EmployeeSalary"> | string
    userId?: StringFilter<"EmployeeSalary"> | string
    baseSalary?: DecimalFilter<"EmployeeSalary"> | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalNullableFilter<"EmployeeSalary"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"EmployeeSalary"> | string
    effectiveDate?: DateTimeFilter<"EmployeeSalary"> | Date | string
    endDate?: DateTimeNullableFilter<"EmployeeSalary"> | Date | string | null
    isActive?: BoolFilter<"EmployeeSalary"> | boolean
    createdAt?: DateTimeFilter<"EmployeeSalary"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeSalary"> | Date | string
  }

  export type MonthlySalaryUpsertWithWhereUniqueWithoutUserInput = {
    where: MonthlySalaryWhereUniqueInput
    update: XOR<MonthlySalaryUpdateWithoutUserInput, MonthlySalaryUncheckedUpdateWithoutUserInput>
    create: XOR<MonthlySalaryCreateWithoutUserInput, MonthlySalaryUncheckedCreateWithoutUserInput>
  }

  export type MonthlySalaryUpdateWithWhereUniqueWithoutUserInput = {
    where: MonthlySalaryWhereUniqueInput
    data: XOR<MonthlySalaryUpdateWithoutUserInput, MonthlySalaryUncheckedUpdateWithoutUserInput>
  }

  export type MonthlySalaryUpdateManyWithWhereWithoutUserInput = {
    where: MonthlySalaryScalarWhereInput
    data: XOR<MonthlySalaryUpdateManyMutationInput, MonthlySalaryUncheckedUpdateManyWithoutUserInput>
  }

  export type MonthlySalaryScalarWhereInput = {
    AND?: MonthlySalaryScalarWhereInput | MonthlySalaryScalarWhereInput[]
    OR?: MonthlySalaryScalarWhereInput[]
    NOT?: MonthlySalaryScalarWhereInput | MonthlySalaryScalarWhereInput[]
    id?: StringFilter<"MonthlySalary"> | string
    employeeSalaryId?: StringFilter<"MonthlySalary"> | string
    userId?: StringFilter<"MonthlySalary"> | string
    year?: IntFilter<"MonthlySalary"> | number
    month?: IntFilter<"MonthlySalary"> | number
    baseSalary?: DecimalFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFilter<"MonthlySalary"> | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFilter<"MonthlySalary"> | $Enums.SalaryStatus
    calculatedAt?: DateTimeNullableFilter<"MonthlySalary"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"MonthlySalary"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"MonthlySalary"> | Date | string | null
    approvedBy?: StringNullableFilter<"MonthlySalary"> | string | null
    notes?: StringNullableFilter<"MonthlySalary"> | string | null
    createdAt?: DateTimeFilter<"MonthlySalary"> | Date | string
    updatedAt?: DateTimeFilter<"MonthlySalary"> | Date | string
  }

  export type MonthlySalaryUpsertWithWhereUniqueWithoutApproverInput = {
    where: MonthlySalaryWhereUniqueInput
    update: XOR<MonthlySalaryUpdateWithoutApproverInput, MonthlySalaryUncheckedUpdateWithoutApproverInput>
    create: XOR<MonthlySalaryCreateWithoutApproverInput, MonthlySalaryUncheckedCreateWithoutApproverInput>
  }

  export type MonthlySalaryUpdateWithWhereUniqueWithoutApproverInput = {
    where: MonthlySalaryWhereUniqueInput
    data: XOR<MonthlySalaryUpdateWithoutApproverInput, MonthlySalaryUncheckedUpdateWithoutApproverInput>
  }

  export type MonthlySalaryUpdateManyWithWhereWithoutApproverInput = {
    where: MonthlySalaryScalarWhereInput
    data: XOR<MonthlySalaryUpdateManyMutationInput, MonthlySalaryUncheckedUpdateManyWithoutApproverInput>
  }

  export type UserCreateWithoutLeaveRequestsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutLeaveRequestsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutLeaveRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaveRequestsInput, UserUncheckedCreateWithoutLeaveRequestsInput>
  }

  export type UserCreateWithoutApprovedLeavesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutApprovedLeavesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutApprovedLeavesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedLeavesInput, UserUncheckedCreateWithoutApprovedLeavesInput>
  }

  export type LeaveDocumentCreateWithoutLeaveRequestInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
  }

  export type LeaveDocumentUncheckedCreateWithoutLeaveRequestInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
  }

  export type LeaveDocumentCreateOrConnectWithoutLeaveRequestInput = {
    where: LeaveDocumentWhereUniqueInput
    create: XOR<LeaveDocumentCreateWithoutLeaveRequestInput, LeaveDocumentUncheckedCreateWithoutLeaveRequestInput>
  }

  export type LeaveDocumentCreateManyLeaveRequestInputEnvelope = {
    data: LeaveDocumentCreateManyLeaveRequestInput | LeaveDocumentCreateManyLeaveRequestInput[]
    skipDuplicates?: boolean
  }

  export type SalaryDeductionCreateWithoutLeaveRequestInput = {
    id?: string
    type: $Enums.DeductionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    createdAt?: Date | string
    monthlySalary: MonthlySalaryCreateNestedOneWithoutDeductionsInput
  }

  export type SalaryDeductionUncheckedCreateWithoutLeaveRequestInput = {
    id?: string
    monthlySalaryId: string
    type: $Enums.DeductionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    createdAt?: Date | string
  }

  export type SalaryDeductionCreateOrConnectWithoutLeaveRequestInput = {
    where: SalaryDeductionWhereUniqueInput
    create: XOR<SalaryDeductionCreateWithoutLeaveRequestInput, SalaryDeductionUncheckedCreateWithoutLeaveRequestInput>
  }

  export type SalaryDeductionCreateManyLeaveRequestInputEnvelope = {
    data: SalaryDeductionCreateManyLeaveRequestInput | SalaryDeductionCreateManyLeaveRequestInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLeaveRequestsInput = {
    update: XOR<UserUpdateWithoutLeaveRequestsInput, UserUncheckedUpdateWithoutLeaveRequestsInput>
    create: XOR<UserCreateWithoutLeaveRequestsInput, UserUncheckedCreateWithoutLeaveRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaveRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaveRequestsInput, UserUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type UserUpdateWithoutLeaveRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaveRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserUpsertWithoutApprovedLeavesInput = {
    update: XOR<UserUpdateWithoutApprovedLeavesInput, UserUncheckedUpdateWithoutApprovedLeavesInput>
    create: XOR<UserCreateWithoutApprovedLeavesInput, UserUncheckedCreateWithoutApprovedLeavesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedLeavesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedLeavesInput, UserUncheckedUpdateWithoutApprovedLeavesInput>
  }

  export type UserUpdateWithoutApprovedLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type LeaveDocumentUpsertWithWhereUniqueWithoutLeaveRequestInput = {
    where: LeaveDocumentWhereUniqueInput
    update: XOR<LeaveDocumentUpdateWithoutLeaveRequestInput, LeaveDocumentUncheckedUpdateWithoutLeaveRequestInput>
    create: XOR<LeaveDocumentCreateWithoutLeaveRequestInput, LeaveDocumentUncheckedCreateWithoutLeaveRequestInput>
  }

  export type LeaveDocumentUpdateWithWhereUniqueWithoutLeaveRequestInput = {
    where: LeaveDocumentWhereUniqueInput
    data: XOR<LeaveDocumentUpdateWithoutLeaveRequestInput, LeaveDocumentUncheckedUpdateWithoutLeaveRequestInput>
  }

  export type LeaveDocumentUpdateManyWithWhereWithoutLeaveRequestInput = {
    where: LeaveDocumentScalarWhereInput
    data: XOR<LeaveDocumentUpdateManyMutationInput, LeaveDocumentUncheckedUpdateManyWithoutLeaveRequestInput>
  }

  export type LeaveDocumentScalarWhereInput = {
    AND?: LeaveDocumentScalarWhereInput | LeaveDocumentScalarWhereInput[]
    OR?: LeaveDocumentScalarWhereInput[]
    NOT?: LeaveDocumentScalarWhereInput | LeaveDocumentScalarWhereInput[]
    id?: StringFilter<"LeaveDocument"> | string
    leaveRequestId?: StringFilter<"LeaveDocument"> | string
    fileName?: StringFilter<"LeaveDocument"> | string
    filePath?: StringFilter<"LeaveDocument"> | string
    fileSize?: IntFilter<"LeaveDocument"> | number
    mimeType?: StringFilter<"LeaveDocument"> | string
    uploadedAt?: DateTimeFilter<"LeaveDocument"> | Date | string
  }

  export type SalaryDeductionUpsertWithWhereUniqueWithoutLeaveRequestInput = {
    where: SalaryDeductionWhereUniqueInput
    update: XOR<SalaryDeductionUpdateWithoutLeaveRequestInput, SalaryDeductionUncheckedUpdateWithoutLeaveRequestInput>
    create: XOR<SalaryDeductionCreateWithoutLeaveRequestInput, SalaryDeductionUncheckedCreateWithoutLeaveRequestInput>
  }

  export type SalaryDeductionUpdateWithWhereUniqueWithoutLeaveRequestInput = {
    where: SalaryDeductionWhereUniqueInput
    data: XOR<SalaryDeductionUpdateWithoutLeaveRequestInput, SalaryDeductionUncheckedUpdateWithoutLeaveRequestInput>
  }

  export type SalaryDeductionUpdateManyWithWhereWithoutLeaveRequestInput = {
    where: SalaryDeductionScalarWhereInput
    data: XOR<SalaryDeductionUpdateManyMutationInput, SalaryDeductionUncheckedUpdateManyWithoutLeaveRequestInput>
  }

  export type SalaryDeductionScalarWhereInput = {
    AND?: SalaryDeductionScalarWhereInput | SalaryDeductionScalarWhereInput[]
    OR?: SalaryDeductionScalarWhereInput[]
    NOT?: SalaryDeductionScalarWhereInput | SalaryDeductionScalarWhereInput[]
    id?: StringFilter<"SalaryDeduction"> | string
    monthlySalaryId?: StringFilter<"SalaryDeduction"> | string
    type?: EnumDeductionTypeFilter<"SalaryDeduction"> | $Enums.DeductionType
    description?: StringFilter<"SalaryDeduction"> | string
    amount?: DecimalFilter<"SalaryDeduction"> | Decimal | DecimalJsLike | number | string
    leaveRequestId?: StringNullableFilter<"SalaryDeduction"> | string | null
    isTaxable?: BoolFilter<"SalaryDeduction"> | boolean
    createdAt?: DateTimeFilter<"SalaryDeduction"> | Date | string
  }

  export type UserCreateWithoutLeaveBalancesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutLeaveBalancesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutLeaveBalancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaveBalancesInput, UserUncheckedCreateWithoutLeaveBalancesInput>
  }

  export type UserUpsertWithoutLeaveBalancesInput = {
    update: XOR<UserUpdateWithoutLeaveBalancesInput, UserUncheckedUpdateWithoutLeaveBalancesInput>
    create: XOR<UserCreateWithoutLeaveBalancesInput, UserUncheckedCreateWithoutLeaveBalancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaveBalancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaveBalancesInput, UserUncheckedUpdateWithoutLeaveBalancesInput>
  }

  export type UserUpdateWithoutLeaveBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaveBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutCreatedPoliciesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutCreatedPoliciesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutCreatedPoliciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPoliciesInput, UserUncheckedCreateWithoutCreatedPoliciesInput>
  }

  export type UserUpsertWithoutCreatedPoliciesInput = {
    update: XOR<UserUpdateWithoutCreatedPoliciesInput, UserUncheckedUpdateWithoutCreatedPoliciesInput>
    create: XOR<UserCreateWithoutCreatedPoliciesInput, UserUncheckedCreateWithoutCreatedPoliciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPoliciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPoliciesInput, UserUncheckedUpdateWithoutCreatedPoliciesInput>
  }

  export type UserUpdateWithoutCreatedPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type LeaveRequestCreateWithoutDocumentsInput = {
    id?: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaveRequestsInput
    approver?: UserCreateNestedOneWithoutApprovedLeavesInput
    salaryDeductions?: SalaryDeductionCreateNestedManyWithoutLeaveRequestInput
  }

  export type LeaveRequestUncheckedCreateWithoutDocumentsInput = {
    id?: string
    userId: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salaryDeductions?: SalaryDeductionUncheckedCreateNestedManyWithoutLeaveRequestInput
  }

  export type LeaveRequestCreateOrConnectWithoutDocumentsInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutDocumentsInput, LeaveRequestUncheckedCreateWithoutDocumentsInput>
  }

  export type LeaveRequestUpsertWithoutDocumentsInput = {
    update: XOR<LeaveRequestUpdateWithoutDocumentsInput, LeaveRequestUncheckedUpdateWithoutDocumentsInput>
    create: XOR<LeaveRequestCreateWithoutDocumentsInput, LeaveRequestUncheckedCreateWithoutDocumentsInput>
    where?: LeaveRequestWhereInput
  }

  export type LeaveRequestUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: LeaveRequestWhereInput
    data: XOR<LeaveRequestUpdateWithoutDocumentsInput, LeaveRequestUncheckedUpdateWithoutDocumentsInput>
  }

  export type LeaveRequestUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaveRequestsNestedInput
    approver?: UserUpdateOneWithoutApprovedLeavesNestedInput
    salaryDeductions?: SalaryDeductionUpdateManyWithoutLeaveRequestNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryDeductions?: SalaryDeductionUncheckedUpdateManyWithoutLeaveRequestNestedInput
  }

  export type UserCreateWithoutCreatedHolidaysInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutCreatedHolidaysInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutCreatedHolidaysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedHolidaysInput, UserUncheckedCreateWithoutCreatedHolidaysInput>
  }

  export type UserUpsertWithoutCreatedHolidaysInput = {
    update: XOR<UserUpdateWithoutCreatedHolidaysInput, UserUncheckedUpdateWithoutCreatedHolidaysInput>
    create: XOR<UserCreateWithoutCreatedHolidaysInput, UserUncheckedCreateWithoutCreatedHolidaysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedHolidaysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedHolidaysInput, UserUncheckedUpdateWithoutCreatedHolidaysInput>
  }

  export type UserUpdateWithoutCreatedHolidaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedHolidaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutAttendanceRecordsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutAttendanceRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceRecordsInput, UserUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type UserUpsertWithoutAttendanceRecordsInput = {
    update: XOR<UserUpdateWithoutAttendanceRecordsInput, UserUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<UserCreateWithoutAttendanceRecordsInput, UserUncheckedCreateWithoutAttendanceRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceRecordsInput, UserUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type UserUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutCreatedAttendancePoliciesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutCreatedAttendancePoliciesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutCreatedAttendancePoliciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedAttendancePoliciesInput, UserUncheckedCreateWithoutCreatedAttendancePoliciesInput>
  }

  export type UserUpsertWithoutCreatedAttendancePoliciesInput = {
    update: XOR<UserUpdateWithoutCreatedAttendancePoliciesInput, UserUncheckedUpdateWithoutCreatedAttendancePoliciesInput>
    create: XOR<UserCreateWithoutCreatedAttendancePoliciesInput, UserUncheckedCreateWithoutCreatedAttendancePoliciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedAttendancePoliciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedAttendancePoliciesInput, UserUncheckedUpdateWithoutCreatedAttendancePoliciesInput>
  }

  export type UserUpdateWithoutCreatedAttendancePoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedAttendancePoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutEmployeeSalaryInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutEmployeeSalaryInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutEmployeeSalaryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeSalaryInput, UserUncheckedCreateWithoutEmployeeSalaryInput>
  }

  export type MonthlySalaryCreateWithoutEmployeeSalaryInput = {
    id?: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMonthlySalariesInput
    approver?: UserCreateNestedOneWithoutApprovedSalariesInput
    deductions?: SalaryDeductionCreateNestedManyWithoutMonthlySalaryInput
  }

  export type MonthlySalaryUncheckedCreateWithoutEmployeeSalaryInput = {
    id?: string
    userId: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    approvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deductions?: SalaryDeductionUncheckedCreateNestedManyWithoutMonthlySalaryInput
  }

  export type MonthlySalaryCreateOrConnectWithoutEmployeeSalaryInput = {
    where: MonthlySalaryWhereUniqueInput
    create: XOR<MonthlySalaryCreateWithoutEmployeeSalaryInput, MonthlySalaryUncheckedCreateWithoutEmployeeSalaryInput>
  }

  export type MonthlySalaryCreateManyEmployeeSalaryInputEnvelope = {
    data: MonthlySalaryCreateManyEmployeeSalaryInput | MonthlySalaryCreateManyEmployeeSalaryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmployeeSalaryInput = {
    update: XOR<UserUpdateWithoutEmployeeSalaryInput, UserUncheckedUpdateWithoutEmployeeSalaryInput>
    create: XOR<UserCreateWithoutEmployeeSalaryInput, UserUncheckedCreateWithoutEmployeeSalaryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeSalaryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeSalaryInput, UserUncheckedUpdateWithoutEmployeeSalaryInput>
  }

  export type UserUpdateWithoutEmployeeSalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeSalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type MonthlySalaryUpsertWithWhereUniqueWithoutEmployeeSalaryInput = {
    where: MonthlySalaryWhereUniqueInput
    update: XOR<MonthlySalaryUpdateWithoutEmployeeSalaryInput, MonthlySalaryUncheckedUpdateWithoutEmployeeSalaryInput>
    create: XOR<MonthlySalaryCreateWithoutEmployeeSalaryInput, MonthlySalaryUncheckedCreateWithoutEmployeeSalaryInput>
  }

  export type MonthlySalaryUpdateWithWhereUniqueWithoutEmployeeSalaryInput = {
    where: MonthlySalaryWhereUniqueInput
    data: XOR<MonthlySalaryUpdateWithoutEmployeeSalaryInput, MonthlySalaryUncheckedUpdateWithoutEmployeeSalaryInput>
  }

  export type MonthlySalaryUpdateManyWithWhereWithoutEmployeeSalaryInput = {
    where: MonthlySalaryScalarWhereInput
    data: XOR<MonthlySalaryUpdateManyMutationInput, MonthlySalaryUncheckedUpdateManyWithoutEmployeeSalaryInput>
  }

  export type EmployeeSalaryCreateWithoutMonthlySalariesInput = {
    id?: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeSalaryInput
  }

  export type EmployeeSalaryUncheckedCreateWithoutMonthlySalariesInput = {
    id?: string
    userId: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeSalaryCreateOrConnectWithoutMonthlySalariesInput = {
    where: EmployeeSalaryWhereUniqueInput
    create: XOR<EmployeeSalaryCreateWithoutMonthlySalariesInput, EmployeeSalaryUncheckedCreateWithoutMonthlySalariesInput>
  }

  export type UserCreateWithoutMonthlySalariesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutMonthlySalariesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    approvedSalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutMonthlySalariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMonthlySalariesInput, UserUncheckedCreateWithoutMonthlySalariesInput>
  }

  export type UserCreateWithoutApprovedSalariesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApprovedSalariesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    managerId?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveRequestUncheckedCreateNestedManyWithoutApproverInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdPolicies?: LeavePolicyUncheckedCreateNestedManyWithoutCreatorInput
    createdHolidays?: HolidayUncheckedCreateNestedManyWithoutCreatorInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutUserInput
    createdAttendancePolicies?: AttendancePolicyUncheckedCreateNestedManyWithoutCreatorInput
    employeeSalary?: EmployeeSalaryUncheckedCreateNestedManyWithoutUserInput
    monthlySalaries?: MonthlySalaryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApprovedSalariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedSalariesInput, UserUncheckedCreateWithoutApprovedSalariesInput>
  }

  export type SalaryDeductionCreateWithoutMonthlySalaryInput = {
    id?: string
    type: $Enums.DeductionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    createdAt?: Date | string
    leaveRequest?: LeaveRequestCreateNestedOneWithoutSalaryDeductionsInput
  }

  export type SalaryDeductionUncheckedCreateWithoutMonthlySalaryInput = {
    id?: string
    type: $Enums.DeductionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    leaveRequestId?: string | null
    isTaxable?: boolean
    createdAt?: Date | string
  }

  export type SalaryDeductionCreateOrConnectWithoutMonthlySalaryInput = {
    where: SalaryDeductionWhereUniqueInput
    create: XOR<SalaryDeductionCreateWithoutMonthlySalaryInput, SalaryDeductionUncheckedCreateWithoutMonthlySalaryInput>
  }

  export type SalaryDeductionCreateManyMonthlySalaryInputEnvelope = {
    data: SalaryDeductionCreateManyMonthlySalaryInput | SalaryDeductionCreateManyMonthlySalaryInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeSalaryUpsertWithoutMonthlySalariesInput = {
    update: XOR<EmployeeSalaryUpdateWithoutMonthlySalariesInput, EmployeeSalaryUncheckedUpdateWithoutMonthlySalariesInput>
    create: XOR<EmployeeSalaryCreateWithoutMonthlySalariesInput, EmployeeSalaryUncheckedCreateWithoutMonthlySalariesInput>
    where?: EmployeeSalaryWhereInput
  }

  export type EmployeeSalaryUpdateToOneWithWhereWithoutMonthlySalariesInput = {
    where?: EmployeeSalaryWhereInput
    data: XOR<EmployeeSalaryUpdateWithoutMonthlySalariesInput, EmployeeSalaryUncheckedUpdateWithoutMonthlySalariesInput>
  }

  export type EmployeeSalaryUpdateWithoutMonthlySalariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeSalaryNestedInput
  }

  export type EmployeeSalaryUncheckedUpdateWithoutMonthlySalariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMonthlySalariesInput = {
    update: XOR<UserUpdateWithoutMonthlySalariesInput, UserUncheckedUpdateWithoutMonthlySalariesInput>
    create: XOR<UserCreateWithoutMonthlySalariesInput, UserUncheckedCreateWithoutMonthlySalariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMonthlySalariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMonthlySalariesInput, UserUncheckedUpdateWithoutMonthlySalariesInput>
  }

  export type UserUpdateWithoutMonthlySalariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutMonthlySalariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserUpsertWithoutApprovedSalariesInput = {
    update: XOR<UserUpdateWithoutApprovedSalariesInput, UserUncheckedUpdateWithoutApprovedSalariesInput>
    create: XOR<UserCreateWithoutApprovedSalariesInput, UserUncheckedCreateWithoutApprovedSalariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedSalariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedSalariesInput, UserUncheckedUpdateWithoutApprovedSalariesInput>
  }

  export type UserUpdateWithoutApprovedSalariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedSalariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SalaryDeductionUpsertWithWhereUniqueWithoutMonthlySalaryInput = {
    where: SalaryDeductionWhereUniqueInput
    update: XOR<SalaryDeductionUpdateWithoutMonthlySalaryInput, SalaryDeductionUncheckedUpdateWithoutMonthlySalaryInput>
    create: XOR<SalaryDeductionCreateWithoutMonthlySalaryInput, SalaryDeductionUncheckedCreateWithoutMonthlySalaryInput>
  }

  export type SalaryDeductionUpdateWithWhereUniqueWithoutMonthlySalaryInput = {
    where: SalaryDeductionWhereUniqueInput
    data: XOR<SalaryDeductionUpdateWithoutMonthlySalaryInput, SalaryDeductionUncheckedUpdateWithoutMonthlySalaryInput>
  }

  export type SalaryDeductionUpdateManyWithWhereWithoutMonthlySalaryInput = {
    where: SalaryDeductionScalarWhereInput
    data: XOR<SalaryDeductionUpdateManyMutationInput, SalaryDeductionUncheckedUpdateManyWithoutMonthlySalaryInput>
  }

  export type MonthlySalaryCreateWithoutDeductionsInput = {
    id?: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeSalary: EmployeeSalaryCreateNestedOneWithoutMonthlySalariesInput
    user: UserCreateNestedOneWithoutMonthlySalariesInput
    approver?: UserCreateNestedOneWithoutApprovedSalariesInput
  }

  export type MonthlySalaryUncheckedCreateWithoutDeductionsInput = {
    id?: string
    employeeSalaryId: string
    userId: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    approvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonthlySalaryCreateOrConnectWithoutDeductionsInput = {
    where: MonthlySalaryWhereUniqueInput
    create: XOR<MonthlySalaryCreateWithoutDeductionsInput, MonthlySalaryUncheckedCreateWithoutDeductionsInput>
  }

  export type LeaveRequestCreateWithoutSalaryDeductionsInput = {
    id?: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaveRequestsInput
    approver?: UserCreateNestedOneWithoutApprovedLeavesInput
    documents?: LeaveDocumentCreateNestedManyWithoutLeaveRequestInput
  }

  export type LeaveRequestUncheckedCreateWithoutSalaryDeductionsInput = {
    id?: string
    userId: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: LeaveDocumentUncheckedCreateNestedManyWithoutLeaveRequestInput
  }

  export type LeaveRequestCreateOrConnectWithoutSalaryDeductionsInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutSalaryDeductionsInput, LeaveRequestUncheckedCreateWithoutSalaryDeductionsInput>
  }

  export type MonthlySalaryUpsertWithoutDeductionsInput = {
    update: XOR<MonthlySalaryUpdateWithoutDeductionsInput, MonthlySalaryUncheckedUpdateWithoutDeductionsInput>
    create: XOR<MonthlySalaryCreateWithoutDeductionsInput, MonthlySalaryUncheckedCreateWithoutDeductionsInput>
    where?: MonthlySalaryWhereInput
  }

  export type MonthlySalaryUpdateToOneWithWhereWithoutDeductionsInput = {
    where?: MonthlySalaryWhereInput
    data: XOR<MonthlySalaryUpdateWithoutDeductionsInput, MonthlySalaryUncheckedUpdateWithoutDeductionsInput>
  }

  export type MonthlySalaryUpdateWithoutDeductionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeSalary?: EmployeeSalaryUpdateOneRequiredWithoutMonthlySalariesNestedInput
    user?: UserUpdateOneRequiredWithoutMonthlySalariesNestedInput
    approver?: UserUpdateOneWithoutApprovedSalariesNestedInput
  }

  export type MonthlySalaryUncheckedUpdateWithoutDeductionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeSalaryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUpsertWithoutSalaryDeductionsInput = {
    update: XOR<LeaveRequestUpdateWithoutSalaryDeductionsInput, LeaveRequestUncheckedUpdateWithoutSalaryDeductionsInput>
    create: XOR<LeaveRequestCreateWithoutSalaryDeductionsInput, LeaveRequestUncheckedCreateWithoutSalaryDeductionsInput>
    where?: LeaveRequestWhereInput
  }

  export type LeaveRequestUpdateToOneWithWhereWithoutSalaryDeductionsInput = {
    where?: LeaveRequestWhereInput
    data: XOR<LeaveRequestUpdateWithoutSalaryDeductionsInput, LeaveRequestUncheckedUpdateWithoutSalaryDeductionsInput>
  }

  export type LeaveRequestUpdateWithoutSalaryDeductionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaveRequestsNestedInput
    approver?: UserUpdateOneWithoutApprovedLeavesNestedInput
    documents?: LeaveDocumentUpdateManyWithoutLeaveRequestNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutSalaryDeductionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: LeaveDocumentUncheckedUpdateManyWithoutLeaveRequestNestedInput
  }

  export type UserCreateManyManagerInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    department?: string | null
    profilePicture?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestCreateManyUserInput = {
    id?: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestCreateManyApproverInput = {
    id?: string
    userId: string
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.LeaveStatus
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    isHalfDay?: boolean
    halfDayPeriod?: $Enums.HalfDayPeriod | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveBalanceCreateManyUserInput = {
    id?: string
    year: number
    annualTotal?: number
    annualUsed?: number
    annualRemaining?: number
    sickTotal?: number
    sickUsed?: number
    sickRemaining?: number
    casualTotal?: number
    casualUsed?: number
    casualRemaining?: number
    maternityTotal?: number
    maternityUsed?: number
    maternityRemaining?: number
    paternityTotal?: number
    paternityUsed?: number
    paternityRemaining?: number
    emergencyTotal?: number
    emergencyUsed?: number
    emergencyRemaining?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    userName: string
    action: string
    targetId?: string | null
    targetType?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type LeavePolicyCreateManyCreatorInput = {
    id?: string
    leaveType: string
    totalDaysPerYear: number
    canCarryForward?: boolean
    maxCarryForwardDays?: number | null
    requiresApproval?: boolean
    allowHalfDay?: boolean
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    date: Date | string
    type: $Enums.HolidayType
    isRecurring?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordCreateManyUserInput = {
    id?: string
    date: Date | string
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    status?: $Enums.AttendanceStatus
    hoursWorked?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isHoliday?: boolean
    isWeekend?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendancePolicyCreateManyCreatorInput = {
    id?: string
    name: string
    workingHoursPerDay?: Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: number
    overtimeThresholdHours?: Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: boolean
    requireCheckIn?: boolean
    requireCheckOut?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeSalaryCreateManyUserInput = {
    id?: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonthlySalaryCreateManyUserInput = {
    id?: string
    employeeSalaryId: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    approvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonthlySalaryCreateManyApproverInput = {
    id?: string
    employeeSalaryId: string
    userId: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveRequestUncheckedUpdateManyWithoutApproverNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdPolicies?: LeavePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    createdHolidays?: HolidayUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAttendancePolicies?: AttendancePolicyUncheckedUpdateManyWithoutCreatorNestedInput
    employeeSalary?: EmployeeSalaryUncheckedUpdateManyWithoutUserNestedInput
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutUserNestedInput
    approvedSalaries?: MonthlySalaryUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutApprovedLeavesNestedInput
    documents?: LeaveDocumentUpdateManyWithoutLeaveRequestNestedInput
    salaryDeductions?: SalaryDeductionUpdateManyWithoutLeaveRequestNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: LeaveDocumentUncheckedUpdateManyWithoutLeaveRequestNestedInput
    salaryDeductions?: SalaryDeductionUncheckedUpdateManyWithoutLeaveRequestNestedInput
  }

  export type LeaveRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaveRequestsNestedInput
    documents?: LeaveDocumentUpdateManyWithoutLeaveRequestNestedInput
    salaryDeductions?: SalaryDeductionUpdateManyWithoutLeaveRequestNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: LeaveDocumentUncheckedUpdateManyWithoutLeaveRequestNestedInput
    salaryDeductions?: SalaryDeductionUncheckedUpdateManyWithoutLeaveRequestNestedInput
  }

  export type LeaveRequestUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfDayPeriod?: NullableEnumHalfDayPeriodFieldUpdateOperationsInput | $Enums.HalfDayPeriod | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    annualTotal?: IntFieldUpdateOperationsInput | number
    annualUsed?: IntFieldUpdateOperationsInput | number
    annualRemaining?: IntFieldUpdateOperationsInput | number
    sickTotal?: IntFieldUpdateOperationsInput | number
    sickUsed?: IntFieldUpdateOperationsInput | number
    sickRemaining?: IntFieldUpdateOperationsInput | number
    casualTotal?: IntFieldUpdateOperationsInput | number
    casualUsed?: IntFieldUpdateOperationsInput | number
    casualRemaining?: IntFieldUpdateOperationsInput | number
    maternityTotal?: IntFieldUpdateOperationsInput | number
    maternityUsed?: IntFieldUpdateOperationsInput | number
    maternityRemaining?: IntFieldUpdateOperationsInput | number
    paternityTotal?: IntFieldUpdateOperationsInput | number
    paternityUsed?: IntFieldUpdateOperationsInput | number
    paternityRemaining?: IntFieldUpdateOperationsInput | number
    emergencyTotal?: IntFieldUpdateOperationsInput | number
    emergencyUsed?: IntFieldUpdateOperationsInput | number
    emergencyRemaining?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    annualTotal?: IntFieldUpdateOperationsInput | number
    annualUsed?: IntFieldUpdateOperationsInput | number
    annualRemaining?: IntFieldUpdateOperationsInput | number
    sickTotal?: IntFieldUpdateOperationsInput | number
    sickUsed?: IntFieldUpdateOperationsInput | number
    sickRemaining?: IntFieldUpdateOperationsInput | number
    casualTotal?: IntFieldUpdateOperationsInput | number
    casualUsed?: IntFieldUpdateOperationsInput | number
    casualRemaining?: IntFieldUpdateOperationsInput | number
    maternityTotal?: IntFieldUpdateOperationsInput | number
    maternityUsed?: IntFieldUpdateOperationsInput | number
    maternityRemaining?: IntFieldUpdateOperationsInput | number
    paternityTotal?: IntFieldUpdateOperationsInput | number
    paternityUsed?: IntFieldUpdateOperationsInput | number
    paternityRemaining?: IntFieldUpdateOperationsInput | number
    emergencyTotal?: IntFieldUpdateOperationsInput | number
    emergencyUsed?: IntFieldUpdateOperationsInput | number
    emergencyRemaining?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    annualTotal?: IntFieldUpdateOperationsInput | number
    annualUsed?: IntFieldUpdateOperationsInput | number
    annualRemaining?: IntFieldUpdateOperationsInput | number
    sickTotal?: IntFieldUpdateOperationsInput | number
    sickUsed?: IntFieldUpdateOperationsInput | number
    sickRemaining?: IntFieldUpdateOperationsInput | number
    casualTotal?: IntFieldUpdateOperationsInput | number
    casualUsed?: IntFieldUpdateOperationsInput | number
    casualRemaining?: IntFieldUpdateOperationsInput | number
    maternityTotal?: IntFieldUpdateOperationsInput | number
    maternityUsed?: IntFieldUpdateOperationsInput | number
    maternityRemaining?: IntFieldUpdateOperationsInput | number
    paternityTotal?: IntFieldUpdateOperationsInput | number
    paternityUsed?: IntFieldUpdateOperationsInput | number
    paternityRemaining?: IntFieldUpdateOperationsInput | number
    emergencyTotal?: IntFieldUpdateOperationsInput | number
    emergencyUsed?: IntFieldUpdateOperationsInput | number
    emergencyRemaining?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeavePolicyUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    totalDaysPerYear?: IntFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForwardDays?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeavePolicyUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    totalDaysPerYear?: IntFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForwardDays?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeavePolicyUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    totalDaysPerYear?: IntFieldUpdateOperationsInput | number
    canCarryForward?: BoolFieldUpdateOperationsInput | boolean
    maxCarryForwardDays?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    allowHalfDay?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumHolidayTypeFieldUpdateOperationsInput | $Enums.HolidayType
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumHolidayTypeFieldUpdateOperationsInput | $Enums.HolidayType
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumHolidayTypeFieldUpdateOperationsInput | $Enums.HolidayType
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    isWeekend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    isWeekend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    isWeekend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendancePolicyUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingHoursPerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: IntFieldUpdateOperationsInput | number
    overtimeThresholdHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: BoolFieldUpdateOperationsInput | boolean
    requireCheckIn?: BoolFieldUpdateOperationsInput | boolean
    requireCheckOut?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendancePolicyUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingHoursPerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: IntFieldUpdateOperationsInput | number
    overtimeThresholdHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: BoolFieldUpdateOperationsInput | boolean
    requireCheckIn?: BoolFieldUpdateOperationsInput | boolean
    requireCheckOut?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendancePolicyUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingHoursPerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lateThresholdMinutes?: IntFieldUpdateOperationsInput | number
    overtimeThresholdHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowFlexibleHours?: BoolFieldUpdateOperationsInput | boolean
    requireCheckIn?: BoolFieldUpdateOperationsInput | boolean
    requireCheckOut?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeSalaryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlySalaries?: MonthlySalaryUpdateManyWithoutEmployeeSalaryNestedInput
  }

  export type EmployeeSalaryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlySalaries?: MonthlySalaryUncheckedUpdateManyWithoutEmployeeSalaryNestedInput
  }

  export type EmployeeSalaryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlySalaryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeSalary?: EmployeeSalaryUpdateOneRequiredWithoutMonthlySalariesNestedInput
    approver?: UserUpdateOneWithoutApprovedSalariesNestedInput
    deductions?: SalaryDeductionUpdateManyWithoutMonthlySalaryNestedInput
  }

  export type MonthlySalaryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeSalaryId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deductions?: SalaryDeductionUncheckedUpdateManyWithoutMonthlySalaryNestedInput
  }

  export type MonthlySalaryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeSalaryId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlySalaryUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeSalary?: EmployeeSalaryUpdateOneRequiredWithoutMonthlySalariesNestedInput
    user?: UserUpdateOneRequiredWithoutMonthlySalariesNestedInput
    deductions?: SalaryDeductionUpdateManyWithoutMonthlySalaryNestedInput
  }

  export type MonthlySalaryUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeSalaryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deductions?: SalaryDeductionUncheckedUpdateManyWithoutMonthlySalaryNestedInput
  }

  export type MonthlySalaryUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeSalaryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveDocumentCreateManyLeaveRequestInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
  }

  export type SalaryDeductionCreateManyLeaveRequestInput = {
    id?: string
    monthlySalaryId: string
    type: $Enums.DeductionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    createdAt?: Date | string
  }

  export type LeaveDocumentUpdateWithoutLeaveRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveDocumentUncheckedUpdateWithoutLeaveRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveDocumentUncheckedUpdateManyWithoutLeaveRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryDeductionUpdateWithoutLeaveRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDeductionTypeFieldUpdateOperationsInput | $Enums.DeductionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlySalary?: MonthlySalaryUpdateOneRequiredWithoutDeductionsNestedInput
  }

  export type SalaryDeductionUncheckedUpdateWithoutLeaveRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthlySalaryId?: StringFieldUpdateOperationsInput | string
    type?: EnumDeductionTypeFieldUpdateOperationsInput | $Enums.DeductionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryDeductionUncheckedUpdateManyWithoutLeaveRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthlySalaryId?: StringFieldUpdateOperationsInput | string
    type?: EnumDeductionTypeFieldUpdateOperationsInput | $Enums.DeductionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlySalaryCreateManyEmployeeSalaryInput = {
    id?: string
    userId: string
    year: number
    month: number
    baseSalary: Decimal | DecimalJsLike | number | string
    grossSalary: Decimal | DecimalJsLike | number | string
    totalDeductions?: Decimal | DecimalJsLike | number | string
    netSalary: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    calculatedAt?: Date | string | null
    approvedAt?: Date | string | null
    paidAt?: Date | string | null
    approvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonthlySalaryUpdateWithoutEmployeeSalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMonthlySalariesNestedInput
    approver?: UserUpdateOneWithoutApprovedSalariesNestedInput
    deductions?: SalaryDeductionUpdateManyWithoutMonthlySalaryNestedInput
  }

  export type MonthlySalaryUncheckedUpdateWithoutEmployeeSalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deductions?: SalaryDeductionUncheckedUpdateManyWithoutMonthlySalaryNestedInput
  }

  export type MonthlySalaryUncheckedUpdateManyWithoutEmployeeSalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    calculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryDeductionCreateManyMonthlySalaryInput = {
    id?: string
    type: $Enums.DeductionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    leaveRequestId?: string | null
    isTaxable?: boolean
    createdAt?: Date | string
  }

  export type SalaryDeductionUpdateWithoutMonthlySalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDeductionTypeFieldUpdateOperationsInput | $Enums.DeductionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveRequest?: LeaveRequestUpdateOneWithoutSalaryDeductionsNestedInput
  }

  export type SalaryDeductionUncheckedUpdateWithoutMonthlySalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDeductionTypeFieldUpdateOperationsInput | $Enums.DeductionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaveRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryDeductionUncheckedUpdateManyWithoutMonthlySalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDeductionTypeFieldUpdateOperationsInput | $Enums.DeductionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaveRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveRequestCountOutputTypeDefaultArgs instead
     */
    export type LeaveRequestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveRequestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeSalaryCountOutputTypeDefaultArgs instead
     */
    export type EmployeeSalaryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeSalaryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MonthlySalaryCountOutputTypeDefaultArgs instead
     */
    export type MonthlySalaryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MonthlySalaryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveRequestDefaultArgs instead
     */
    export type LeaveRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveBalanceDefaultArgs instead
     */
    export type LeaveBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveBalanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeavePolicyDefaultArgs instead
     */
    export type LeavePolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeavePolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveDocumentDefaultArgs instead
     */
    export type LeaveDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HolidayDefaultArgs instead
     */
    export type HolidayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HolidayDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttendanceRecordDefaultArgs instead
     */
    export type AttendanceRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttendanceRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttendancePolicyDefaultArgs instead
     */
    export type AttendancePolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttendancePolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeSalaryDefaultArgs instead
     */
    export type EmployeeSalaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeSalaryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MonthlySalaryDefaultArgs instead
     */
    export type MonthlySalaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MonthlySalaryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalaryDeductionDefaultArgs instead
     */
    export type SalaryDeductionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalaryDeductionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}